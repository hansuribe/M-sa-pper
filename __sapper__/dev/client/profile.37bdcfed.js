import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, a as space, t as text, c as claim_element, b as children, f as detach_dev, g as claim_space, h as claim_text, j as attr_dev, l as add_location, k as set_style, m as insert_dev, n as append_dev, o as set_data_dev, p as noop, q as create_component, u as claim_component, w as mount_component, x as transition_in, y as transition_out, z as destroy_component, B as create_slot, K as getContext, L as validate_store, M as component_subscribe, J as writable, N as derived, O as onMount, P as setContext, H as get_slot_context, I as get_slot_changes, Q as onDestroy, R as assign, T as exclude_internal_props, U as empty, V as group_outros, W as check_outros, X as get_spread_update, Y as get_spread_object, C as createEventDispatcher, Z as set_attributes, F as listen_dev, r as query_selector_all } from './client.b787aeaa.js';
import { N as Navbar, T as Tabbar } from './Tabbar.440a2582.js';
import { u as username } from './stores.ab784b93.js';

/* src/components/ProfileHeader.svelte generated by Svelte v3.22.2 */

const file = "src/components/ProfileHeader.svelte";

function create_fragment(ctx) {
	let main;
	let div8;
	let div0;
	let t0;
	let div5;
	let div4;
	let div1;
	let t1;
	let div2;
	let h3;
	let t2;
	let t3;
	let h5;
	let t4;
	let t5;
	let div3;
	let t6;
	let t7;
	let div6;
	let t8;
	let div7;

	const block = {
		c: function create() {
			main = element("main");
			div8 = element("div");
			div0 = element("div");
			t0 = space();
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			h3 = element("h3");
			t2 = text(/*alias*/ ctx[0]);
			t3 = space();
			h5 = element("h5");
			t4 = text(/*name*/ ctx[1]);
			t5 = space();
			div3 = element("div");
			t6 = text(/*level*/ ctx[3]);
			t7 = space();
			div6 = element("div");
			t8 = space();
			div7 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			div8 = claim_element(main_nodes, "DIV", { id: true, class: true });
			var div8_nodes = children(div8);
			div0 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div8_nodes);
			div5 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			div1 = claim_element(div4_nodes, "DIV", { id: true, style: true, class: true });
			children(div1).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*alias*/ ctx[0]);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			h5 = claim_element(div2_nodes, "H5", { class: true });
			var h5_nodes = children(h5);
			t4 = claim_text(h5_nodes, /*name*/ ctx[1]);
			h5_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t5 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			t6 = claim_text(div3_nodes, /*level*/ ctx[3]);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t7 = claim_space(div8_nodes);
			div6 = claim_element(div8_nodes, "DIV", { id: true, style: true, class: true });
			children(div6).forEach(detach_dev);
			t8 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div7).forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "id", "layer1");
			attr_dev(div0, "class", "svelte-15zeztu");
			add_location(div0, file, 6, 4, 97);
			attr_dev(div1, "id", "profilepicture");
			set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			attr_dev(div1, "class", "svelte-15zeztu");
			add_location(div1, file, 9, 8, 180);
			attr_dev(h3, "class", "svelte-15zeztu");
			add_location(h3, file, 13, 10, 315);
			attr_dev(h5, "class", "svelte-15zeztu");
			add_location(h5, file, 14, 10, 342);
			attr_dev(div2, "id", "userinfo");
			attr_dev(div2, "class", "svelte-15zeztu");
			add_location(div2, file, 12, 8, 285);
			attr_dev(div3, "id", "level");
			attr_dev(div3, "class", "svelte-15zeztu");
			add_location(div3, file, 17, 8, 443);
			attr_dev(div4, "id", "content");
			attr_dev(div4, "class", "svelte-15zeztu");
			add_location(div4, file, 8, 6, 153);
			attr_dev(div5, "id", "contentwrapper");
			attr_dev(div5, "class", "svelte-15zeztu");
			add_location(div5, file, 7, 4, 121);
			attr_dev(div6, "id", "layer2");
			set_style(div6, "background-image", "url(gta.jpg)");
			attr_dev(div6, "class", "svelte-15zeztu");
			add_location(div6, file, 21, 4, 563);
			attr_dev(div7, "id", "layer3");
			attr_dev(div7, "class", "svelte-15zeztu");
			add_location(div7, file, 22, 4, 627);
			attr_dev(div8, "id", "head");
			attr_dev(div8, "class", "svelte-15zeztu");
			add_location(div8, file, 5, 2, 77);
			add_location(main, file, 4, 0, 68);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div8);
			append_dev(div8, div0);
			append_dev(div8, t0);
			append_dev(div8, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div4, t1);
			append_dev(div4, div2);
			append_dev(div2, h3);
			append_dev(h3, t2);
			append_dev(div2, t3);
			append_dev(div2, h5);
			append_dev(h5, t4);
			append_dev(div4, t5);
			append_dev(div4, div3);
			append_dev(div3, t6);
			append_dev(div8, t7);
			append_dev(div8, div6);
			append_dev(div8, t8);
			append_dev(div8, div7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*profilepicture*/ 4) {
				set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			}

			if (dirty & /*alias*/ 1) set_data_dev(t2, /*alias*/ ctx[0]);
			if (dirty & /*name*/ 2) set_data_dev(t4, /*name*/ ctx[1]);
			if (dirty & /*level*/ 8) set_data_dev(t6, /*level*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { alias } = $$props,
		{ name } = $$props,
		{ profilepicture } = $$props,
		{ level } = $$props;

	const writable_props = ["alias", "name", "profilepicture", "level"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProfileHeader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ProfileHeader", $$slots, []);

	$$self.$set = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	$$self.$capture_state = () => ({ alias, name, profilepicture, level });

	$$self.$inject_state = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [alias, name, profilepicture, level];
}

class ProfileHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			alias: 0,
			name: 1,
			profilepicture: 2,
			level: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProfileHeader",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*alias*/ ctx[0] === undefined && !("alias" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'alias'");
		}

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'name'");
		}

		if (/*profilepicture*/ ctx[2] === undefined && !("profilepicture" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'profilepicture'");
		}

		if (/*level*/ ctx[3] === undefined && !("level" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'level'");
		}
	}

	get alias() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alias(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get profilepicture() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set profilepicture(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/AboutMeTile.svelte generated by Svelte v3.22.2 */

const file$1 = "src/components/AboutMeTile.svelte";

function create_fragment$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, "Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", "aboutme");
			attr_dev(div, "class", "svelte-3tnd7d");
			add_location(div, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AboutMeTile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AboutMeTile", $$slots, []);
	return [];
}

class AboutMeTile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AboutMeTile",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/MainBadge.svelte generated by Svelte v3.22.2 */

const file$2 = "src/components/MainBadge.svelte";

function create_fragment$2(ctx) {
	let div1;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let h2;
	let t1;
	let t2;
	let h4;
	let t3;

	const block = {
		c: function create() {
			div1 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			h2 = element("h2");
			t1 = text("Years of Service");
			t2 = space();
			h4 = element("h4");
			t3 = text("250 XP");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			img = claim_element(div1_nodes, "IMG", { src: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Years of Service");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			h4 = claim_element(div0_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t3 = claim_text(h4_nodes, "250 XP");
			h4_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "https://steamcommunity-a.akamaihd.net/public/images/badges/02_years/steamyears5_54.png")) attr_dev(img, "src", img_src_value);
			add_location(img, file$2, 1, 2, 23);
			attr_dev(h2, "class", "svelte-vmk8bb");
			add_location(h2, file$2, 4, 4, 159);
			attr_dev(h4, "class", "svelte-vmk8bb");
			add_location(h4, file$2, 5, 4, 189);
			attr_dev(div0, "id", "badgemaininfo");
			attr_dev(div0, "class", "svelte-vmk8bb");
			add_location(div0, file$2, 3, 2, 130);
			attr_dev(div1, "id", "badgemain");
			attr_dev(div1, "class", "svelte-vmk8bb");
			add_location(div1, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h2);
			append_dev(h2, t1);
			append_dev(div0, t2);
			append_dev(div0, h4);
			append_dev(h4, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MainBadge> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MainBadge", $$slots, []);
	return [];
}

class MainBadge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MainBadge",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/components/BadgeShowcase.svelte generated by Svelte v3.22.2 */

const file$3 = "src/components/BadgeShowcase.svelte";

function create_fragment$3(ctx) {
	let div;
	let img0;
	let img0_src_value;
	let t0;
	let img1;
	let img1_src_value;
	let t1;
	let img2;
	let img2_src_value;
	let t2;
	let img3;
	let img3_src_value;
	let t3;
	let img4;
	let img4_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img0 = element("img");
			t0 = space();
			img1 = element("img");
			t1 = space();
			img2 = element("img");
			t2 = space();
			img3 = element("img");
			t3 = space();
			img4 = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			img0 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t0 = claim_space(div_nodes);
			img1 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t1 = claim_space(div_nodes);
			img2 = claim_element(div_nodes, "IMG", { src: true, class: true });
			t2 = claim_space(div_nodes);
			img3 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t3 = claim_space(div_nodes);
			img4 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img0.src !== (img0_src_value = /*images*/ ctx[0][0].link)) attr_dev(img0, "src", img0_src_value);
			set_style(img0, "height", "32px");
			attr_dev(img0, "class", "svelte-soube2");
			add_location(img0, file$3, 4, 2, 67);
			if (img1.src !== (img1_src_value = /*images*/ ctx[0][1].link)) attr_dev(img1, "src", img1_src_value);
			set_style(img1, "height", "32px");
			attr_dev(img1, "class", "svelte-soube2");
			add_location(img1, file$3, 5, 2, 122);
			if (img2.src !== (img2_src_value = /*images*/ ctx[0][2].link)) attr_dev(img2, "src", img2_src_value);
			attr_dev(img2, "class", "svelte-soube2");
			add_location(img2, file$3, 6, 2, 177);
			if (img3.src !== (img3_src_value = /*images*/ ctx[0][3].link)) attr_dev(img3, "src", img3_src_value);
			set_style(img3, "height", "36px");
			attr_dev(img3, "class", "svelte-soube2");
			add_location(img3, file$3, 7, 2, 210);
			if (img4.src !== (img4_src_value = /*images*/ ctx[0][4].link)) attr_dev(img4, "src", img4_src_value);
			set_style(img4, "height", "38px");
			attr_dev(img4, "class", "svelte-soube2");
			add_location(img4, file$3, 8, 2, 265);
			attr_dev(div, "id", "badgeshowcase");
			attr_dev(div, "class", "svelte-soube2");
			add_location(div, file$3, 3, 0, 40);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img0);
			append_dev(div, t0);
			append_dev(div, img1);
			append_dev(div, t1);
			append_dev(div, img2);
			append_dev(div, t2);
			append_dev(div, img3);
			append_dev(div, t3);
			append_dev(div, img4);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*images*/ 1 && img0.src !== (img0_src_value = /*images*/ ctx[0][0].link)) {
				attr_dev(img0, "src", img0_src_value);
			}

			if (dirty & /*images*/ 1 && img1.src !== (img1_src_value = /*images*/ ctx[0][1].link)) {
				attr_dev(img1, "src", img1_src_value);
			}

			if (dirty & /*images*/ 1 && img2.src !== (img2_src_value = /*images*/ ctx[0][2].link)) {
				attr_dev(img2, "src", img2_src_value);
			}

			if (dirty & /*images*/ 1 && img3.src !== (img3_src_value = /*images*/ ctx[0][3].link)) {
				attr_dev(img3, "src", img3_src_value);
			}

			if (dirty & /*images*/ 1 && img4.src !== (img4_src_value = /*images*/ ctx[0][4].link)) {
				attr_dev(img4, "src", img4_src_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { images } = $$props;
	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BadgeShowcase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("BadgeShowcase", $$slots, []);

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	$$self.$capture_state = () => ({ images });

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [images];
}

class BadgeShowcase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { images: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BadgeShowcase",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*images*/ ctx[0] === undefined && !("images" in props)) {
			console.warn("<BadgeShowcase> was created without expected prop 'images'");
		}
	}

	get images() {
		throw new Error("<BadgeShowcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<BadgeShowcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Badges.svelte generated by Svelte v3.22.2 */
const file$4 = "src/components/Badges.svelte";

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;
	let t3;
	let t4;
	let current;
	const mainbadge = new MainBadge({ $$inline: true });

	const badgeshowcase = new BadgeShowcase({
			props: {
				images: [
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/37_summer2019/level25_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/730/54e40b9e2288fbab8bd4c6537b0325d405c7e1b0.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/28_springcleaning2018/bronze_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/762800/d467ec8eaed4643c47fbed43ed781daef2525963.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/27_steamawardnominations/level04_80.png"
					}
				]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text("Badges");
			t1 = space();
			h2 = element("h2");
			t2 = text("8");
			t3 = space();
			create_component(mainbadge.$$.fragment);
			t4 = space();
			create_component(badgeshowcase.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Badges");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "8");
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			claim_component(mainbadge.$$.fragment, div1_nodes);
			t4 = claim_space(div1_nodes);
			claim_component(badgeshowcase.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$4, 7, 4, 159);
			add_location(h2, file$4, 8, 4, 179);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-1ye7e9i");
			add_location(div0, file$4, 6, 2, 138);
			attr_dev(div1, "id", "badges");
			attr_dev(div1, "class", "svelte-1ye7e9i");
			add_location(div1, file$4, 5, 0, 118);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
			append_dev(div1, t3);
			mount_component(mainbadge, div1, null);
			append_dev(div1, t4);
			mount_component(badgeshowcase, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(mainbadge.$$.fragment, local);
			transition_in(badgeshowcase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mainbadge.$$.fragment, local);
			transition_out(badgeshowcase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(mainbadge);
			destroy_component(badgeshowcase);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Badges> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Badges", $$slots, []);
	$$self.$capture_state = () => ({ MainBadge, BadgeShowcase });
	return [];
}

class Badges extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badges",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/components/Friends.svelte generated by Svelte v3.22.2 */

const file$5 = "src/components/Friends.svelte";

function create_fragment$5(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text("Friends");
			t1 = space();
			h2 = element("h2");
			t2 = text("72");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Friends");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "72");
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$5, 2, 4, 42);
			add_location(h2, file$5, 3, 4, 63);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-hallut");
			add_location(div0, file$5, 1, 2, 21);
			attr_dev(div1, "id", "friends");
			attr_dev(div1, "class", "svelte-hallut");
			add_location(div1, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Friends> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Friends", $$slots, []);
	return [];
}

class Friends extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Friends",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/components/About.svelte generated by Svelte v3.22.2 */
const file$6 = "src/components/About.svelte";

function create_fragment$6(ctx) {
	let main;
	let t0;
	let t1;
	let current;
	const aboutmetile = new AboutMeTile({ $$inline: true });
	const badges = new Badges({ $$inline: true });
	const friends = new Friends({ $$inline: true });

	const block = {
		c: function create() {
			main = element("main");
			create_component(aboutmetile.$$.fragment);
			t0 = space();
			create_component(badges.$$.fragment);
			t1 = space();
			create_component(friends.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(aboutmetile.$$.fragment, main_nodes);
			t0 = claim_space(main_nodes);
			claim_component(badges.$$.fragment, main_nodes);
			t1 = claim_space(main_nodes);
			claim_component(friends.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "svelte-kvh3dq");
			add_location(main, file$6, 9, 0, 278);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(aboutmetile, main, null);
			append_dev(main, t0);
			mount_component(badges, main, null);
			append_dev(main, t1);
			mount_component(friends, main, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(aboutmetile.$$.fragment, local);
			transition_in(badges.$$.fragment, local);
			transition_in(friends.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(aboutmetile.$$.fragment, local);
			transition_out(badges.$$.fragment, local);
			transition_out(friends.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(aboutmetile);
			destroy_component(badges);
			destroy_component(friends);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("About", $$slots, []);
	$$self.$capture_state = () => ({ AboutMeTile, Badges, Friends });
	return [];
}

class About extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: create_fragment$6.name
		});
	}
}

const LOCATION = {};
const ROUTER = {};

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

function getLocation(source) {
  return {
    ...source.location,
    state: source.history.state,
    key: (source.history.state && source.history.state.key) || "initial"
  };
}

function createHistory(source, options) {
  const listeners = [];
  let location = getLocation(source);

  return {
    get location() {
      return location;
    },

    listen(listener) {
      listeners.push(listener);

      const popstateListener = () => {
        location = getLocation(source);
        listener({ location, action: "POP" });
      };

      source.addEventListener("popstate", popstateListener);

      return () => {
        source.removeEventListener("popstate", popstateListener);

        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    },

    navigate(to, { state, replace = false } = {}) {
      state = { ...state, key: Date.now() + "" };
      // try...catch iOS Safari limits to 100 pushState calls
      try {
        if (replace) {
          source.history.replaceState(state, null, to);
        } else {
          source.history.pushState(state, null, to);
        }
      } catch (e) {
        source.location[replace ? "replace" : "assign"](to);
      }

      location = getLocation(source);
      listeners.forEach(listener => listener({ location, action: "PUSH" }));
    }
  };
}

// Stores history entries in memory for testing or other platforms like Native
function createMemorySource(initialPathname = "/") {
  let index = 0;
  const stack = [{ pathname: initialPathname, search: "" }];
  const states = [];

  return {
    get location() {
      return stack[index];
    },
    addEventListener(name, fn) {},
    removeEventListener(name, fn) {},
    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        index++;
        stack.push({ pathname, search });
        states.push(state);
      },
      replaceState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        stack[index] = { pathname, search };
        states[index] = state;
      }
    }
  };
}

// Global history uses window.history as the source if available,
// otherwise a memory history
const canUseDOM = Boolean(
  typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
);
const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
const { navigate } = globalHistory;

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

const paramRe = /^:(.+)/;

const SEGMENT_POINTS = 4;
const STATIC_POINTS = 3;
const DYNAMIC_POINTS = 2;
const SPLAT_PENALTY = 1;
const ROOT_POINTS = 1;

/**
 * Check if `string` starts with `search`
 * @param {string} string
 * @param {string} search
 * @return {boolean}
 */
function startsWith(string, search) {
  return string.substr(0, search.length) === search;
}

/**
 * Check if `segment` is a root segment
 * @param {string} segment
 * @return {boolean}
 */
function isRootSegment(segment) {
  return segment === "";
}

/**
 * Check if `segment` is a dynamic segment
 * @param {string} segment
 * @return {boolean}
 */
function isDynamic(segment) {
  return paramRe.test(segment);
}

/**
 * Check if `segment` is a splat
 * @param {string} segment
 * @return {boolean}
 */
function isSplat(segment) {
  return segment[0] === "*";
}

/**
 * Split up the URI into segments delimited by `/`
 * @param {string} uri
 * @return {string[]}
 */
function segmentize(uri) {
  return (
    uri
      // Strip starting/ending `/`
      .replace(/(^\/+|\/+$)/g, "")
      .split("/")
  );
}

/**
 * Strip `str` of potential start and end `/`
 * @param {string} str
 * @return {string}
 */
function stripSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
}

/**
 * Score a route depending on how its individual segments look
 * @param {object} route
 * @param {number} index
 * @return {object}
 */
function rankRoute(route, index) {
  const score = route.default
    ? 0
    : segmentize(route.path).reduce((score, segment) => {
        score += SEGMENT_POINTS;

        if (isRootSegment(segment)) {
          score += ROOT_POINTS;
        } else if (isDynamic(segment)) {
          score += DYNAMIC_POINTS;
        } else if (isSplat(segment)) {
          score -= SEGMENT_POINTS + SPLAT_PENALTY;
        } else {
          score += STATIC_POINTS;
        }

        return score;
      }, 0);

  return { route, score, index };
}

/**
 * Give a score to all routes and sort them on that
 * @param {object[]} routes
 * @return {object[]}
 */
function rankRoutes(routes) {
  return (
    routes
      .map(rankRoute)
      // If two routes have the exact same score, we go by index instead
      .sort((a, b) =>
        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
      )
  );
}

/**
 * Ranks and picks the best route to match. Each segment gets the highest
 * amount of points, then the type of segment gets an additional amount of
 * points where
 *
 *  static > dynamic > splat > root
 *
 * This way we don't have to worry about the order of our routes, let the
 * computers do it.
 *
 * A route looks like this
 *
 *  { path, default, value }
 *
 * And a returned match looks like:
 *
 *  { route, params, uri }
 *
 * @param {object[]} routes
 * @param {string} uri
 * @return {?object}
 */
function pick(routes, uri) {
  let match;
  let default_;

  const [uriPathname] = uri.split("?");
  const uriSegments = segmentize(uriPathname);
  const isRootUri = uriSegments[0] === "";
  const ranked = rankRoutes(routes);

  for (let i = 0, l = ranked.length; i < l; i++) {
    const route = ranked[i].route;
    let missed = false;

    if (route.default) {
      default_ = {
        route,
        params: {},
        uri
      };
      continue;
    }

    const routeSegments = segmentize(route.path);
    const params = {};
    const max = Math.max(uriSegments.length, routeSegments.length);
    let index = 0;

    for (; index < max; index++) {
      const routeSegment = routeSegments[index];
      const uriSegment = uriSegments[index];

      if (routeSegment !== undefined && isSplat(routeSegment)) {
        // Hit a splat, just grab the rest, and return a match
        // uri:   /files/documents/work
        // route: /files/* or /files/*splatname
        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

        params[splatName] = uriSegments
          .slice(index)
          .map(decodeURIComponent)
          .join("/");
        break;
      }

      if (uriSegment === undefined) {
        // URI is shorter than the route, no match
        // uri:   /users
        // route: /users/:userId
        missed = true;
        break;
      }

      let dynamicMatch = paramRe.exec(routeSegment);

      if (dynamicMatch && !isRootUri) {
        const value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        // Current segments don't match, not dynamic, not splat, so no match
        // uri:   /users/123/settings
        // route: /users/:id/profile
        missed = true;
        break;
      }
    }

    if (!missed) {
      match = {
        route,
        params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }

  return match || default_ || null;
}

/**
 * Check if the `path` matches the `uri`.
 * @param {string} path
 * @param {string} uri
 * @return {?object}
 */
function match(route, uri) {
  return pick([route], uri);
}

/**
 * Add the query to the pathname if a query is given
 * @param {string} pathname
 * @param {string} [query]
 * @return {string}
 */
function addQuery(pathname, query) {
  return pathname + (query ? `?${query}` : "");
}

/**
 * Resolve URIs as though every path is a directory, no files. Relative URIs
 * in the browser can feel awkward because not only can you be "in a directory",
 * you can be "at a file", too. For example:
 *
 *  browserSpecResolve('foo', '/bar/') => /bar/foo
 *  browserSpecResolve('foo', '/bar') => /foo
 *
 * But on the command line of a file system, it's not as complicated. You can't
 * `cd` from a file, only directories. This way, links have to know less about
 * their current path. To go deeper you can do this:
 *
 *  <Link to="deeper"/>
 *  // instead of
 *  <Link to=`{${props.uri}/deeper}`/>
 *
 * Just like `cd`, if you want to go deeper from the command line, you do this:
 *
 *  cd deeper
 *  # not
 *  cd $(pwd)/deeper
 *
 * By treating every path as a directory, linking to relative paths should
 * require less contextual information and (fingers crossed) be more intuitive.
 * @param {string} to
 * @param {string} base
 * @return {string}
 */
function resolve(to, base) {
  // /foo/bar, /baz/qux => /foo/bar
  if (startsWith(to, "/")) {
    return to;
  }

  const [toPathname, toQuery] = to.split("?");
  const [basePathname] = base.split("?");
  const toSegments = segmentize(toPathname);
  const baseSegments = segmentize(basePathname);

  // ?a=b, /users?b=c => /users?a=b
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }

  // profile, /users/789 => /users/789/profile
  if (!startsWith(toSegments[0], ".")) {
    const pathname = baseSegments.concat(toSegments).join("/");

    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }

  // ./       , /users/123 => /users/123
  // ../      , /users/123 => /users
  // ../..    , /users/123 => /
  // ../../one, /a/b/c/d   => /a/b/one
  // .././one , /a/b/c/d   => /a/b/c/one
  const allSegments = baseSegments.concat(toSegments);
  const segments = [];

  allSegments.forEach(segment => {
    if (segment === "..") {
      segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });

  return addQuery("/" + segments.join("/"), toQuery);
}

/**
 * Combines the `basepath` and the `path` into one path.
 * @param {string} basepath
 * @param {string} path
 */
function combinePaths(basepath, path) {
  return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
}

/**
 * Decides whether a given `event` should result in a navigation or not.
 * @param {object} event
 */
function shouldNavigate(event) {
  return (
    !event.defaultPrevented &&
    event.button === 0 &&
    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
  );
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.22.2 */

function create_fragment$7(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let $routes;
	let { basepath = "/" } = $$props;
	let { url = null } = $$props;
	const locationContext = getContext(LOCATION);
	const routerContext = getContext(ROUTER);
	const routes = writable([]);
	validate_store(routes, "routes");
	component_subscribe($$self, routes, value => $$invalidate(8, $routes = value));
	const activeRoute = writable(null);
	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

	// If locationContext is not set, this is the topmost Router in the tree.
	// If the `url` prop is given we force the location to it.
	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(7, $location = value));

	// If routerContext is set, the routerBase of the parent Router
	// will be the base for this Router's descendants.
	// If routerContext is not set, the path and resolved uri will both
	// have the value of the basepath prop.
	const base = routerContext
	? routerContext.routerBase
	: writable({ path: basepath, uri: basepath });

	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(6, $base = value));

	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
		// If there is no activeRoute, the routerBase will be identical to the base.
		if (activeRoute === null) {
			return base;
		}

		const { path: basepath } = base;
		const { route, uri } = activeRoute;

		// Remove the potential /* or /*splatname from
		// the end of the child Routes relative paths.
		const path = route.default
		? basepath
		: route.path.replace(/\*.*$/, "");

		return { path, uri };
	});

	function registerRoute(route) {
		const { path: basepath } = $base;
		let { path } = route;

		// We store the original path in the _path property so we can reuse
		// it when the basepath changes. The only thing that matters is that
		// the route reference is intact, so mutation is fine.
		route._path = path;

		route.path = combinePaths(basepath, path);

		if (typeof window === "undefined") {
			// In SSR we should set the activeRoute immediately if it is a match.
			// If there are more Routes being registered after a match is found,
			// we just skip them.
			if (hasActiveRoute) {
				return;
			}

			const matchingRoute = match(route, $location.pathname);

			if (matchingRoute) {
				activeRoute.set(matchingRoute);
				hasActiveRoute = true;
			}
		} else {
			routes.update(rs => {
				rs.push(route);
				return rs;
			});
		}
	}

	function unregisterRoute(route) {
		routes.update(rs => {
			const index = rs.indexOf(route);
			rs.splice(index, 1);
			return rs;
		});
	}

	if (!locationContext) {
		// The topmost Router in the tree is responsible for updating
		// the location store and supplying it through context.
		onMount(() => {
			const unlisten = globalHistory.listen(history => {
				location.set(history.location);
			});

			return unlisten;
		});

		setContext(LOCATION, location);
	}

	setContext(ROUTER, {
		activeRoute,
		base,
		routerBase,
		registerRoute,
		unregisterRoute
	});

	const writable_props = ["basepath", "url"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Router", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		onMount,
		writable,
		derived,
		LOCATION,
		ROUTER,
		globalHistory,
		pick,
		match,
		stripSlashes,
		combinePaths,
		basepath,
		url,
		locationContext,
		routerContext,
		routes,
		activeRoute,
		hasActiveRoute,
		location,
		base,
		routerBase,
		registerRoute,
		unregisterRoute,
		$base,
		$location,
		$routes
	});

	$$self.$inject_state = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$base*/ 64) {
			// This reactive statement will update all the Routes' path when
			// the basepath changes.
			 {
				const { path: basepath } = $base;

				routes.update(rs => {
					rs.forEach(r => r.path = combinePaths(basepath, r._path));
					return rs;
				});
			}
		}

		if ($$self.$$.dirty & /*$routes, $location*/ 384) {
			// This reactive statement will be run when the Router is created
			// when there are no Routes and then again the following tick, so it
			// will not find an active Route in SSR and in the browser it will only
			// pick an active Route after all Routes have been registered.
			 {
				const bestMatch = pick($routes, $location.pathname);
				activeRoute.set(bestMatch);
			}
		}
	};

	return [
		routes,
		location,
		base,
		basepath,
		url,
		hasActiveRoute,
		$base,
		$location,
		$routes,
		locationContext,
		routerContext,
		activeRoute,
		routerBase,
		registerRoute,
		unregisterRoute,
		$$scope,
		$$slots
	];
}

class Router extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { basepath: 3, url: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Router",
			options,
			id: create_fragment$7.name
		});
	}

	get basepath() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set basepath(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.22.2 */

const get_default_slot_changes = dirty => ({
	params: dirty & /*routeParams*/ 2,
	location: dirty & /*$location*/ 16
});

const get_default_slot_context = ctx => ({
	params: /*routeParams*/ ctx[1],
	location: /*$location*/ ctx[4]
});

// (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*component*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
		ctx
	});

	return block;
}

// (43:2) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 4114) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(43:2) {:else}",
		ctx
	});

	return block;
}

// (41:2) {#if component !== null}
function create_if_block_1(ctx) {
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{ location: /*$location*/ ctx[4] },
		/*routeParams*/ ctx[1],
		/*routeProps*/ ctx[2]
	];

	var switch_value = /*component*/ ctx[0];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 22)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
					dirty & /*routeParams*/ 2 && get_spread_object(/*routeParams*/ ctx[1]),
					dirty & /*routeProps*/ 4 && get_spread_object(/*routeProps*/ ctx[2])
				])
			: {};

			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(41:2) {#if component !== null}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$activeRoute*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let $activeRoute;
	let $location;
	let { path = "" } = $$props;
	let { component = null } = $$props;
	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
	validate_store(activeRoute, "activeRoute");
	component_subscribe($$self, activeRoute, value => $$invalidate(3, $activeRoute = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

	const route = {
		path,
		// If no path prop is given, this Route will act as the default Route
		// that is rendered if no other Route in the Router is a match.
		default: path === ""
	};

	let routeParams = {};
	let routeProps = {};
	registerRoute(route);

	// There is no need to unregister Routes in SSR since it will all be
	// thrown away anyway.
	if (typeof window !== "undefined") {
		onDestroy(() => {
			unregisterRoute(route);
		});
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Route", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		onDestroy,
		ROUTER,
		LOCATION,
		path,
		component,
		registerRoute,
		unregisterRoute,
		activeRoute,
		location,
		route,
		routeParams,
		routeProps,
		$activeRoute,
		$location
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
		if ("routeParams" in $$props) $$invalidate(1, routeParams = $$new_props.routeParams);
		if ("routeProps" in $$props) $$invalidate(2, routeProps = $$new_props.routeProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$activeRoute*/ 8) {
			 if ($activeRoute && $activeRoute.route === route) {
				$$invalidate(1, routeParams = $activeRoute.params);
			}
		}

		 {
			const { path, component, ...rest } = $$props;
			$$invalidate(2, routeProps = rest);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		component,
		routeParams,
		routeProps,
		$activeRoute,
		$location,
		activeRoute,
		location,
		route,
		path,
		registerRoute,
		unregisterRoute,
		$$props,
		$$scope,
		$$slots
	];
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { path: 8, component: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Route",
			options,
			id: create_fragment$8.name
		});
	}

	get path() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.22.2 */
const file$7 = "Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte";

function create_fragment$9(ctx) {
	let a;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let a_levels = [
		{ href: /*href*/ ctx[0] },
		{ "aria-current": /*ariaCurrent*/ ctx[2] },
		/*props*/ ctx[1]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, "aria-current": true });
			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(a, a_data);
			add_location(a, file$7, 40, 0, 1249);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
			if (remount) dispose();
			dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}

			set_attributes(a, get_spread_update(a_levels, [
				dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
				dirty & /*ariaCurrent*/ 4 && { "aria-current": /*ariaCurrent*/ ctx[2] },
				dirty & /*props*/ 2 && /*props*/ ctx[1]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let { to = "#" } = $$props;
	let { replace = false } = $$props;
	let { state = {} } = $$props;
	let { getProps = () => ({}) } = $$props;
	const { base } = getContext(ROUTER);
	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(12, $base = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(13, $location = value));
	const dispatch = createEventDispatcher();
	let href, isPartiallyCurrent, isCurrent, props;

	function onClick(event) {
		dispatch("click", event);

		if (shouldNavigate(event)) {
			event.preventDefault();

			// Don't push another entry to the history stack when the user
			// clicks on a Link to the page they are currently on.
			const shouldReplace = $location.pathname === href || replace;

			navigate(href, { state, replace: shouldReplace });
		}
	}

	const writable_props = ["to", "replace", "state", "getProps"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Link", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		createEventDispatcher,
		ROUTER,
		LOCATION,
		navigate,
		startsWith,
		resolve,
		shouldNavigate,
		to,
		replace,
		state,
		getProps,
		base,
		location,
		dispatch,
		href,
		isPartiallyCurrent,
		isCurrent,
		props,
		onClick,
		$base,
		$location,
		ariaCurrent
	});

	$$self.$inject_state = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$props.isPartiallyCurrent);
		if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$props.isCurrent);
		if ("props" in $$props) $$invalidate(1, props = $$props.props);
		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$props.ariaCurrent);
	};

	let ariaCurrent;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*to, $base*/ 4160) {
			 $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
		}

		if ($$self.$$.dirty & /*$location, href*/ 8193) {
			 $$invalidate(10, isPartiallyCurrent = startsWith($location.pathname, href));
		}

		if ($$self.$$.dirty & /*href, $location*/ 8193) {
			 $$invalidate(11, isCurrent = href === $location.pathname);
		}

		if ($$self.$$.dirty & /*isCurrent*/ 2048) {
			 $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
		}

		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 11777) {
			 $$invalidate(1, props = getProps({
				location: $location,
				href,
				isPartiallyCurrent,
				isCurrent
			}));
		}
	};

	return [
		href,
		props,
		ariaCurrent,
		base,
		location,
		onClick,
		to,
		replace,
		state,
		getProps,
		isPartiallyCurrent,
		isCurrent,
		$base,
		$location,
		dispatch,
		$$scope,
		$$slots
	];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { to: 6, replace: 7, state: 8, getProps: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$9.name
		});
	}

	get to() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set to(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get replace() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set replace(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getProps() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getProps(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/profile.svelte generated by Svelte v3.22.2 */
const file$8 = "src/routes/profile.svelte";

function create_fragment$a(ctx) {
	let t0;
	let t1;
	let div5;
	let t2;
	let div3;
	let div0;
	let t3;
	let t4;
	let div1;
	let t5;
	let t6;
	let div2;
	let t7;
	let t8;
	let div4;
	let t9;
	let current;

	const navbar = new Navbar({
			props: { title: "Profile" },
			$$inline: true
		});

	const profileheader = new ProfileHeader({
			props: {
				name: /*username_value*/ ctx[0],
				alias: "bingotheslayer",
				profilepicture: "profilepicture.jpg",
				level: "40"
			},
			$$inline: true
		});

	const about = new About({ $$inline: true });
	const tabbar = new Tabbar({ props: { location: 2 }, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			create_component(navbar.$$.fragment);
			t1 = space();
			div5 = element("div");
			create_component(profileheader.$$.fragment);
			t2 = space();
			div3 = element("div");
			div0 = element("div");
			t3 = text("About");
			t4 = space();
			div1 = element("div");
			t5 = text("Activity");
			t6 = space();
			div2 = element("div");
			t7 = text("Inventory");
			t8 = space();
			div4 = element("div");
			create_component(about.$$.fragment);
			t9 = space();
			create_component(tabbar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-fcey8i\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(navbar.$$.fragment, nodes);
			t1 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			claim_component(profileheader.$$.fragment, div5_nodes);
			t2 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t3 = claim_text(div0_nodes, "About");
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t5 = claim_text(div1_nodes, "Activity");
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t7 = claim_text(div2_nodes, "Inventory");
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t8 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			claim_component(about.$$.fragment, div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			claim_component(tabbar.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Profile :: Steam Mobile";
			attr_dev(div0, "class", "selected svelte-1ttnfi1");
			add_location(div0, file$8, 27, 4, 711);
			attr_dev(div1, "class", "svelte-1ttnfi1");
			add_location(div1, file$8, 28, 4, 749);
			attr_dev(div2, "class", "svelte-1ttnfi1");
			add_location(div2, file$8, 29, 4, 773);
			attr_dev(div3, "id", "navtray");
			attr_dev(div3, "class", "svelte-1ttnfi1");
			add_location(div3, file$8, 26, 2, 688);
			attr_dev(div4, "id", "container");
			attr_dev(div4, "class", "svelte-1ttnfi1");
			add_location(div4, file$8, 31, 2, 805);
			attr_dev(div5, "id", "profile");
			attr_dev(div5, "class", "svelte-1ttnfi1");
			add_location(div5, file$8, 20, 0, 539);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(navbar, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div5, anchor);
			mount_component(profileheader, div5, null);
			append_dev(div5, t2);
			append_dev(div5, div3);
			append_dev(div3, div0);
			append_dev(div0, t3);
			append_dev(div3, t4);
			append_dev(div3, div1);
			append_dev(div1, t5);
			append_dev(div3, t6);
			append_dev(div3, div2);
			append_dev(div2, t7);
			append_dev(div5, t8);
			append_dev(div5, div4);
			mount_component(about, div4, null);
			insert_dev(target, t9, anchor);
			mount_component(tabbar, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const profileheader_changes = {};
			if (dirty & /*username_value*/ 1) profileheader_changes.name = /*username_value*/ ctx[0];
			profileheader.$set(profileheader_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(profileheader.$$.fragment, local);
			transition_in(about.$$.fragment, local);
			transition_in(tabbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(profileheader.$$.fragment, local);
			transition_out(about.$$.fragment, local);
			transition_out(tabbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div5);
			destroy_component(profileheader);
			destroy_component(about);
			if (detaching) detach_dev(t9);
			destroy_component(tabbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let username_value;

	const unsubscribe = username.subscribe(value => {
		$$invalidate(0, username_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Profile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Profile", $$slots, []);

	$$self.$capture_state = () => ({
		Navbar,
		Tabbar,
		ProfileHeader,
		About,
		username,
		Router,
		Link,
		Route,
		username_value,
		unsubscribe
	});

	$$self.$inject_state = $$props => {
		if ("username_value" in $$props) $$invalidate(0, username_value = $$props.username_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [username_value];
}

class Profile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Profile",
			options,
			id: create_fragment$a.name
		});
	}
}

export default Profile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS4zN2JkY2ZlZC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUHJvZmlsZUhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9CYWRnZVNob3djYXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0JhZGdlcy5zdmVsdGUiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXJvdXRpbmcvc3JjL2NvbnRleHRzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy9oaXN0b3J5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy91dGlscy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvUm91dGVyLnN2ZWx0ZSIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvUm91dGUuc3ZlbHRlIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy9MaW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcHJvZmlsZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBhbGlhcywgbmFtZSwgcHJvZmlsZXBpY3R1cmUsIGxldmVsXG48L3NjcmlwdD5cblxuPG1haW4+XG4gIDxkaXYgaWQ9XCJoZWFkXCI+XG4gICAgPGRpdiBpZD1cImxheWVyMVwiIC8+XG4gICAgPGRpdiBpZD1cImNvbnRlbnR3cmFwcGVyXCI+XG4gICAgICA8ZGl2IGlkPVwiY29udGVudFwiPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgaWQ9XCJwcm9maWxlcGljdHVyZVwiXG4gICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoe3Byb2ZpbGVwaWN0dXJlfSk7XCIgLz5cbiAgICAgICAgPGRpdiBpZD1cInVzZXJpbmZvXCI+XG4gICAgICAgICAgPGgzPnthbGlhc308L2gzPlxuICAgICAgICAgIDxoNT57bmFtZX08L2g1PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCEtLSBuZWVkIHRvIHJpZ2h0IGxvZ2ljIGZvciBoYW5kbGluZyBiYWRnZSBjb2xvciAtLT5cbiAgICAgICAgPGRpdiBpZD1cImxldmVsXCI+e2xldmVsfTwvZGl2PlxuICAgICAgICA8IS0tIG5lZWQgdG8gcmlnaHQgbG9naWMgZm9yIGhhbmRsaW5nIGJhZGdlIGNvbG9yIC0tPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImxheWVyMlwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKGd0YS5qcGcpO1wiIC8+XG4gICAgPGRpdiBpZD1cImxheWVyM1wiIC8+XG4gIDwvZGl2PlxuPC9tYWluPlxuXG48c3R5bGU+XG4gICNoZWFkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cblxuICAjdXNlcmluZm8ge1xuICAgIG1hcmdpbi1sZWZ0OiAxOHB4O1xuICB9XG5cbiAgI2xldmVsIHtcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjNDY3YTNjO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuICAgIHdpZHRoOiAzNXB4O1xuICAgIGhlaWdodDogMzVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICBoMyB7XG4gICAgZm9udC1zaXplOiAyMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICBoNSB7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgY29sb3I6ICM2OTY5Njk7XG4gIH1cblxuICAjcHJvZmlsZXBpY3R1cmUge1xuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDc1cHg7XG4gICAgd2lkdGg6IDc1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG5cbiAgI2xheWVyMSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGhlaWdodDogNTBweDtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCByZ2IoMCwgMCwgMCksIHJnYmEoMCwgMCwgMCwgMCkpO1xuICAgIGJvdHRvbTogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB6LWluZGV4OiA5NzU7XG4gIH1cblxuICAjY29udGVudHdyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiA5OTtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gICNjb250ZW50IHtcbiAgICBwYWRkaW5nOiAzMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gICNsYXllcjIge1xuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxNDBweDtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIHotaW5kZXg6IDM7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG9wYWNpdHk6IDAuMTtcbiAgfVxuXG4gICNsYXllcjMge1xuICAgIGJhY2tncm91bmQ6ICMwZjBiMjA7XG4gICAgaGVpZ2h0OiAxNDBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIHotaW5kZXg6IDI7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGltYWdlcztcbjwvc2NyaXB0PlxuPGRpdiBpZD1cImJhZGdlc2hvd2Nhc2VcIj5cbiAgPGltZyBzcmM9XCJ7aW1hZ2VzWzBdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDMycHg7XCIgLz5cbiAgPGltZyBzcmM9XCJ7aW1hZ2VzWzFdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDMycHg7XCIgLz5cbiAgPGltZyBzcmM9XCJ7aW1hZ2VzWzJdLmxpbmt9XCIgLz5cbiAgPGltZyBzcmM9XCJ7aW1hZ2VzWzNdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDM2cHg7XCIgLz5cbiAgPGltZyBzcmM9XCJ7aW1hZ2VzWzRdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDM4cHg7XCIgLz5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICNiYWRnZXNob3djYXNlIGltZ3tcbiAgICBoZWlnaHQ6IDQwcHg7XG4gIH1cblxuICAjYmFkZ2VzaG93Y2FzZXtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG48L3N0eWxlPlxuXG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgTWFpbkJhZGdlIGZyb20gJy4vTWFpbkJhZGdlLnN2ZWx0ZSdcbiAgaW1wb3J0IEJhZGdlU2hvd2Nhc2UgZnJvbSAnLi9CYWRnZVNob3djYXNlLnN2ZWx0ZSdcbjwvc2NyaXB0PlxuXG48ZGl2IGlkPVwiYmFkZ2VzXCI+XG4gIDxkaXYgaWQ9XCJ0aXRsZVwiPlxuICAgIDxoMz5CYWRnZXM8L2gzPlxuICAgIDxoMj44PC9oMj5cbiAgPC9kaXY+XG4gIDxNYWluQmFkZ2UgLz5cbiAgPEJhZGdlU2hvd2Nhc2UgaW1hZ2VzPXtbe2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNvbW11bml0eS1hLmFrYW1haWhkLm5ldC9wdWJsaWMvaW1hZ2VzL2JhZGdlcy8zN19zdW1tZXIyMDE5L2xldmVsMjVfODAucG5nXCJ9LCB7bGluazogXCJodHRwczovL3N0ZWFtY2RuLWEuYWthbWFpaGQubmV0L3N0ZWFtY29tbXVuaXR5L3B1YmxpYy9pbWFnZXMvaXRlbXMvNzMwLzU0ZTQwYjllMjI4OGZiYWI4YmQ0YzY1MzdiMDMyNWQ0MDVjN2UxYjAucG5nXCJ9LCB7bGluazogXCJodHRwczovL3N0ZWFtY29tbXVuaXR5LWEuYWthbWFpaGQubmV0L3B1YmxpYy9pbWFnZXMvYmFkZ2VzLzI4X3NwcmluZ2NsZWFuaW5nMjAxOC9icm9uemVfODAucG5nXCJ9LCB7bGluazogXCJodHRwczovL3N0ZWFtY2RuLWEuYWthbWFpaGQubmV0L3N0ZWFtY29tbXVuaXR5L3B1YmxpYy9pbWFnZXMvaXRlbXMvNzYyODAwL2Q0NjdlYzhlYWVkNDY0M2M0N2ZiZWQ0M2VkNzgxZGFlZjI1MjU5NjMucG5nXCJ9LCB7bGluayA6IFwiaHR0cHM6Ly9zdGVhbWNvbW11bml0eS1hLmFrYW1haWhkLm5ldC9wdWJsaWMvaW1hZ2VzL2JhZGdlcy8yN19zdGVhbWF3YXJkbm9taW5hdGlvbnMvbGV2ZWwwNF84MC5wbmdcIn1dfSAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgI2JhZGdlcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzBmMGIyMDtcbiAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICBsaW5lLWhlaWdodDogMThweDtcbiAgICBmb250LXdlaWdodDogMzAwO1xuICAgIGdyaWQtY29sdW1uOiAxLzI7XG4gICAgZ3JpZC1yb3c6IDIvNDtcbiAgfVxuXG4gICN0aXRsZSB7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gIH1cbjwvc3R5bGU+XG4iLCJleHBvcnQgY29uc3QgTE9DQVRJT04gPSB7fTtcbmV4cG9ydCBjb25zdCBST1VURVIgPSB7fTtcbiIsIi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yb3V0ZXIvYmxvYi9iNjBlNmRkNzgxZDVkM2E0YmRhYWY0ZGU2NjU2NDljMGY2YTdlNzhkL3NyYy9saWIvaGlzdG9yeS5qc1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yb3V0ZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogKi9cblxuZnVuY3Rpb24gZ2V0TG9jYXRpb24oc291cmNlKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc291cmNlLmxvY2F0aW9uLFxuICAgIHN0YXRlOiBzb3VyY2UuaGlzdG9yeS5zdGF0ZSxcbiAgICBrZXk6IChzb3VyY2UuaGlzdG9yeS5zdGF0ZSAmJiBzb3VyY2UuaGlzdG9yeS5zdGF0ZS5rZXkpIHx8IFwiaW5pdGlhbFwiXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhpc3Rvcnkoc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICBsZXQgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihzb3VyY2UpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgICAgY29uc3QgcG9wc3RhdGVMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihzb3VyY2UpO1xuICAgICAgICBsaXN0ZW5lcih7IGxvY2F0aW9uLCBhY3Rpb246IFwiUE9QXCIgfSk7XG4gICAgICB9O1xuXG4gICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHBvcHN0YXRlTGlzdGVuZXIpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHBvcHN0YXRlTGlzdGVuZXIpO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIG5hdmlnYXRlKHRvLCB7IHN0YXRlLCByZXBsYWNlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICBzdGF0ZSA9IHsgLi4uc3RhdGUsIGtleTogRGF0ZS5ub3coKSArIFwiXCIgfTtcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGlPUyBTYWZhcmkgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgc291cmNlLmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBudWxsLCB0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc291cmNlLmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCBudWxsLCB0byk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc291cmNlLmxvY2F0aW9uW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwiYXNzaWduXCJdKHRvKTtcbiAgICAgIH1cblxuICAgICAgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihzb3VyY2UpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoeyBsb2NhdGlvbiwgYWN0aW9uOiBcIlBVU0hcIiB9KSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBTdG9yZXMgaGlzdG9yeSBlbnRyaWVzIGluIG1lbW9yeSBmb3IgdGVzdGluZyBvciBvdGhlciBwbGF0Zm9ybXMgbGlrZSBOYXRpdmVcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVNvdXJjZShpbml0aWFsUGF0aG5hbWUgPSBcIi9cIikge1xuICBsZXQgaW5kZXggPSAwO1xuICBjb25zdCBzdGFjayA9IFt7IHBhdGhuYW1lOiBpbml0aWFsUGF0aG5hbWUsIHNlYXJjaDogXCJcIiB9XTtcbiAgY29uc3Qgc3RhdGVzID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gc3RhY2tbaW5kZXhdO1xuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmbikge30sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmbikge30sXG4gICAgaGlzdG9yeToge1xuICAgICAgZ2V0IGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH0sXG4gICAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH0sXG4gICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZXNbaW5kZXhdO1xuICAgICAgfSxcbiAgICAgIHB1c2hTdGF0ZShzdGF0ZSwgXywgdXJpKSB7XG4gICAgICAgIGNvbnN0IFtwYXRobmFtZSwgc2VhcmNoID0gXCJcIl0gPSB1cmkuc3BsaXQoXCI/XCIpO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBzdGFjay5wdXNoKHsgcGF0aG5hbWUsIHNlYXJjaCB9KTtcbiAgICAgICAgc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2VTdGF0ZShzdGF0ZSwgXywgdXJpKSB7XG4gICAgICAgIGNvbnN0IFtwYXRobmFtZSwgc2VhcmNoID0gXCJcIl0gPSB1cmkuc3BsaXQoXCI/XCIpO1xuICAgICAgICBzdGFja1tpbmRleF0gPSB7IHBhdGhuYW1lLCBzZWFyY2ggfTtcbiAgICAgICAgc3RhdGVzW2luZGV4XSA9IHN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gR2xvYmFsIGhpc3RvcnkgdXNlcyB3aW5kb3cuaGlzdG9yeSBhcyB0aGUgc291cmNlIGlmIGF2YWlsYWJsZSxcbi8vIG90aGVyd2lzZSBhIG1lbW9yeSBoaXN0b3J5XG5jb25zdCBjYW5Vc2VET00gPSBCb29sZWFuKFxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgd2luZG93LmRvY3VtZW50ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbik7XG5jb25zdCBnbG9iYWxIaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShjYW5Vc2VET00gPyB3aW5kb3cgOiBjcmVhdGVNZW1vcnlTb3VyY2UoKSk7XG5jb25zdCB7IG5hdmlnYXRlIH0gPSBnbG9iYWxIaXN0b3J5O1xuXG5leHBvcnQgeyBnbG9iYWxIaXN0b3J5LCBuYXZpZ2F0ZSwgY3JlYXRlSGlzdG9yeSwgY3JlYXRlTWVtb3J5U291cmNlIH07XG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcm91dGVyL2Jsb2IvYjYwZTZkZDc4MWQ1ZDNhNGJkYWFmNGRlNjY1NjQ5YzBmNmE3ZTc4ZC9zcmMvbGliL3V0aWxzLmpzXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JvdXRlci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiAqL1xuXG5jb25zdCBwYXJhbVJlID0gL146KC4rKS87XG5cbmNvbnN0IFNFR01FTlRfUE9JTlRTID0gNDtcbmNvbnN0IFNUQVRJQ19QT0lOVFMgPSAzO1xuY29uc3QgRFlOQU1JQ19QT0lOVFMgPSAyO1xuY29uc3QgU1BMQVRfUEVOQUxUWSA9IDE7XG5jb25zdCBST09UX1BPSU5UUyA9IDE7XG5cbi8qKlxuICogQ2hlY2sgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHNlYXJjaGBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgc2VhcmNoKSB7XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYHNlZ21lbnRgIGlzIGEgcm9vdCBzZWdtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VnbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSb290U2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50ID09PSBcIlwiO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBzZWdtZW50YCBpcyBhIGR5bmFtaWMgc2VnbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlZ21lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRHluYW1pYyhzZWdtZW50KSB7XG4gIHJldHVybiBwYXJhbVJlLnRlc3Qoc2VnbWVudCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYHNlZ21lbnRgIGlzIGEgc3BsYXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWdtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NwbGF0KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnRbMF0gPT09IFwiKlwiO1xufVxuXG4vKipcbiAqIFNwbGl0IHVwIHRoZSBVUkkgaW50byBzZWdtZW50cyBkZWxpbWl0ZWQgYnkgYC9gXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqL1xuZnVuY3Rpb24gc2VnbWVudGl6ZSh1cmkpIHtcbiAgcmV0dXJuIChcbiAgICB1cmlcbiAgICAgIC8vIFN0cmlwIHN0YXJ0aW5nL2VuZGluZyBgL2BcbiAgICAgIC5yZXBsYWNlKC8oXlxcLyt8XFwvKyQpL2csIFwiXCIpXG4gICAgICAuc3BsaXQoXCIvXCIpXG4gICk7XG59XG5cbi8qKlxuICogU3RyaXAgYHN0cmAgb2YgcG90ZW50aWFsIHN0YXJ0IGFuZCBlbmQgYC9gXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwU2xhc2hlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXlxcLyt8XFwvKyQpL2csIFwiXCIpO1xufVxuXG4vKipcbiAqIFNjb3JlIGEgcm91dGUgZGVwZW5kaW5nIG9uIGhvdyBpdHMgaW5kaXZpZHVhbCBzZWdtZW50cyBsb29rXG4gKiBAcGFyYW0ge29iamVjdH0gcm91dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiByYW5rUm91dGUocm91dGUsIGluZGV4KSB7XG4gIGNvbnN0IHNjb3JlID0gcm91dGUuZGVmYXVsdFxuICAgID8gMFxuICAgIDogc2VnbWVudGl6ZShyb3V0ZS5wYXRoKS5yZWR1Y2UoKHNjb3JlLCBzZWdtZW50KSA9PiB7XG4gICAgICAgIHNjb3JlICs9IFNFR01FTlRfUE9JTlRTO1xuXG4gICAgICAgIGlmIChpc1Jvb3RTZWdtZW50KHNlZ21lbnQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gUk9PVF9QT0lOVFM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEeW5hbWljKHNlZ21lbnQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gRFlOQU1JQ19QT0lOVFM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTcGxhdChzZWdtZW50KSkge1xuICAgICAgICAgIHNjb3JlIC09IFNFR01FTlRfUE9JTlRTICsgU1BMQVRfUEVOQUxUWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29yZSArPSBTVEFUSUNfUE9JTlRTO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3JlO1xuICAgICAgfSwgMCk7XG5cbiAgcmV0dXJuIHsgcm91dGUsIHNjb3JlLCBpbmRleCB9O1xufVxuXG4vKipcbiAqIEdpdmUgYSBzY29yZSB0byBhbGwgcm91dGVzIGFuZCBzb3J0IHRoZW0gb24gdGhhdFxuICogQHBhcmFtIHtvYmplY3RbXX0gcm91dGVzXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcmFua1JvdXRlcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIChcbiAgICByb3V0ZXNcbiAgICAgIC5tYXAocmFua1JvdXRlKVxuICAgICAgLy8gSWYgdHdvIHJvdXRlcyBoYXZlIHRoZSBleGFjdCBzYW1lIHNjb3JlLCB3ZSBnbyBieSBpbmRleCBpbnN0ZWFkXG4gICAgICAuc29ydCgoYSwgYikgPT5cbiAgICAgICAgYS5zY29yZSA8IGIuc2NvcmUgPyAxIDogYS5zY29yZSA+IGIuc2NvcmUgPyAtMSA6IGEuaW5kZXggLSBiLmluZGV4XG4gICAgICApXG4gICk7XG59XG5cbi8qKlxuICogUmFua3MgYW5kIHBpY2tzIHRoZSBiZXN0IHJvdXRlIHRvIG1hdGNoLiBFYWNoIHNlZ21lbnQgZ2V0cyB0aGUgaGlnaGVzdFxuICogYW1vdW50IG9mIHBvaW50cywgdGhlbiB0aGUgdHlwZSBvZiBzZWdtZW50IGdldHMgYW4gYWRkaXRpb25hbCBhbW91bnQgb2ZcbiAqIHBvaW50cyB3aGVyZVxuICpcbiAqICBzdGF0aWMgPiBkeW5hbWljID4gc3BsYXQgPiByb290XG4gKlxuICogVGhpcyB3YXkgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgb3JkZXIgb2Ygb3VyIHJvdXRlcywgbGV0IHRoZVxuICogY29tcHV0ZXJzIGRvIGl0LlxuICpcbiAqIEEgcm91dGUgbG9va3MgbGlrZSB0aGlzXG4gKlxuICogIHsgcGF0aCwgZGVmYXVsdCwgdmFsdWUgfVxuICpcbiAqIEFuZCBhIHJldHVybmVkIG1hdGNoIGxvb2tzIGxpa2U6XG4gKlxuICogIHsgcm91dGUsIHBhcmFtcywgdXJpIH1cbiAqXG4gKiBAcGFyYW0ge29iamVjdFtdfSByb3V0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBpY2socm91dGVzLCB1cmkpIHtcbiAgbGV0IG1hdGNoO1xuICBsZXQgZGVmYXVsdF87XG5cbiAgY29uc3QgW3VyaVBhdGhuYW1lXSA9IHVyaS5zcGxpdChcIj9cIik7XG4gIGNvbnN0IHVyaVNlZ21lbnRzID0gc2VnbWVudGl6ZSh1cmlQYXRobmFtZSk7XG4gIGNvbnN0IGlzUm9vdFVyaSA9IHVyaVNlZ21lbnRzWzBdID09PSBcIlwiO1xuICBjb25zdCByYW5rZWQgPSByYW5rUm91dGVzKHJvdXRlcyk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSByYW5rZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3Qgcm91dGUgPSByYW5rZWRbaV0ucm91dGU7XG4gICAgbGV0IG1pc3NlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJvdXRlLmRlZmF1bHQpIHtcbiAgICAgIGRlZmF1bHRfID0ge1xuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgdXJpXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVTZWdtZW50cyA9IHNlZ21lbnRpemUocm91dGUucGF0aCk7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgodXJpU2VnbWVudHMubGVuZ3RoLCByb3V0ZVNlZ21lbnRzLmxlbmd0aCk7XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgcm91dGVTZWdtZW50ID0gcm91dGVTZWdtZW50c1tpbmRleF07XG4gICAgICBjb25zdCB1cmlTZWdtZW50ID0gdXJpU2VnbWVudHNbaW5kZXhdO1xuXG4gICAgICBpZiAocm91dGVTZWdtZW50ICE9PSB1bmRlZmluZWQgJiYgaXNTcGxhdChyb3V0ZVNlZ21lbnQpKSB7XG4gICAgICAgIC8vIEhpdCBhIHNwbGF0LCBqdXN0IGdyYWIgdGhlIHJlc3QsIGFuZCByZXR1cm4gYSBtYXRjaFxuICAgICAgICAvLyB1cmk6ICAgL2ZpbGVzL2RvY3VtZW50cy93b3JrXG4gICAgICAgIC8vIHJvdXRlOiAvZmlsZXMvKiBvciAvZmlsZXMvKnNwbGF0bmFtZVxuICAgICAgICBjb25zdCBzcGxhdE5hbWUgPSByb3V0ZVNlZ21lbnQgPT09IFwiKlwiID8gXCIqXCIgOiByb3V0ZVNlZ21lbnQuc2xpY2UoMSk7XG5cbiAgICAgICAgcGFyYW1zW3NwbGF0TmFtZV0gPSB1cmlTZWdtZW50c1xuICAgICAgICAgIC5zbGljZShpbmRleClcbiAgICAgICAgICAubWFwKGRlY29kZVVSSUNvbXBvbmVudClcbiAgICAgICAgICAuam9pbihcIi9cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJpU2VnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFVSSSBpcyBzaG9ydGVyIHRoYW4gdGhlIHJvdXRlLCBubyBtYXRjaFxuICAgICAgICAvLyB1cmk6ICAgL3VzZXJzXG4gICAgICAgIC8vIHJvdXRlOiAvdXNlcnMvOnVzZXJJZFxuICAgICAgICBtaXNzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IGR5bmFtaWNNYXRjaCA9IHBhcmFtUmUuZXhlYyhyb3V0ZVNlZ21lbnQpO1xuXG4gICAgICBpZiAoZHluYW1pY01hdGNoICYmICFpc1Jvb3RVcmkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodXJpU2VnbWVudCk7XG4gICAgICAgIHBhcmFtc1tkeW5hbWljTWF0Y2hbMV1dID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHJvdXRlU2VnbWVudCAhPT0gdXJpU2VnbWVudCkge1xuICAgICAgICAvLyBDdXJyZW50IHNlZ21lbnRzIGRvbid0IG1hdGNoLCBub3QgZHluYW1pYywgbm90IHNwbGF0LCBzbyBubyBtYXRjaFxuICAgICAgICAvLyB1cmk6ICAgL3VzZXJzLzEyMy9zZXR0aW5nc1xuICAgICAgICAvLyByb3V0ZTogL3VzZXJzLzppZC9wcm9maWxlXG4gICAgICAgIG1pc3NlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWlzc2VkKSB7XG4gICAgICBtYXRjaCA9IHtcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdXJpOiBcIi9cIiArIHVyaVNlZ21lbnRzLnNsaWNlKDAsIGluZGV4KS5qb2luKFwiL1wiKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaCB8fCBkZWZhdWx0XyB8fCBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBgcGF0aGAgbWF0Y2hlcyB0aGUgYHVyaWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWF0Y2gocm91dGUsIHVyaSkge1xuICByZXR1cm4gcGljayhbcm91dGVdLCB1cmkpO1xufVxuXG4vKipcbiAqIEFkZCB0aGUgcXVlcnkgdG8gdGhlIHBhdGhuYW1lIGlmIGEgcXVlcnkgaXMgZ2l2ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFtxdWVyeV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYWRkUXVlcnkocGF0aG5hbWUsIHF1ZXJ5KSB7XG4gIHJldHVybiBwYXRobmFtZSArIChxdWVyeSA/IGA/JHtxdWVyeX1gIDogXCJcIik7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBVUklzIGFzIHRob3VnaCBldmVyeSBwYXRoIGlzIGEgZGlyZWN0b3J5LCBubyBmaWxlcy4gUmVsYXRpdmUgVVJJc1xuICogaW4gdGhlIGJyb3dzZXIgY2FuIGZlZWwgYXdrd2FyZCBiZWNhdXNlIG5vdCBvbmx5IGNhbiB5b3UgYmUgXCJpbiBhIGRpcmVjdG9yeVwiLFxuICogeW91IGNhbiBiZSBcImF0IGEgZmlsZVwiLCB0b28uIEZvciBleGFtcGxlOlxuICpcbiAqICBicm93c2VyU3BlY1Jlc29sdmUoJ2ZvbycsICcvYmFyLycpID0+IC9iYXIvZm9vXG4gKiAgYnJvd3NlclNwZWNSZXNvbHZlKCdmb28nLCAnL2JhcicpID0+IC9mb29cbiAqXG4gKiBCdXQgb24gdGhlIGNvbW1hbmQgbGluZSBvZiBhIGZpbGUgc3lzdGVtLCBpdCdzIG5vdCBhcyBjb21wbGljYXRlZC4gWW91IGNhbid0XG4gKiBgY2RgIGZyb20gYSBmaWxlLCBvbmx5IGRpcmVjdG9yaWVzLiBUaGlzIHdheSwgbGlua3MgaGF2ZSB0byBrbm93IGxlc3MgYWJvdXRcbiAqIHRoZWlyIGN1cnJlbnQgcGF0aC4gVG8gZ28gZGVlcGVyIHlvdSBjYW4gZG8gdGhpczpcbiAqXG4gKiAgPExpbmsgdG89XCJkZWVwZXJcIi8+XG4gKiAgLy8gaW5zdGVhZCBvZlxuICogIDxMaW5rIHRvPWB7JHtwcm9wcy51cml9L2RlZXBlcn1gLz5cbiAqXG4gKiBKdXN0IGxpa2UgYGNkYCwgaWYgeW91IHdhbnQgdG8gZ28gZGVlcGVyIGZyb20gdGhlIGNvbW1hbmQgbGluZSwgeW91IGRvIHRoaXM6XG4gKlxuICogIGNkIGRlZXBlclxuICogICMgbm90XG4gKiAgY2QgJChwd2QpL2RlZXBlclxuICpcbiAqIEJ5IHRyZWF0aW5nIGV2ZXJ5IHBhdGggYXMgYSBkaXJlY3RvcnksIGxpbmtpbmcgdG8gcmVsYXRpdmUgcGF0aHMgc2hvdWxkXG4gKiByZXF1aXJlIGxlc3MgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhbmQgKGZpbmdlcnMgY3Jvc3NlZCkgYmUgbW9yZSBpbnR1aXRpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUodG8sIGJhc2UpIHtcbiAgLy8gL2Zvby9iYXIsIC9iYXovcXV4ID0+IC9mb28vYmFyXG4gIGlmIChzdGFydHNXaXRoKHRvLCBcIi9cIikpIHtcbiAgICByZXR1cm4gdG87XG4gIH1cblxuICBjb25zdCBbdG9QYXRobmFtZSwgdG9RdWVyeV0gPSB0by5zcGxpdChcIj9cIik7XG4gIGNvbnN0IFtiYXNlUGF0aG5hbWVdID0gYmFzZS5zcGxpdChcIj9cIik7XG4gIGNvbnN0IHRvU2VnbWVudHMgPSBzZWdtZW50aXplKHRvUGF0aG5hbWUpO1xuICBjb25zdCBiYXNlU2VnbWVudHMgPSBzZWdtZW50aXplKGJhc2VQYXRobmFtZSk7XG5cbiAgLy8gP2E9YiwgL3VzZXJzP2I9YyA9PiAvdXNlcnM/YT1iXG4gIGlmICh0b1NlZ21lbnRzWzBdID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGFkZFF1ZXJ5KGJhc2VQYXRobmFtZSwgdG9RdWVyeSk7XG4gIH1cblxuICAvLyBwcm9maWxlLCAvdXNlcnMvNzg5ID0+IC91c2Vycy83ODkvcHJvZmlsZVxuICBpZiAoIXN0YXJ0c1dpdGgodG9TZWdtZW50c1swXSwgXCIuXCIpKSB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBiYXNlU2VnbWVudHMuY29uY2F0KHRvU2VnbWVudHMpLmpvaW4oXCIvXCIpO1xuXG4gICAgcmV0dXJuIGFkZFF1ZXJ5KChiYXNlUGF0aG5hbWUgPT09IFwiL1wiID8gXCJcIiA6IFwiL1wiKSArIHBhdGhuYW1lLCB0b1F1ZXJ5KTtcbiAgfVxuXG4gIC8vIC4vICAgICAgICwgL3VzZXJzLzEyMyA9PiAvdXNlcnMvMTIzXG4gIC8vIC4uLyAgICAgICwgL3VzZXJzLzEyMyA9PiAvdXNlcnNcbiAgLy8gLi4vLi4gICAgLCAvdXNlcnMvMTIzID0+IC9cbiAgLy8gLi4vLi4vb25lLCAvYS9iL2MvZCAgID0+IC9hL2Ivb25lXG4gIC8vIC4uLy4vb25lICwgL2EvYi9jL2QgICA9PiAvYS9iL2Mvb25lXG4gIGNvbnN0IGFsbFNlZ21lbnRzID0gYmFzZVNlZ21lbnRzLmNvbmNhdCh0b1NlZ21lbnRzKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBbXTtcblxuICBhbGxTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWRkUXVlcnkoXCIvXCIgKyBzZWdtZW50cy5qb2luKFwiL1wiKSwgdG9RdWVyeSk7XG59XG5cbi8qKlxuICogQ29tYmluZXMgdGhlIGBiYXNlcGF0aGAgYW5kIHRoZSBgcGF0aGAgaW50byBvbmUgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gY29tYmluZVBhdGhzKGJhc2VwYXRoLCBwYXRoKSB7XG4gIHJldHVybiBgJHtzdHJpcFNsYXNoZXMoXG4gICAgcGF0aCA9PT0gXCIvXCIgPyBiYXNlcGF0aCA6IGAke3N0cmlwU2xhc2hlcyhiYXNlcGF0aCl9LyR7c3RyaXBTbGFzaGVzKHBhdGgpfWBcbiAgKX0vYDtcbn1cblxuLyoqXG4gKiBEZWNpZGVzIHdoZXRoZXIgYSBnaXZlbiBgZXZlbnRgIHNob3VsZCByZXN1bHQgaW4gYSBuYXZpZ2F0aW9uIG9yIG5vdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGROYXZpZ2F0ZShldmVudCkge1xuICByZXR1cm4gKFxuICAgICFldmVudC5kZWZhdWx0UHJldmVudGVkICYmXG4gICAgZXZlbnQuYnV0dG9uID09PSAwICYmXG4gICAgIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KVxuICApO1xufVxuXG5mdW5jdGlvbiBob3N0TWF0Y2hlcyhhbmNob3IpIHtcbiAgY29uc3QgaG9zdCA9IGxvY2F0aW9uLmhvc3RcbiAgcmV0dXJuIChcbiAgICBhbmNob3IuaG9zdCA9PSBob3N0IHx8XG4gICAgLy8gc3ZlbHRlIHNlZW1zIHRvIGtpbGwgYW5jaG9yLmhvc3QgdmFsdWUgaW4gaWUxMSwgc28gZmFsbCBiYWNrIHRvIGNoZWNraW5nIGhyZWZcbiAgICBhbmNob3IuaHJlZi5pbmRleE9mKGBodHRwczovLyR7aG9zdH1gKSA9PT0gMCB8fFxuICAgIGFuY2hvci5ocmVmLmluZGV4T2YoYGh0dHA6Ly8ke2hvc3R9YCkgPT09IDBcbiAgKVxufVxuXG5leHBvcnQgeyBzdHJpcFNsYXNoZXMsIHBpY2ssIG1hdGNoLCByZXNvbHZlLCBjb21iaW5lUGF0aHMsIHNob3VsZE5hdmlnYXRlLCBob3N0TWF0Y2hlcyB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgc2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgd3JpdGFibGUsIGRlcml2ZWQgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG4gIGltcG9ydCB7IExPQ0FUSU9OLCBST1VURVIgfSBmcm9tIFwiLi9jb250ZXh0cy5qc1wiO1xuICBpbXBvcnQgeyBnbG9iYWxIaXN0b3J5IH0gZnJvbSBcIi4vaGlzdG9yeS5qc1wiO1xuICBpbXBvcnQgeyBwaWNrLCBtYXRjaCwgc3RyaXBTbGFzaGVzLCBjb21iaW5lUGF0aHMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuXG4gIGV4cG9ydCBsZXQgYmFzZXBhdGggPSBcIi9cIjtcbiAgZXhwb3J0IGxldCB1cmwgPSBudWxsO1xuXG4gIGNvbnN0IGxvY2F0aW9uQ29udGV4dCA9IGdldENvbnRleHQoTE9DQVRJT04pO1xuICBjb25zdCByb3V0ZXJDb250ZXh0ID0gZ2V0Q29udGV4dChST1VURVIpO1xuXG4gIGNvbnN0IHJvdXRlcyA9IHdyaXRhYmxlKFtdKTtcbiAgY29uc3QgYWN0aXZlUm91dGUgPSB3cml0YWJsZShudWxsKTtcbiAgbGV0IGhhc0FjdGl2ZVJvdXRlID0gZmFsc2U7IC8vIFVzZWQgaW4gU1NSIHRvIHN5bmNocm9ub3VzbHkgc2V0IHRoYXQgYSBSb3V0ZSBpcyBhY3RpdmUuXG5cbiAgLy8gSWYgbG9jYXRpb25Db250ZXh0IGlzIG5vdCBzZXQsIHRoaXMgaXMgdGhlIHRvcG1vc3QgUm91dGVyIGluIHRoZSB0cmVlLlxuICAvLyBJZiB0aGUgYHVybGAgcHJvcCBpcyBnaXZlbiB3ZSBmb3JjZSB0aGUgbG9jYXRpb24gdG8gaXQuXG4gIGNvbnN0IGxvY2F0aW9uID1cbiAgICBsb2NhdGlvbkNvbnRleHQgfHxcbiAgICB3cml0YWJsZSh1cmwgPyB7IHBhdGhuYW1lOiB1cmwgfSA6IGdsb2JhbEhpc3RvcnkubG9jYXRpb24pO1xuXG4gIC8vIElmIHJvdXRlckNvbnRleHQgaXMgc2V0LCB0aGUgcm91dGVyQmFzZSBvZiB0aGUgcGFyZW50IFJvdXRlclxuICAvLyB3aWxsIGJlIHRoZSBiYXNlIGZvciB0aGlzIFJvdXRlcidzIGRlc2NlbmRhbnRzLlxuICAvLyBJZiByb3V0ZXJDb250ZXh0IGlzIG5vdCBzZXQsIHRoZSBwYXRoIGFuZCByZXNvbHZlZCB1cmkgd2lsbCBib3RoXG4gIC8vIGhhdmUgdGhlIHZhbHVlIG9mIHRoZSBiYXNlcGF0aCBwcm9wLlxuICBjb25zdCBiYXNlID0gcm91dGVyQ29udGV4dFxuICAgID8gcm91dGVyQ29udGV4dC5yb3V0ZXJCYXNlXG4gICAgOiB3cml0YWJsZSh7XG4gICAgICAgIHBhdGg6IGJhc2VwYXRoLFxuICAgICAgICB1cmk6IGJhc2VwYXRoXG4gICAgICB9KTtcblxuICBjb25zdCByb3V0ZXJCYXNlID0gZGVyaXZlZChbYmFzZSwgYWN0aXZlUm91dGVdLCAoW2Jhc2UsIGFjdGl2ZVJvdXRlXSkgPT4ge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFjdGl2ZVJvdXRlLCB0aGUgcm91dGVyQmFzZSB3aWxsIGJlIGlkZW50aWNhbCB0byB0aGUgYmFzZS5cbiAgICBpZiAoYWN0aXZlUm91dGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcGF0aDogYmFzZXBhdGggfSA9IGJhc2U7XG4gICAgY29uc3QgeyByb3V0ZSwgdXJpIH0gPSBhY3RpdmVSb3V0ZTtcbiAgICAvLyBSZW1vdmUgdGhlIHBvdGVudGlhbCAvKiBvciAvKnNwbGF0bmFtZSBmcm9tXG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgY2hpbGQgUm91dGVzIHJlbGF0aXZlIHBhdGhzLlxuICAgIGNvbnN0IHBhdGggPSByb3V0ZS5kZWZhdWx0ID8gYmFzZXBhdGggOiByb3V0ZS5wYXRoLnJlcGxhY2UoL1xcKi4qJC8sIFwiXCIpO1xuXG4gICAgcmV0dXJuIHsgcGF0aCwgdXJpIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICBjb25zdCB7IHBhdGg6IGJhc2VwYXRoIH0gPSAkYmFzZTtcbiAgICBsZXQgeyBwYXRoIH0gPSByb3V0ZTtcblxuICAgIC8vIFdlIHN0b3JlIHRoZSBvcmlnaW5hbCBwYXRoIGluIHRoZSBfcGF0aCBwcm9wZXJ0eSBzbyB3ZSBjYW4gcmV1c2VcbiAgICAvLyBpdCB3aGVuIHRoZSBiYXNlcGF0aCBjaGFuZ2VzLiBUaGUgb25seSB0aGluZyB0aGF0IG1hdHRlcnMgaXMgdGhhdFxuICAgIC8vIHRoZSByb3V0ZSByZWZlcmVuY2UgaXMgaW50YWN0LCBzbyBtdXRhdGlvbiBpcyBmaW5lLlxuICAgIHJvdXRlLl9wYXRoID0gcGF0aDtcbiAgICByb3V0ZS5wYXRoID0gY29tYmluZVBhdGhzKGJhc2VwYXRoLCBwYXRoKTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAvLyBJbiBTU1Igd2Ugc2hvdWxkIHNldCB0aGUgYWN0aXZlUm91dGUgaW1tZWRpYXRlbHkgaWYgaXQgaXMgYSBtYXRjaC5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFJvdXRlcyBiZWluZyByZWdpc3RlcmVkIGFmdGVyIGEgbWF0Y2ggaXMgZm91bmQsXG4gICAgICAvLyB3ZSBqdXN0IHNraXAgdGhlbS5cbiAgICAgIGlmIChoYXNBY3RpdmVSb3V0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nUm91dGUgPSBtYXRjaChyb3V0ZSwgJGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGluZ1JvdXRlKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlLnNldChtYXRjaGluZ1JvdXRlKTtcbiAgICAgICAgaGFzQWN0aXZlUm91dGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByb3V0ZXMudXBkYXRlKHJzID0+IHtcbiAgICAgICAgcnMucHVzaChyb3V0ZSk7XG4gICAgICAgIHJldHVybiBycztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgIHJvdXRlcy51cGRhdGUocnMgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBycy5pbmRleE9mKHJvdXRlKTtcbiAgICAgIHJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gcnM7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUaGlzIHJlYWN0aXZlIHN0YXRlbWVudCB3aWxsIHVwZGF0ZSBhbGwgdGhlIFJvdXRlcycgcGF0aCB3aGVuXG4gIC8vIHRoZSBiYXNlcGF0aCBjaGFuZ2VzLlxuICAkOiB7XG4gICAgY29uc3QgeyBwYXRoOiBiYXNlcGF0aCB9ID0gJGJhc2U7XG4gICAgcm91dGVzLnVwZGF0ZShycyA9PiB7XG4gICAgICBycy5mb3JFYWNoKHIgPT4gKHIucGF0aCA9IGNvbWJpbmVQYXRocyhiYXNlcGF0aCwgci5fcGF0aCkpKTtcbiAgICAgIHJldHVybiBycztcbiAgICB9KTtcbiAgfVxuICAvLyBUaGlzIHJlYWN0aXZlIHN0YXRlbWVudCB3aWxsIGJlIHJ1biB3aGVuIHRoZSBSb3V0ZXIgaXMgY3JlYXRlZFxuICAvLyB3aGVuIHRoZXJlIGFyZSBubyBSb3V0ZXMgYW5kIHRoZW4gYWdhaW4gdGhlIGZvbGxvd2luZyB0aWNrLCBzbyBpdFxuICAvLyB3aWxsIG5vdCBmaW5kIGFuIGFjdGl2ZSBSb3V0ZSBpbiBTU1IgYW5kIGluIHRoZSBicm93c2VyIGl0IHdpbGwgb25seVxuICAvLyBwaWNrIGFuIGFjdGl2ZSBSb3V0ZSBhZnRlciBhbGwgUm91dGVzIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAkOiB7XG4gICAgY29uc3QgYmVzdE1hdGNoID0gcGljaygkcm91dGVzLCAkbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIGFjdGl2ZVJvdXRlLnNldChiZXN0TWF0Y2gpO1xuICB9XG5cbiAgaWYgKCFsb2NhdGlvbkNvbnRleHQpIHtcbiAgICAvLyBUaGUgdG9wbW9zdCBSb3V0ZXIgaW4gdGhlIHRyZWUgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nXG4gICAgLy8gdGhlIGxvY2F0aW9uIHN0b3JlIGFuZCBzdXBwbHlpbmcgaXQgdGhyb3VnaCBjb250ZXh0LlxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgY29uc3QgdW5saXN0ZW4gPSBnbG9iYWxIaXN0b3J5Lmxpc3RlbihoaXN0b3J5ID0+IHtcbiAgICAgICAgbG9jYXRpb24uc2V0KGhpc3RvcnkubG9jYXRpb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB1bmxpc3RlbjtcbiAgICB9KTtcblxuICAgIHNldENvbnRleHQoTE9DQVRJT04sIGxvY2F0aW9uKTtcbiAgfVxuXG4gIHNldENvbnRleHQoUk9VVEVSLCB7XG4gICAgYWN0aXZlUm91dGUsXG4gICAgYmFzZSxcbiAgICByb3V0ZXJCYXNlLFxuICAgIHJlZ2lzdGVyUm91dGUsXG4gICAgdW5yZWdpc3RlclJvdXRlXG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzbG90Pjwvc2xvdD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgUk9VVEVSLCBMT0NBVElPTiB9IGZyb20gXCIuL2NvbnRleHRzLmpzXCI7XG5cbiAgZXhwb3J0IGxldCBwYXRoID0gXCJcIjtcbiAgZXhwb3J0IGxldCBjb21wb25lbnQgPSBudWxsO1xuXG4gIGNvbnN0IHsgcmVnaXN0ZXJSb3V0ZSwgdW5yZWdpc3RlclJvdXRlLCBhY3RpdmVSb3V0ZSB9ID0gZ2V0Q29udGV4dChST1VURVIpO1xuICBjb25zdCBsb2NhdGlvbiA9IGdldENvbnRleHQoTE9DQVRJT04pO1xuXG4gIGNvbnN0IHJvdXRlID0ge1xuICAgIHBhdGgsXG4gICAgLy8gSWYgbm8gcGF0aCBwcm9wIGlzIGdpdmVuLCB0aGlzIFJvdXRlIHdpbGwgYWN0IGFzIHRoZSBkZWZhdWx0IFJvdXRlXG4gICAgLy8gdGhhdCBpcyByZW5kZXJlZCBpZiBubyBvdGhlciBSb3V0ZSBpbiB0aGUgUm91dGVyIGlzIGEgbWF0Y2guXG4gICAgZGVmYXVsdDogcGF0aCA9PT0gXCJcIlxuICB9O1xuICBsZXQgcm91dGVQYXJhbXMgPSB7fTtcbiAgbGV0IHJvdXRlUHJvcHMgPSB7fTtcblxuICAkOiBpZiAoJGFjdGl2ZVJvdXRlICYmICRhY3RpdmVSb3V0ZS5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICByb3V0ZVBhcmFtcyA9ICRhY3RpdmVSb3V0ZS5wYXJhbXM7XG4gIH1cblxuICAkOiB7XG4gICAgY29uc3QgeyBwYXRoLCBjb21wb25lbnQsIC4uLnJlc3QgfSA9ICQkcHJvcHM7XG4gICAgcm91dGVQcm9wcyA9IHJlc3Q7XG4gIH1cblxuICByZWdpc3RlclJvdXRlKHJvdXRlKTtcblxuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIHVucmVnaXN0ZXIgUm91dGVzIGluIFNTUiBzaW5jZSBpdCB3aWxsIGFsbCBiZVxuICAvLyB0aHJvd24gYXdheSBhbnl3YXkuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH1cbjwvc2NyaXB0PlxuXG57I2lmICRhY3RpdmVSb3V0ZSAhPT0gbnVsbCAmJiAkYWN0aXZlUm91dGUucm91dGUgPT09IHJvdXRlfVxuICB7I2lmIGNvbXBvbmVudCAhPT0gbnVsbH1cbiAgICA8c3ZlbHRlOmNvbXBvbmVudCB0aGlzPVwie2NvbXBvbmVudH1cIiBsb2NhdGlvbj17JGxvY2F0aW9ufSB7Li4ucm91dGVQYXJhbXN9IHsuLi5yb3V0ZVByb3BzfSAgLz5cbiAgezplbHNlfVxuICAgIDxzbG90IHBhcmFtcz1cIntyb3V0ZVBhcmFtc31cIiBsb2NhdGlvbj17JGxvY2F0aW9ufT48L3Nsb3Q+XG4gIHsvaWZ9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBST1VURVIsIExPQ0FUSU9OIH0gZnJvbSBcIi4vY29udGV4dHMuanNcIjtcbiAgaW1wb3J0IHsgbmF2aWdhdGUgfSBmcm9tIFwiLi9oaXN0b3J5LmpzXCI7XG4gIGltcG9ydCB7IHN0YXJ0c1dpdGgsIHJlc29sdmUsIHNob3VsZE5hdmlnYXRlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuICBleHBvcnQgbGV0IHRvID0gXCIjXCI7XG4gIGV4cG9ydCBsZXQgcmVwbGFjZSA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHN0YXRlID0ge307XG4gIGV4cG9ydCBsZXQgZ2V0UHJvcHMgPSAoKSA9PiAoe30pO1xuXG4gIGNvbnN0IHsgYmFzZSB9ID0gZ2V0Q29udGV4dChST1VURVIpO1xuICBjb25zdCBsb2NhdGlvbiA9IGdldENvbnRleHQoTE9DQVRJT04pO1xuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBocmVmLCBpc1BhcnRpYWxseUN1cnJlbnQsIGlzQ3VycmVudCwgcHJvcHM7XG4gICQ6IGhyZWYgPSB0byA9PT0gXCIvXCIgPyAkYmFzZS51cmkgOiByZXNvbHZlKHRvLCAkYmFzZS51cmkpO1xuICAkOiBpc1BhcnRpYWxseUN1cnJlbnQgPSBzdGFydHNXaXRoKCRsb2NhdGlvbi5wYXRobmFtZSwgaHJlZik7XG4gICQ6IGlzQ3VycmVudCA9IGhyZWYgPT09ICRsb2NhdGlvbi5wYXRobmFtZTtcbiAgJDogYXJpYUN1cnJlbnQgPSBpc0N1cnJlbnQgPyBcInBhZ2VcIiA6IHVuZGVmaW5lZDtcbiAgJDogcHJvcHMgPSBnZXRQcm9wcyh7XG4gICAgbG9jYXRpb246ICRsb2NhdGlvbixcbiAgICBocmVmLFxuICAgIGlzUGFydGlhbGx5Q3VycmVudCxcbiAgICBpc0N1cnJlbnRcbiAgfSk7XG5cbiAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIGRpc3BhdGNoKFwiY2xpY2tcIiwgZXZlbnQpO1xuXG4gICAgaWYgKHNob3VsZE5hdmlnYXRlKGV2ZW50KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIERvbid0IHB1c2ggYW5vdGhlciBlbnRyeSB0byB0aGUgaGlzdG9yeSBzdGFjayB3aGVuIHRoZSB1c2VyXG4gICAgICAvLyBjbGlja3Mgb24gYSBMaW5rIHRvIHRoZSBwYWdlIHRoZXkgYXJlIGN1cnJlbnRseSBvbi5cbiAgICAgIGNvbnN0IHNob3VsZFJlcGxhY2UgPSAkbG9jYXRpb24ucGF0aG5hbWUgPT09IGhyZWYgfHwgcmVwbGFjZTtcbiAgICAgIG5hdmlnYXRlKGhyZWYsIHsgc3RhdGUsIHJlcGxhY2U6IHNob3VsZFJlcGxhY2UgfSk7XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPGEgaHJlZj1cIntocmVmfVwiIGFyaWEtY3VycmVudD1cInthcmlhQ3VycmVudH1cIiBvbjpjbGljaz1cIntvbkNsaWNrfVwiIHsuLi5wcm9wc30+XG4gIDxzbG90Pjwvc2xvdD5cbjwvYT5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBOYXZiYXIgZnJvbSAnLi4vY29tcG9uZW50cy9OYXZiYXIuc3ZlbHRlJ1xuICBpbXBvcnQgVGFiYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVGFiYmFyLnN2ZWx0ZSdcbiAgaW1wb3J0IFByb2ZpbGVIZWFkZXIgZnJvbSAnLi4vY29tcG9uZW50cy9Qcm9maWxlSGVhZGVyLnN2ZWx0ZSdcbiAgaW1wb3J0IEFib3V0IGZyb20gJy4uL2NvbXBvbmVudHMvQWJvdXQuc3ZlbHRlJ1xuICBpbXBvcnQgeyB1c2VybmFtZSB9IGZyb20gJy4vc3RvcmVzLmpzJ1xuICBpbXBvcnQgeyBSb3V0ZXIsIExpbmssIFJvdXRlIH0gZnJvbSAnc3ZlbHRlLXJvdXRpbmcnXG5cbiAgbGV0IHVzZXJuYW1lX3ZhbHVlXG5cbiAgY29uc3QgdW5zdWJzY3JpYmUgPSB1c2VybmFtZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgdXNlcm5hbWVfdmFsdWUgPSB2YWx1ZVxuICB9KVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cbiAgPHRpdGxlPlByb2ZpbGUgOjogU3RlYW0gTW9iaWxlPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxOYXZiYXIgdGl0bGU9XCJQcm9maWxlXCIgLz5cbjxkaXYgaWQ9XCJwcm9maWxlXCI+XG4gIDxQcm9maWxlSGVhZGVyXG4gICAgbmFtZT17dXNlcm5hbWVfdmFsdWV9XG4gICAgYWxpYXM9XCJiaW5nb3RoZXNsYXllclwiXG4gICAgcHJvZmlsZXBpY3R1cmU9XCJwcm9maWxlcGljdHVyZS5qcGdcIlxuICAgIGxldmVsPVwiNDBcIiAvPlxuICA8ZGl2IGlkPVwibmF2dHJheVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RlZFwiPkFib3V0PC9kaXY+XG4gICAgPGRpdj5BY3Rpdml0eTwvZGl2PlxuICAgIDxkaXY+SW52ZW50b3J5PC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+XG4gICAgPEFib3V0IC8+XG4gIDwvZGl2PlxuPC9kaXY+XG48VGFiYmFyIGxvY2F0aW9uPXsyfSAvPlxuXG48c3R5bGU+XG4gICNjb250YWluZXIge1xuICAgIHBhZGRpbmc6IDIwcHggMzBweDtcbiAgfVxuXG4gICNwcm9maWxlIHtcbiAgICBwYWRkaW5nOiA2MHB4IDBweDtcbiAgfVxuXG4gICNuYXZ0cmF5IHtcbiAgICBwYWRkaW5nOiAwcHggMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICB9XG5cbiAgI25hdnRyYXkgZGl2IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGYwYjIwO1xuICAgIHdpZHRoOiAyMiU7XG4gICAgaGVpZ2h0OiAzMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gIH1cblxuICAuc2VsZWN0ZWQge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICMwMjdhZmY7XG4gIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFhZSxHQUFLOzs7c0JBQ0wsR0FBSTs7O3VCQUdNLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQUpmLEdBQUs7Ozs7O3NDQUNMLEdBQUk7Ozs7Ozt5Q0FHTSxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O21FQU5VLEdBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29FQUFkLEdBQWM7Ozt1REFFdkMsR0FBSztxREFDTCxHQUFJO3VEQUdNLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhCakIsS0FBSztJQUFFLElBQUk7SUFBRSxjQUFjO0lBQUUsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
