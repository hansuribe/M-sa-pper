import {
  S as SvelteComponentDev,
  i as init,
  s as safe_not_equal,
  d as dispatch_dev,
  v as validate_slots,
  e as element,
  t as text,
  c as claim_element,
  b as children,
  h as claim_text,
  f as detach_dev,
  j as attr_dev,
  l as add_location,
  k as set_style,
  m as insert_dev,
  n as append_dev,
  o as set_data_dev,
  p as noop,
  a as space,
  q as create_component,
  g as claim_space,
  u as claim_component,
  w as mount_component,
  x as transition_in,
  y as transition_out,
  z as destroy_component,
  D as null_to_empty,
  E as run_all,
  F as listen_dev,
  K as group_outros,
  L as check_outros,
  r as query_selector_all,
} from './client.2e3a1ea0.js'
import { N as Navbar, T as Tabbar } from './Tabbar.73058c64.js'

/* src/components/RecentChat.svelte generated by Svelte v3.22.2 */

const file = 'src/components/RecentChat.svelte'

function create_fragment(ctx) {
  let div1
  let div0
  let t
  let div0_class_value
  let div1_class_value

  const block = {
    c: function create() {
      div1 = element('div')
      div0 = element('div')
      t = text(/*name*/ ctx[2])
      this.h()
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, 'DIV', { id: true, class: true, style: true })
      var div1_nodes = children(div1)
      div0 = claim_element(div1_nodes, 'DIV', { id: true, class: true })
      var div0_nodes = children(div0)
      t = claim_text(div0_nodes, /*name*/ ctx[2])
      div0_nodes.forEach(detach_dev)
      div1_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(div0, 'id', 'name')
      attr_dev(
        div0,
        'class',
        (div0_class_value =
          '' +
          (/*status*/ (ctx[1] === 1 ? 'name--ingame' : '') +
            /*status*/ (ctx[1] === 2 ? 'name--online' : '') +
            /*status*/ (ctx[1] === 3 ? 'status offline' : '') +
            ' svelte-gwm1hn'))
      )
      add_location(div0, file, 12, 2, 314)
      attr_dev(div1, 'id', 'imageholder')
      attr_dev(
        div1,
        'class',
        (div1_class_value =
          '' +
          (/*status*/ (ctx[1] === 1 ? 'status ingame' : '') +
            /*status*/ (ctx[1] === 2 ? 'status online' : '') +
            /*status*/ (ctx[1] === 3 ? 'status offline' : '') +
            ' svelte-gwm1hn'))
      )
      set_style(div1, 'background-image', 'url(' + /*image*/ ctx[0] + ')')
      add_location(div1, file, 8, 0, 122)
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor)
      append_dev(div1, div0)
      append_dev(div0, t)
    },
    p: function update(ctx, [dirty]) {
      if (dirty & /*name*/ 4) set_data_dev(t, /*name*/ ctx[2])

      if (
        dirty & /*status*/ 2 &&
        div0_class_value !==
          (div0_class_value =
            '' +
            (/*status*/ (ctx[1] === 1 ? 'name--ingame' : '') +
              /*status*/ (ctx[1] === 2 ? 'name--online' : '') +
              /*status*/ (ctx[1] === 3 ? 'status offline' : '') +
              ' svelte-gwm1hn'))
      ) {
        attr_dev(div0, 'class', div0_class_value)
      }

      if (
        dirty & /*status*/ 2 &&
        div1_class_value !==
          (div1_class_value =
            '' +
            (/*status*/ (ctx[1] === 1 ? 'status ingame' : '') +
              /*status*/ (ctx[1] === 2 ? 'status online' : '') +
              /*status*/ (ctx[1] === 3 ? 'status offline' : '') +
              ' svelte-gwm1hn'))
      ) {
        attr_dev(div1, 'class', div1_class_value)
      }

      if (dirty & /*image*/ 1) {
        set_style(div1, 'background-image', 'url(' + /*image*/ ctx[0] + ')')
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_fragment.name,
    type: 'component',
    source: '',
    ctx,
  })

  return block
}

function instance($$self, $$props, $$invalidate) {
  let { image } = $$props,
    { status } = $$props,
    { name } = $$props
  const writable_props = ['image', 'status', 'name']

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$')
      console.warn(`<RecentChat> was created with unknown prop '${key}'`)
  })

  let { $$slots = {}, $$scope } = $$props
  validate_slots('RecentChat', $$slots, [])

  $$self.$set = ($$props) => {
    if ('image' in $$props) $$invalidate(0, (image = $$props.image))
    if ('status' in $$props) $$invalidate(1, (status = $$props.status))
    if ('name' in $$props) $$invalidate(2, (name = $$props.name))
  }

  $$self.$capture_state = () => ({ image, status, name })

  $$self.$inject_state = ($$props) => {
    if ('image' in $$props) $$invalidate(0, (image = $$props.image))
    if ('status' in $$props) $$invalidate(1, (status = $$props.status))
    if ('name' in $$props) $$invalidate(2, (name = $$props.name))
  }

  if ($$props && '$$inject' in $$props) {
    $$self.$inject_state($$props.$$inject)
  }

  return [image, status, name]
}

class RecentChat extends SvelteComponentDev {
  constructor(options) {
    super(options)
    init(this, options, instance, create_fragment, safe_not_equal, {
      image: 0,
      status: 1,
      name: 2,
    })

    dispatch_dev('SvelteRegisterComponent', {
      component: this,
      tagName: 'RecentChat',
      options,
      id: create_fragment.name,
    })

    const { ctx } = this.$$
    const props = options.props || {}

    if (/*image*/ ctx[0] === undefined && !('image' in props)) {
      console.warn("<RecentChat> was created without expected prop 'image'")
    }

    if (/*status*/ ctx[1] === undefined && !('status' in props)) {
      console.warn("<RecentChat> was created without expected prop 'status'")
    }

    if (/*name*/ ctx[2] === undefined && !('name' in props)) {
      console.warn("<RecentChat> was created without expected prop 'name'")
    }
  }

  get image() {
    throw new Error(
      "<RecentChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set image(value) {
    throw new Error(
      "<RecentChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get status() {
    throw new Error(
      "<RecentChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set status(value) {
    throw new Error(
      "<RecentChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get name() {
    throw new Error(
      "<RecentChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set name(value) {
    throw new Error(
      "<RecentChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }
}

/* src/components/RecentChats.svelte generated by Svelte v3.22.2 */
const file$1 = 'src/components/RecentChats.svelte'

function create_fragment$1(ctx) {
  let div1
  let h3
  let t0
  let t1
  let div0
  let t2
  let t3
  let t4
  let current

  const recentchat0 = new RecentChat({
    props: {
      image: 'friendone.png',
      status: 1,
      name: 'bingotheslayeer',
    },
    $$inline: true,
  })

  const recentchat1 = new RecentChat({
    props: {
      image: 'friendtwo.png',
      status: 2,
      name: 'fatherdeath',
    },
    $$inline: true,
  })

  const recentchat2 = new RecentChat({
    props: {
      image: 'friendthree.png',
      status: 2,
      name: 'pyschotherapist',
    },
    $$inline: true,
  })

  const recentchat3 = new RecentChat({
    props: {
      image: 'friendfour.png',
      status: 3,
      name: 'fatfather64',
    },
    $$inline: true,
  })

  const block = {
    c: function create() {
      div1 = element('div')
      h3 = element('h3')
      t0 = text('Recent Chats')
      t1 = space()
      div0 = element('div')
      create_component(recentchat0.$$.fragment)
      t2 = space()
      create_component(recentchat1.$$.fragment)
      t3 = space()
      create_component(recentchat2.$$.fragment)
      t4 = space()
      create_component(recentchat3.$$.fragment)
      this.h()
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, 'DIV', { id: true, class: true })
      var div1_nodes = children(div1)
      h3 = claim_element(div1_nodes, 'H3', { class: true })
      var h3_nodes = children(h3)
      t0 = claim_text(h3_nodes, 'Recent Chats')
      h3_nodes.forEach(detach_dev)
      t1 = claim_space(div1_nodes)
      div0 = claim_element(div1_nodes, 'DIV', { id: true, class: true })
      var div0_nodes = children(div0)
      claim_component(recentchat0.$$.fragment, div0_nodes)
      t2 = claim_space(div0_nodes)
      claim_component(recentchat1.$$.fragment, div0_nodes)
      t3 = claim_space(div0_nodes)
      claim_component(recentchat2.$$.fragment, div0_nodes)
      t4 = claim_space(div0_nodes)
      claim_component(recentchat3.$$.fragment, div0_nodes)
      div0_nodes.forEach(detach_dev)
      div1_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(h3, 'class', 'svelte-kha6qg')
      add_location(h3, file$1, 11, 2, 174)
      attr_dev(div0, 'id', 'list')
      attr_dev(div0, 'class', 'svelte-kha6qg')
      add_location(div0, file$1, 12, 2, 198)
      attr_dev(div1, 'id', 'card')
      attr_dev(div1, 'class', 'svelte-kha6qg')
      add_location(div1, file$1, 10, 0, 156)
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor)
      append_dev(div1, h3)
      append_dev(h3, t0)
      append_dev(div1, t1)
      append_dev(div1, div0)
      mount_component(recentchat0, div0, null)
      append_dev(div0, t2)
      mount_component(recentchat1, div0, null)
      append_dev(div0, t3)
      mount_component(recentchat2, div0, null)
      append_dev(div0, t4)
      mount_component(recentchat3, div0, null)
      current = true
    },
    p: noop,
    i: function intro(local) {
      if (current) return
      transition_in(recentchat0.$$.fragment, local)
      transition_in(recentchat1.$$.fragment, local)
      transition_in(recentchat2.$$.fragment, local)
      transition_in(recentchat3.$$.fragment, local)
      current = true
    },
    o: function outro(local) {
      transition_out(recentchat0.$$.fragment, local)
      transition_out(recentchat1.$$.fragment, local)
      transition_out(recentchat2.$$.fragment, local)
      transition_out(recentchat3.$$.fragment, local)
      current = false
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1)
      destroy_component(recentchat0)
      destroy_component(recentchat1)
      destroy_component(recentchat2)
      destroy_component(recentchat3)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_fragment$1.name,
    type: 'component',
    source: '',
    ctx,
  })

  return block
}

function instance$1($$self, $$props, $$invalidate) {
  let { title } = $$props
  const writable_props = ['title']

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$')
      console.warn(`<RecentChats> was created with unknown prop '${key}'`)
  })

  let { $$slots = {}, $$scope } = $$props
  validate_slots('RecentChats', $$slots, [])

  $$self.$set = ($$props) => {
    if ('title' in $$props) $$invalidate(0, (title = $$props.title))
  }

  $$self.$capture_state = () => ({ RecentChat, title })

  $$self.$inject_state = ($$props) => {
    if ('title' in $$props) $$invalidate(0, (title = $$props.title))
  }

  if ($$props && '$$inject' in $$props) {
    $$self.$inject_state($$props.$$inject)
  }

  return [title]
}

class RecentChats extends SvelteComponentDev {
  constructor(options) {
    super(options)
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
      title: 0,
    })

    dispatch_dev('SvelteRegisterComponent', {
      component: this,
      tagName: 'RecentChats',
      options,
      id: create_fragment$1.name,
    })

    const { ctx } = this.$$
    const props = options.props || {}

    if (/*title*/ ctx[0] === undefined && !('title' in props)) {
      console.warn("<RecentChats> was created without expected prop 'title'")
    }
  }

  get title() {
    throw new Error(
      "<RecentChats>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set title(value) {
    throw new Error(
      "<RecentChats>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }
}

/* src/components/ChatsTile.svelte generated by Svelte v3.22.2 */

const file$2 = 'src/components/ChatsTile.svelte'

// (20:22)
function create_if_block_1(ctx) {
  let div
  let t0
  let t1
  let t2

  const block = {
    c: function create() {
      div = element('div')
      t0 = text('Last online ')
      t1 = text(/*timestamp*/ ctx[4])
      t2 = text(' days ago')
      this.h()
    },
    l: function claim(nodes) {
      div = claim_element(nodes, 'DIV', { id: true, class: true })
      var div_nodes = children(div)
      t0 = claim_text(div_nodes, 'Last online ')
      t1 = claim_text(div_nodes, /*timestamp*/ ctx[4])
      t2 = claim_text(div_nodes, ' days ago')
      div_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(div, 'id', 'lastonline')
      attr_dev(div, 'class', 'svelte-zt7sbu')
      add_location(div, file$2, 20, 6, 653)
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor)
      append_dev(div, t0)
      append_dev(div, t1)
      append_dev(div, t2)
    },
    p: function update(ctx, dirty) {
      if (dirty & /*timestamp*/ 16) set_data_dev(t1, /*timestamp*/ ctx[4])
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_if_block_1.name,
    type: 'if',
    source: '(20:22) ',
    ctx,
  })

  return block
}

// (16:4) {#if !offline}
function create_if_block(ctx) {
  let div
  let t_value = (!(/*gameName*/ ctx[1]) ? 'Online' : /*gameName*/ ctx[1]) + ''
  let t
  let div_class_value

  const block = {
    c: function create() {
      div = element('div')
      t = text(t_value)
      this.h()
    },
    l: function claim(nodes) {
      div = claim_element(nodes, 'DIV', { id: true, class: true })
      var div_nodes = children(div)
      t = claim_text(div_nodes, t_value)
      div_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(div, 'id', 'usergame')
      attr_dev(
        div,
        'class',
        (div_class_value =
          '' +
          (null_to_empty(!(/*gameName*/ ctx[1]) ? 'onlinegamename' : '') +
            ' svelte-zt7sbu'))
      )
      add_location(div, file$2, 16, 6, 507)
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor)
      append_dev(div, t)
    },
    p: function update(ctx, dirty) {
      if (
        dirty & /*gameName*/ 2 &&
        t_value !==
          (t_value =
            (!(/*gameName*/ ctx[1]) ? 'Online' : /*gameName*/ ctx[1]) + '')
      )
        set_data_dev(t, t_value)

      if (
        dirty & /*gameName*/ 2 &&
        div_class_value !==
          (div_class_value =
            '' +
            (null_to_empty(!(/*gameName*/ ctx[1]) ? 'onlinegamename' : '') +
              ' svelte-zt7sbu'))
      ) {
        attr_dev(div, 'class', div_class_value)
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_if_block.name,
    type: 'if',
    source: '(16:4) {#if !offline}',
    ctx,
  })

  return block
}

function create_fragment$2(ctx) {
  let li
  let div0
  let t0
  let div2
  let div1
  let t1
  let div1_class_value
  let t2
  let li_class_value

  function select_block_type(ctx, dirty) {
    if (!(/*offline*/ ctx[5])) return create_if_block
    if (/*offline*/ ctx[5]) return create_if_block_1
  }

  let current_block_type = select_block_type(ctx)
  let if_block = current_block_type && current_block_type(ctx)

  const block = {
    c: function create() {
      li = element('li')
      div0 = element('div')
      t0 = space()
      div2 = element('div')
      div1 = element('div')
      t1 = text(/*userName*/ ctx[0])
      t2 = space()
      if (if_block) if_block.c()
      this.h()
    },
    l: function claim(nodes) {
      li = claim_element(nodes, 'LI', { class: true })
      var li_nodes = children(li)
      div0 = claim_element(li_nodes, 'DIV', {
        id: true,
        style: true,
        class: true,
      })
      children(div0).forEach(detach_dev)
      t0 = claim_space(li_nodes)
      div2 = claim_element(li_nodes, 'DIV', { id: true, class: true })
      var div2_nodes = children(div2)
      div1 = claim_element(div2_nodes, 'DIV', { id: true, class: true })
      var div1_nodes = children(div1)
      t1 = claim_text(div1_nodes, /*userName*/ ctx[0])
      div1_nodes.forEach(detach_dev)
      t2 = claim_space(div2_nodes)
      if (if_block) if_block.l(div2_nodes)
      div2_nodes.forEach(detach_dev)
      li_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(div0, 'id', 'userimage')
      set_style(div0, 'background-image', 'url(' + /*userImage*/ ctx[2] + ')')
      attr_dev(div0, 'class', 'svelte-zt7sbu')
      add_location(div0, file$2, 10, 2, 304)
      attr_dev(div1, 'id', 'username')
      attr_dev(
        div1,
        'class',
        (div1_class_value =
          '' +
          (null_to_empty(!(/*gameName*/ ctx[1]) ? 'onlineusername' : '') +
            ' svelte-zt7sbu'))
      )
      add_location(div1, file$2, 12, 4, 392)
      attr_dev(div2, 'id', 'info')
      attr_dev(div2, 'class', 'svelte-zt7sbu')
      add_location(div2, file$2, 11, 2, 372)

      attr_dev(
        li,
        'class',
        (li_class_value =
          '' +
          (/*status*/ (ctx[3] === 1 ? 'status ingame' : '') +
            /*status*/ (ctx[3] === 2 ? 'status online' : '') +
            /*status*/ (ctx[3] === 3 ? 'status offline statusoffline' : '') +
            ' svelte-zt7sbu'))
      )

      add_location(li, file$2, 8, 0, 160)
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor)
      append_dev(li, div0)
      append_dev(li, t0)
      append_dev(li, div2)
      append_dev(div2, div1)
      append_dev(div1, t1)
      append_dev(div2, t2)
      if (if_block) if_block.m(div2, null)
    },
    p: function update(ctx, [dirty]) {
      if (dirty & /*userImage*/ 4) {
        set_style(div0, 'background-image', 'url(' + /*userImage*/ ctx[2] + ')')
      }

      if (dirty & /*userName*/ 1) set_data_dev(t1, /*userName*/ ctx[0])

      if (
        dirty & /*gameName*/ 2 &&
        div1_class_value !==
          (div1_class_value =
            '' +
            (null_to_empty(!(/*gameName*/ ctx[1]) ? 'onlineusername' : '') +
              ' svelte-zt7sbu'))
      ) {
        attr_dev(div1, 'class', div1_class_value)
      }

      if (
        current_block_type === (current_block_type = select_block_type(ctx)) &&
        if_block
      ) {
        if_block.p(ctx, dirty)
      } else {
        if (if_block) if_block.d(1)
        if_block = current_block_type && current_block_type(ctx)

        if (if_block) {
          if_block.c()
          if_block.m(div2, null)
        }
      }

      if (
        dirty & /*status*/ 8 &&
        li_class_value !==
          (li_class_value =
            '' +
            (/*status*/ (ctx[3] === 1 ? 'status ingame' : '') +
              /*status*/ (ctx[3] === 2 ? 'status online' : '') +
              /*status*/ (ctx[3] === 3 ? 'status offline statusoffline' : '') +
              ' svelte-zt7sbu'))
      ) {
        attr_dev(li, 'class', li_class_value)
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(li)

      if (if_block) {
        if_block.d()
      }
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_fragment$2.name,
    type: 'component',
    source: '',
    ctx,
  })

  return block
}

function instance$2($$self, $$props, $$invalidate) {
  let { userName } = $$props,
    { gameName } = $$props,
    { userImage } = $$props,
    { status } = $$props,
    { timestamp } = $$props,
    { offline } = $$props

  const writable_props = [
    'userName',
    'gameName',
    'userImage',
    'status',
    'timestamp',
    'offline',
  ]

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$')
      console.warn(`<ChatsTile> was created with unknown prop '${key}'`)
  })

  let { $$slots = {}, $$scope } = $$props
  validate_slots('ChatsTile', $$slots, [])

  $$self.$set = ($$props) => {
    if ('userName' in $$props) $$invalidate(0, (userName = $$props.userName))
    if ('gameName' in $$props) $$invalidate(1, (gameName = $$props.gameName))
    if ('userImage' in $$props) $$invalidate(2, (userImage = $$props.userImage))
    if ('status' in $$props) $$invalidate(3, (status = $$props.status))
    if ('timestamp' in $$props) $$invalidate(4, (timestamp = $$props.timestamp))
    if ('offline' in $$props) $$invalidate(5, (offline = $$props.offline))
  }

  $$self.$capture_state = () => ({
    userName,
    gameName,
    userImage,
    status,
    timestamp,
    offline,
  })

  $$self.$inject_state = ($$props) => {
    if ('userName' in $$props) $$invalidate(0, (userName = $$props.userName))
    if ('gameName' in $$props) $$invalidate(1, (gameName = $$props.gameName))
    if ('userImage' in $$props) $$invalidate(2, (userImage = $$props.userImage))
    if ('status' in $$props) $$invalidate(3, (status = $$props.status))
    if ('timestamp' in $$props) $$invalidate(4, (timestamp = $$props.timestamp))
    if ('offline' in $$props) $$invalidate(5, (offline = $$props.offline))
  }

  if ($$props && '$$inject' in $$props) {
    $$self.$inject_state($$props.$$inject)
  }

  return [userName, gameName, userImage, status, timestamp, offline]
}

class ChatsTile extends SvelteComponentDev {
  constructor(options) {
    super(options)

    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
      userName: 0,
      gameName: 1,
      userImage: 2,
      status: 3,
      timestamp: 4,
      offline: 5,
    })

    dispatch_dev('SvelteRegisterComponent', {
      component: this,
      tagName: 'ChatsTile',
      options,
      id: create_fragment$2.name,
    })

    const { ctx } = this.$$
    const props = options.props || {}

    if (/*userName*/ ctx[0] === undefined && !('userName' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'userName'")
    }

    if (/*gameName*/ ctx[1] === undefined && !('gameName' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'gameName'")
    }

    if (/*userImage*/ ctx[2] === undefined && !('userImage' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'userImage'")
    }

    if (/*status*/ ctx[3] === undefined && !('status' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'status'")
    }

    if (/*timestamp*/ ctx[4] === undefined && !('timestamp' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'timestamp'")
    }

    if (/*offline*/ ctx[5] === undefined && !('offline' in props)) {
      console.warn("<ChatsTile> was created without expected prop 'offline'")
    }
  }

  get userName() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set userName(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get gameName() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set gameName(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get userImage() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set userImage(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get status() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set status(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get timestamp() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set timestamp(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  get offline() {
    throw new Error(
      "<ChatsTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }

  set offline(value) {
    throw new Error(
      "<ChatsTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'"
    )
  }
}

/* src/components/Chats.svelte generated by Svelte v3.22.2 */
const file$3 = 'src/components/Chats.svelte'

// (32:2) {#if !offline}
function create_if_block_1$1(ctx) {
  let ul
  let t0
  let t1
  let current

  const chatstile0 = new ChatsTile({
    props: {
      userName: 'bingotheslayer',
      gameName: 'Dank Souls 3',
      userImage: 'friendone.png',
      status: 1,
      offline: /*offline*/ ctx[0],
    },
    $$inline: true,
  })

  const chatstile1 = new ChatsTile({
    props: {
      userName: 'fatherdeath',
      userImage: 'friendtwo.png',
      status: 2,
      offline: /*offline*/ ctx[0],
    },
    $$inline: true,
  })

  const chatstile2 = new ChatsTile({
    props: {
      userName: 'pyschotherapist',
      userImage: 'friendthree.png',
      status: 2,
      offline: /*offline*/ ctx[0],
    },
    $$inline: true,
  })

  const block = {
    c: function create() {
      ul = element('ul')
      create_component(chatstile0.$$.fragment)
      t0 = space()
      create_component(chatstile1.$$.fragment)
      t1 = space()
      create_component(chatstile2.$$.fragment)
      this.h()
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, 'UL', { class: true })
      var ul_nodes = children(ul)
      claim_component(chatstile0.$$.fragment, ul_nodes)
      t0 = claim_space(ul_nodes)
      claim_component(chatstile1.$$.fragment, ul_nodes)
      t1 = claim_space(ul_nodes)
      claim_component(chatstile2.$$.fragment, ul_nodes)
      ul_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(ul, 'class', 'svelte-1najpus')
      add_location(ul, file$3, 32, 4, 630)
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor)
      mount_component(chatstile0, ul, null)
      append_dev(ul, t0)
      mount_component(chatstile1, ul, null)
      append_dev(ul, t1)
      mount_component(chatstile2, ul, null)
      current = true
    },
    p: function update(ctx, dirty) {
      const chatstile0_changes = {}
      if (dirty & /*offline*/ 1) chatstile0_changes.offline = /*offline*/ ctx[0]
      chatstile0.$set(chatstile0_changes)
      const chatstile1_changes = {}
      if (dirty & /*offline*/ 1) chatstile1_changes.offline = /*offline*/ ctx[0]
      chatstile1.$set(chatstile1_changes)
      const chatstile2_changes = {}
      if (dirty & /*offline*/ 1) chatstile2_changes.offline = /*offline*/ ctx[0]
      chatstile2.$set(chatstile2_changes)
    },
    i: function intro(local) {
      if (current) return
      transition_in(chatstile0.$$.fragment, local)
      transition_in(chatstile1.$$.fragment, local)
      transition_in(chatstile2.$$.fragment, local)
      current = true
    },
    o: function outro(local) {
      transition_out(chatstile0.$$.fragment, local)
      transition_out(chatstile1.$$.fragment, local)
      transition_out(chatstile2.$$.fragment, local)
      current = false
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(ul)
      destroy_component(chatstile0)
      destroy_component(chatstile1)
      destroy_component(chatstile2)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_if_block_1$1.name,
    type: 'if',
    source: '(32:2) {#if !offline}',
    ctx,
  })

  return block
}

// (52:2) {#if offline}
function create_if_block$1(ctx) {
  let ul
  let t
  let current

  const chatstile0 = new ChatsTile({
    props: {
      userName: 'fatfather64',
      gameName: 'Grand Theft Auto: San Andreas',
      userImage: 'friendfour.png',
      status: 3,
      offline: /*offline*/ ctx[0],
      timestamp: '6',
    },
    $$inline: true,
  })

  const chatstile1 = new ChatsTile({
    props: {
      userName: 'dingdongding',
      gameName: 'Grand Theft Auto: San Andreas',
      userImage: 'profilepicture.jpg',
      status: 3,
      offline: /*offline*/ ctx[0],
      timestamp: '12',
    },
    $$inline: true,
  })

  const block = {
    c: function create() {
      ul = element('ul')
      create_component(chatstile0.$$.fragment)
      t = space()
      create_component(chatstile1.$$.fragment)
      this.h()
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, 'UL', { class: true })
      var ul_nodes = children(ul)
      claim_component(chatstile0.$$.fragment, ul_nodes)
      t = claim_space(ul_nodes)
      claim_component(chatstile1.$$.fragment, ul_nodes)
      ul_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(ul, 'class', 'svelte-1najpus')
      add_location(ul, file$3, 52, 4, 1080)
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor)
      mount_component(chatstile0, ul, null)
      append_dev(ul, t)
      mount_component(chatstile1, ul, null)
      current = true
    },
    p: function update(ctx, dirty) {
      const chatstile0_changes = {}
      if (dirty & /*offline*/ 1) chatstile0_changes.offline = /*offline*/ ctx[0]
      chatstile0.$set(chatstile0_changes)
      const chatstile1_changes = {}
      if (dirty & /*offline*/ 1) chatstile1_changes.offline = /*offline*/ ctx[0]
      chatstile1.$set(chatstile1_changes)
    },
    i: function intro(local) {
      if (current) return
      transition_in(chatstile0.$$.fragment, local)
      transition_in(chatstile1.$$.fragment, local)
      current = true
    },
    o: function outro(local) {
      transition_out(chatstile0.$$.fragment, local)
      transition_out(chatstile1.$$.fragment, local)
      current = false
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(ul)
      destroy_component(chatstile0)
      destroy_component(chatstile1)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_if_block$1.name,
    type: 'if',
    source: '(52:2) {#if offline}',
    ctx,
  })

  return block
}

function create_fragment$3(ctx) {
  let div2
  let div1
  let div0
  let h30
  let t0
  let t1
  let t2
  let h30_class_value
  let t3
  let h31
  let t4
  let t5
  let t6
  let h31_class_value
  let t7
  let t8
  let current
  let dispose
  let if_block0 = !(/*offline*/ ctx[0]) && create_if_block_1$1(ctx)
  let if_block1 = /*offline*/ ctx[0] && create_if_block$1(ctx)

  const block = {
    c: function create() {
      div2 = element('div')
      div1 = element('div')
      div0 = element('div')
      h30 = element('h3')
      t0 = text('Online (')
      t1 = text(/*onlineusers*/ ctx[1])
      t2 = text(')')
      t3 = space()
      h31 = element('h3')
      t4 = text('Offline (')
      t5 = text(/*offlineusers*/ ctx[2])
      t6 = text(')')
      t7 = space()
      if (if_block0) if_block0.c()
      t8 = space()
      if (if_block1) if_block1.c()
      this.h()
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, 'DIV', { id: true, class: true })
      var div2_nodes = children(div2)
      div1 = claim_element(div2_nodes, 'DIV', { id: true, class: true })
      var div1_nodes = children(div1)
      div0 = claim_element(div1_nodes, 'DIV', { id: true, class: true })
      var div0_nodes = children(div0)
      h30 = claim_element(div0_nodes, 'H3', { class: true })
      var h30_nodes = children(h30)
      t0 = claim_text(h30_nodes, 'Online (')
      t1 = claim_text(h30_nodes, /*onlineusers*/ ctx[1])
      t2 = claim_text(h30_nodes, ')')
      h30_nodes.forEach(detach_dev)
      t3 = claim_space(div0_nodes)
      h31 = claim_element(div0_nodes, 'H3', { class: true })
      var h31_nodes = children(h31)
      t4 = claim_text(h31_nodes, 'Offline (')
      t5 = claim_text(h31_nodes, /*offlineusers*/ ctx[2])
      t6 = claim_text(h31_nodes, ')')
      h31_nodes.forEach(detach_dev)
      div0_nodes.forEach(detach_dev)
      div1_nodes.forEach(detach_dev)
      t7 = claim_space(div2_nodes)
      if (if_block0) if_block0.l(div2_nodes)
      t8 = claim_space(div2_nodes)
      if (if_block1) if_block1.l(div2_nodes)
      div2_nodes.forEach(detach_dev)
      this.h()
    },
    h: function hydrate() {
      attr_dev(
        h30,
        'class',
        (h30_class_value =
          '' +
          (null_to_empty(!(/*offline*/ ctx[0]) ? 'selectedtab' : '') +
            ' svelte-1najpus'))
      )
      add_location(h30, file$3, 15, 6, 269)
      attr_dev(
        h31,
        'class',
        (h31_class_value =
          '' +
          (null_to_empty(/*offline*/ ctx[0] ? 'selectedtab' : '') +
            ' svelte-1najpus'))
      )
      add_location(h31, file$3, 22, 6, 432)
      attr_dev(div0, 'id', 'tabs')
      attr_dev(div0, 'class', 'svelte-1najpus')
      add_location(div0, file$3, 14, 4, 247)
      attr_dev(div1, 'id', 'tabscontainer')
      attr_dev(div1, 'class', 'svelte-1najpus')
      add_location(div1, file$3, 13, 2, 218)
      attr_dev(div2, 'id', 'card')
      attr_dev(div2, 'class', 'svelte-1najpus')
      add_location(div2, file$3, 12, 0, 200)
    },
    m: function mount(target, anchor, remount) {
      insert_dev(target, div2, anchor)
      append_dev(div2, div1)
      append_dev(div1, div0)
      append_dev(div0, h30)
      append_dev(h30, t0)
      append_dev(h30, t1)
      append_dev(h30, t2)
      append_dev(div0, t3)
      append_dev(div0, h31)
      append_dev(h31, t4)
      append_dev(h31, t5)
      append_dev(h31, t6)
      append_dev(div2, t7)
      if (if_block0) if_block0.m(div2, null)
      append_dev(div2, t8)
      if (if_block1) if_block1.m(div2, null)
      current = true
      if (remount) run_all(dispose)

      dispose = [
        listen_dev(h30, 'click', /*click_handler*/ ctx[3], false, false, false),
        listen_dev(
          h31,
          'click',
          /*click_handler_1*/ ctx[4],
          false,
          false,
          false
        ),
      ]
    },
    p: function update(ctx, [dirty]) {
      if (
        !current ||
        (dirty & /*offline*/ 1 &&
          h30_class_value !==
            (h30_class_value =
              '' +
              (null_to_empty(!(/*offline*/ ctx[0]) ? 'selectedtab' : '') +
                ' svelte-1najpus')))
      ) {
        attr_dev(h30, 'class', h30_class_value)
      }

      if (
        !current ||
        (dirty & /*offline*/ 1 &&
          h31_class_value !==
            (h31_class_value =
              '' +
              (null_to_empty(/*offline*/ ctx[0] ? 'selectedtab' : '') +
                ' svelte-1najpus')))
      ) {
        attr_dev(h31, 'class', h31_class_value)
      }

      if (!(/*offline*/ ctx[0])) {
        if (if_block0) {
          if_block0.p(ctx, dirty)

          if (dirty & /*offline*/ 1) {
            transition_in(if_block0, 1)
          }
        } else {
          if_block0 = create_if_block_1$1(ctx)
          if_block0.c()
          transition_in(if_block0, 1)
          if_block0.m(div2, t8)
        }
      } else if (if_block0) {
        group_outros()

        transition_out(if_block0, 1, 1, () => {
          if_block0 = null
        })

        check_outros()
      }

      if (/*offline*/ ctx[0]) {
        if (if_block1) {
          if_block1.p(ctx, dirty)

          if (dirty & /*offline*/ 1) {
            transition_in(if_block1, 1)
          }
        } else {
          if_block1 = create_if_block$1(ctx)
          if_block1.c()
          transition_in(if_block1, 1)
          if_block1.m(div2, null)
        }
      } else if (if_block1) {
        group_outros()

        transition_out(if_block1, 1, 1, () => {
          if_block1 = null
        })

        check_outros()
      }
    },
    i: function intro(local) {
      if (current) return
      transition_in(if_block0)
      transition_in(if_block1)
      current = true
    },
    o: function outro(local) {
      transition_out(if_block0)
      transition_out(if_block1)
      current = false
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div2)
      if (if_block0) if_block0.d()
      if (if_block1) if_block1.d()
      run_all(dispose)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_fragment$3.name,
    type: 'component',
    source: '',
    ctx,
  })

  return block
}

function instance$3($$self, $$props, $$invalidate) {
  let offline = false,
    onlineusers = 3,
    offlineusers = 2
  const writable_props = []

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$')
      console.warn(`<Chats> was created with unknown prop '${key}'`)
  })

  let { $$slots = {}, $$scope } = $$props
  validate_slots('Chats', $$slots, [])

  const click_handler = () => {
    $$invalidate(0, (offline = false))
  }

  const click_handler_1 = () => {
    $$invalidate(0, (offline = true))
  }

  $$self.$capture_state = () => ({
    ChatsTile,
    offline,
    onlineusers,
    offlineusers,
  })

  $$self.$inject_state = ($$props) => {
    if ('offline' in $$props) $$invalidate(0, (offline = $$props.offline))
    if ('onlineusers' in $$props)
      $$invalidate(1, (onlineusers = $$props.onlineusers))
    if ('offlineusers' in $$props)
      $$invalidate(2, (offlineusers = $$props.offlineusers))
  }

  if ($$props && '$$inject' in $$props) {
    $$self.$inject_state($$props.$$inject)
  }

  return [offline, onlineusers, offlineusers, click_handler, click_handler_1]
}

class Chats extends SvelteComponentDev {
  constructor(options) {
    super(options)
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {})

    dispatch_dev('SvelteRegisterComponent', {
      component: this,
      tagName: 'Chats',
      options,
      id: create_fragment$3.name,
    })
  }
}

/* src/routes/chat.svelte generated by Svelte v3.22.2 */
const file$4 = 'src/routes/chat.svelte'

function create_fragment$4(ctx) {
  let t0
  let t1
  let div
  let t2
  let t3
  let current
  const navbar = new Navbar({ props: { title: 'Chat' }, $$inline: true })

  const recentchats = new RecentChats({
    props: { title: 'Recent Chats' },
    $$inline: true,
  })

  const chats = new Chats({ $$inline: true })
  const tabbar = new Tabbar({ props: { location: 4 }, $$inline: true })

  const block = {
    c: function create() {
      t0 = space()
      create_component(navbar.$$.fragment)
      t1 = space()
      div = element('div')
      create_component(recentchats.$$.fragment)
      t2 = space()
      create_component(chats.$$.fragment)
      t3 = space()
      create_component(tabbar.$$.fragment)
      this.h()
    },
    l: function claim(nodes) {
      const head_nodes = query_selector_all(
        '[data-svelte="svelte-1800but"]',
        document.head
      )
      head_nodes.forEach(detach_dev)
      t0 = claim_space(nodes)
      claim_component(navbar.$$.fragment, nodes)
      t1 = claim_space(nodes)
      div = claim_element(nodes, 'DIV', { id: true, class: true })
      var div_nodes = children(div)
      claim_component(recentchats.$$.fragment, div_nodes)
      t2 = claim_space(div_nodes)
      claim_component(chats.$$.fragment, div_nodes)
      div_nodes.forEach(detach_dev)
      t3 = claim_space(nodes)
      claim_component(tabbar.$$.fragment, nodes)
      this.h()
    },
    h: function hydrate() {
      document.title = 'Chat :: Steam Mobile'
      attr_dev(div, 'id', 'chat')
      attr_dev(div, 'class', 'svelte-1dg3h8b')
      add_location(div, file$4, 12, 0, 324)
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor)
      mount_component(navbar, target, anchor)
      insert_dev(target, t1, anchor)
      insert_dev(target, div, anchor)
      mount_component(recentchats, div, null)
      append_dev(div, t2)
      mount_component(chats, div, null)
      insert_dev(target, t3, anchor)
      mount_component(tabbar, target, anchor)
      current = true
    },
    p: noop,
    i: function intro(local) {
      if (current) return
      transition_in(navbar.$$.fragment, local)
      transition_in(recentchats.$$.fragment, local)
      transition_in(chats.$$.fragment, local)
      transition_in(tabbar.$$.fragment, local)
      current = true
    },
    o: function outro(local) {
      transition_out(navbar.$$.fragment, local)
      transition_out(recentchats.$$.fragment, local)
      transition_out(chats.$$.fragment, local)
      transition_out(tabbar.$$.fragment, local)
      current = false
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t0)
      destroy_component(navbar, detaching)
      if (detaching) detach_dev(t1)
      if (detaching) detach_dev(div)
      destroy_component(recentchats)
      destroy_component(chats)
      if (detaching) detach_dev(t3)
      destroy_component(tabbar, detaching)
    },
  }

  dispatch_dev('SvelteRegisterBlock', {
    block,
    id: create_fragment$4.name,
    type: 'component',
    source: '',
    ctx,
  })

  return block
}

function instance$4($$self, $$props, $$invalidate) {
  const writable_props = []

  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$')
      console.warn(`<Chat> was created with unknown prop '${key}'`)
  })

  let { $$slots = {}, $$scope } = $$props
  validate_slots('Chat', $$slots, [])
  $$self.$capture_state = () => ({ Navbar, Tabbar, RecentChats, Chats })
  return []
}

class Chat extends SvelteComponentDev {
  constructor(options) {
    super(options)
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {})

    dispatch_dev('SvelteRegisterComponent', {
      component: this,
      tagName: 'Chat',
      options,
      id: create_fragment$4.name,
    })
  }
}

export default Chat
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhdC43YzE4NDA2ZC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUmVjZW50Q2hhdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9SZWNlbnRDaGF0cy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9DaGF0c1RpbGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQ2hhdHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9jaGF0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGltYWdlLCBzdGF0dXMsIG5hbWVcbjwvc2NyaXB0PlxuXG48IS0tIHN0YXR1cyBjb2Rlc1xuXHQxID0gaW5nYW1lLCAyIG9ubGluZSwgMyBvZmZsaW5lXG5zdGF0dXMgY29kZXMgLS0+XG5cbjxkaXZcbiAgaWQ9XCJpbWFnZWhvbGRlclwiXG4gIGNsYXNzPVwie3N0YXR1cyA9PT0gMSA/ICdzdGF0dXMgaW5nYW1lJyA6ICcnfXtzdGF0dXMgPT09IDIgPyAnc3RhdHVzIG9ubGluZScgOiAnJ317c3RhdHVzID09PSAzID8gJ3N0YXR1cyBvZmZsaW5lJyA6ICcnfVwiXG4gIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKHtpbWFnZX0pO1wiPlxuICA8ZGl2XG4gICAgaWQ9XCJuYW1lXCJcbiAgICBjbGFzcz1cIntzdGF0dXMgPT09IDEgPyAnbmFtZS0taW5nYW1lJyA6ICcnfXtzdGF0dXMgPT09IDIgPyAnbmFtZS0tb25saW5lJyA6ICcnfXtzdGF0dXMgPT09IDMgPyAnc3RhdHVzIG9mZmxpbmUnIDogJyd9XCI+XG4gICAge25hbWV9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgI2ltYWdlaG9sZGVyIHtcbiAgICBoZWlnaHQ6IDUwcHg7XG4gICAgd2lkdGg6IDUwcHg7XG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgbWFyZ2luLXJpZ2h0OiAyMHB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gICNuYW1lIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAtMjJweDtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgd2lkdGg6IDUwcHg7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICB9XG5cbiAgLm5hbWUtLWluZ2FtZSB7XG4gICAgY29sb3I6ICM1YzdlMTA7XG4gIH1cblxuICAubmFtZS0tb25saW5lIHtcbiAgICBjb2xvcjogIzU3Y2JkZTtcbiAgfVxuXG4gIC5uYW1lLS1vZmZsaW5lIHtcbiAgICBjb2xvcjogI2EwYTBhMDtcbiAgfVxuXG4gIC5zdGF0dXM6OmFmdGVyIHtcbiAgICBjb250ZW50OiAnJztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDUwcHg7XG4gICAgaGVpZ2h0OiAycHg7XG4gICAgYm90dG9tOiAtMjhweDtcbiAgfVxuXG4gIC5pbmdhbWU6OmFmdGVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWM3ZTEwO1xuICB9XG5cbiAgLm9ubGluZTo6YWZ0ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1N2NiZGU7XG4gIH1cblxuICAub2ZmbGluZSB7XG4gICAgb3BhY2l0eTogMC42O1xuICB9XG5cbiAgLm9mZmxpbmU6OmFmdGVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYTBhMGEwO1xuICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFJlY2VudENoYXQgZnJvbSAnLi9SZWNlbnRDaGF0LnN2ZWx0ZSdcblxuICBleHBvcnQgbGV0IHRpdGxlXG48L3NjcmlwdD5cblxuPCEtLSBzdGF0dXMgY29kZXNcblx0MSA9IGluZ2FtZSwgMiBvbmxpbmUsIDMgb2ZmbGluZVxuc3RhdHVzIGNvZGVzIC0tPlxuXG48ZGl2IGlkPVwiY2FyZFwiPlxuICA8aDM+UmVjZW50IENoYXRzPC9oMz5cbiAgPGRpdiBpZD1cImxpc3RcIj5cbiAgICA8UmVjZW50Q2hhdCBpbWFnZT1cImZyaWVuZG9uZS5wbmdcIiBzdGF0dXM9ezF9IG5hbWU9XCJiaW5nb3RoZXNsYXllZXJcIiAvPlxuICAgIDxSZWNlbnRDaGF0IGltYWdlPVwiZnJpZW5kdHdvLnBuZ1wiIHN0YXR1cz17Mn0gbmFtZT1cImZhdGhlcmRlYXRoXCIgLz5cbiAgICA8UmVjZW50Q2hhdCBpbWFnZT1cImZyaWVuZHRocmVlLnBuZ1wiIHN0YXR1cz17Mn0gbmFtZT1cInB5c2Nob3RoZXJhcGlzdFwiIC8+XG4gICAgPFJlY2VudENoYXQgaW1hZ2U9XCJmcmllbmRmb3VyLnBuZ1wiIHN0YXR1cz17M30gbmFtZT1cImZhdGZhdGhlcjY0XCIgLz5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICBoMyB7XG4gICAgY29sb3I6ICNhN2Q2ZjA7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICBwYWRkaW5nOiAwcHggMzBweDtcbiAgfVxuXG4gICNsaXN0IHtcbiAgICBtYXJnaW46IDE0cHggMHB4O1xuICAgIHBhZGRpbmctbGVmdDogMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAjdGFicyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgfVxuXG4gICNjYXJkIHtcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgIHBhZGRpbmctdG9wOiAzMHB4O1xuICAgIHRvcDogNjBweDtcbiAgICBoZWlnaHQ6IDEyMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuICAgIHotaW5kZXg6IDk5OTtcbiAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgdXNlck5hbWUsIGdhbWVOYW1lLCB1c2VySW1hZ2UsIHN0YXR1cywgdGltZXN0YW1wLCBvZmZsaW5lXG48L3NjcmlwdD5cblxuPCEtLSBzdGF0dXMgY29kZXNcblx0MSA9IGluZ2FtZSwgMiBvbmxpbmUsIDMgb2ZmbGluZVxuc3RhdHVzIGNvZGVzIC0tPlxuXG48bGlcbiAgY2xhc3M9XCJ7c3RhdHVzID09PSAxID8gJ3N0YXR1cyBpbmdhbWUnIDogJyd9e3N0YXR1cyA9PT0gMiA/ICdzdGF0dXMgb25saW5lJyA6ICcnfXtzdGF0dXMgPT09IDMgPyAnc3RhdHVzIG9mZmxpbmUgc3RhdHVzb2ZmbGluZScgOiAnJ31cIj5cbiAgPGRpdiBpZD1cInVzZXJpbWFnZVwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoe3VzZXJJbWFnZX0pO1wiIC8+XG4gIDxkaXYgaWQ9XCJpbmZvXCI+XG4gICAgPGRpdiBpZD1cInVzZXJuYW1lXCIgY2xhc3M9eyFnYW1lTmFtZSA/ICdvbmxpbmV1c2VybmFtZScgOiAnJ30+XG4gICAgICB7dXNlck5hbWV9XG4gICAgPC9kaXY+XG4gICAgeyNpZiAhb2ZmbGluZX1cbiAgICAgIDxkaXYgaWQ9XCJ1c2VyZ2FtZVwiIGNsYXNzPXshZ2FtZU5hbWUgPyAnb25saW5lZ2FtZW5hbWUnIDogJyd9PlxuICAgICAgICB7IWdhbWVOYW1lID8gJ09ubGluZScgOiBnYW1lTmFtZX1cbiAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZSBpZiBvZmZsaW5lfVxuICAgICAgPGRpdiBpZD1cImxhc3RvbmxpbmVcIj5MYXN0IG9ubGluZSB7dGltZXN0YW1wfSBkYXlzIGFnbzwvZGl2PlxuICAgIHsvaWZ9XG4gIDwvZGl2PlxuPC9saT5cblxuPHN0eWxlPlxuICBsaSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDE0cHggMHB4O1xuICB9XG5cbiAgI3VzZXJuYW1lIHtcbiAgICBjb2xvcjogIzVjN2UxMDtcbiAgfVxuXG4gICN1c2VyZ2FtZSxcbiAgI2xhc3RvbmxpbmUge1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgfVxuXG4gICN1c2VyZ2FtZSB7XG4gICAgY29sb3I6ICM1YzdlMTA7XG4gIH1cblxuICAjbGFzdG9ubGluZSB7XG4gICAgY29sb3I6ICM5MDk5YTE7XG4gIH1cblxuICAub25saW5ldXNlcm5hbWUge1xuICAgIGNvbG9yOiAjNmZiZmVjICFpbXBvcnRhbnQ7XG4gICAgb3BhY2l0eTogMC44O1xuICB9XG5cbiAgLm9ubGluZWdhbWVuYW1lIHtcbiAgICBjb2xvcjogI2E3ZDZmMCAhaW1wb3J0YW50O1xuICAgIG9wYWNpdHk6IDAuODtcbiAgfVxuXG4gIC5vZmZsaW5lIHtcbiAgICBjb2xvcjogI2VhZWFlYSAhaW1wb3J0YW50O1xuICB9XG5cbiAgI3VzZXJpbWFnZSB7XG4gICAgd2lkdGg6IDQwcHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG5cbiAgLnN0YXR1czo6YWZ0ZXIge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogM3B4O1xuICAgIGhlaWdodDogNDBweDtcbiAgICBtYXJnaW4tbGVmdDogNDRweDtcbiAgfVxuXG4gIC5pbmdhbWU6OmFmdGVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWM3ZTEwO1xuICB9XG5cbiAgLm9ubGluZTo6YWZ0ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM1N2NiZGU7XG4gIH1cblxuICAub2ZmbGluZTo6YWZ0ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM5MDk5YTE7XG4gIH1cblxuICAjaW5mbyB7XG4gICAgbWFyZ2luLWxlZnQ6IDE1cHg7XG4gIH1cblxuICAuc3RhdHVzb2ZmbGluZSB7XG4gICAgb3BhY2l0eTogMC42ICFpbXBvcnRhbnQ7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgQ2hhdHNUaWxlIGZyb20gJy4vQ2hhdHNUaWxlLnN2ZWx0ZSdcblxuICBsZXQgb2ZmbGluZSA9IGZhbHNlLFxuICAgIG9ubGluZXVzZXJzID0gMyxcbiAgICBvZmZsaW5ldXNlcnMgPSAyXG48L3NjcmlwdD5cblxuPCEtLSBzdGF0dXMgY29kZXNcblx0MSA9IGluZ2FtZSwgMiBvbmxpbmUsIDMgb2ZmbGluZVxuc3RhdHVzIGNvZGVzIC0tPlxuXG48ZGl2IGlkPVwiY2FyZFwiPlxuICA8ZGl2IGlkPVwidGFic2NvbnRhaW5lclwiPlxuICAgIDxkaXYgaWQ9XCJ0YWJzXCI+XG4gICAgICA8aDNcbiAgICAgICAgY2xhc3M9eyFvZmZsaW5lID8gJ3NlbGVjdGVkdGFiJyA6ICcnfVxuICAgICAgICBvbjpjbGljaz17KCkgPT4ge1xuICAgICAgICAgIG9mZmxpbmUgPSBmYWxzZVxuICAgICAgICB9fT5cbiAgICAgICAgT25saW5lICh7b25saW5ldXNlcnN9KVxuICAgICAgPC9oMz5cbiAgICAgIDxoM1xuICAgICAgICBjbGFzcz17b2ZmbGluZSA/ICdzZWxlY3RlZHRhYicgOiAnJ31cbiAgICAgICAgb246Y2xpY2s9eygpID0+IHtcbiAgICAgICAgICBvZmZsaW5lID0gdHJ1ZVxuICAgICAgICB9fT5cbiAgICAgICAgT2ZmbGluZSAoe29mZmxpbmV1c2Vyc30pXG4gICAgICA8L2gzPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgeyNpZiAhb2ZmbGluZX1cbiAgICA8dWw+XG4gICAgICA8Q2hhdHNUaWxlXG4gICAgICAgIHVzZXJOYW1lPVwiYmluZ290aGVzbGF5ZXJcIlxuICAgICAgICBnYW1lTmFtZT1cIkRhbmsgU291bHMgM1wiXG4gICAgICAgIHVzZXJJbWFnZT1cImZyaWVuZG9uZS5wbmdcIlxuICAgICAgICBzdGF0dXM9ezF9XG4gICAgICAgIHtvZmZsaW5lfSAvPlxuICAgICAgPENoYXRzVGlsZVxuICAgICAgICB1c2VyTmFtZT1cImZhdGhlcmRlYXRoXCJcbiAgICAgICAgdXNlckltYWdlPVwiZnJpZW5kdHdvLnBuZ1wiXG4gICAgICAgIHN0YXR1cz17Mn1cbiAgICAgICAge29mZmxpbmV9IC8+XG4gICAgICA8Q2hhdHNUaWxlXG4gICAgICAgIHVzZXJOYW1lPVwicHlzY2hvdGhlcmFwaXN0XCJcbiAgICAgICAgdXNlckltYWdlPVwiZnJpZW5kdGhyZWUucG5nXCJcbiAgICAgICAgc3RhdHVzPXsyfVxuICAgICAgICB7b2ZmbGluZX0gLz5cbiAgICA8L3VsPlxuICB7L2lmfVxuICB7I2lmIG9mZmxpbmV9XG4gICAgPHVsPlxuICAgICAgPENoYXRzVGlsZVxuICAgICAgICB1c2VyTmFtZT1cImZhdGZhdGhlcjY0XCJcbiAgICAgICAgZ2FtZU5hbWU9XCJHcmFuZCBUaGVmdCBBdXRvOiBTYW4gQW5kcmVhc1wiXG4gICAgICAgIHVzZXJJbWFnZT1cImZyaWVuZGZvdXIucG5nXCJcbiAgICAgICAgc3RhdHVzPXszfVxuICAgICAgICB7b2ZmbGluZX1cbiAgICAgICAgdGltZXN0YW1wPVwiNlwiIC8+XG4gICAgICA8Q2hhdHNUaWxlXG4gICAgICAgIHVzZXJOYW1lPVwiZGluZ2RvbmdkaW5nXCJcbiAgICAgICAgZ2FtZU5hbWU9XCJHcmFuZCBUaGVmdCBBdXRvOiBTYW4gQW5kcmVhc1wiXG4gICAgICAgIHVzZXJJbWFnZT1cInByb2ZpbGVwaWN0dXJlLmpwZ1wiXG4gICAgICAgIHN0YXR1cz17M31cbiAgICAgICAge29mZmxpbmV9XG4gICAgICAgIHRpbWVzdGFtcD1cIjEyXCIgLz5cbiAgICA8L3VsPlxuICB7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgI3RhYnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcGFkZGluZzogMHB4IDMwcHg7XG4gICAgd2lkdGg6IDE1MHB4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgaDMge1xuICAgIGNvbG9yOiAjOTA5OWExO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBmb250LXNpemU6IDEycHg7XG4gIH1cblxuICB1bCB7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBwYWRkaW5nOiAwcHggMzBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGYwYjIwO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtYXJnaW46IDA7XG4gIH1cblxuICAjY2FyZCB7XG4gICAgbWFyZ2luLXRvcDogMzBweDtcbiAgfVxuXG4gIC5zZWxlY3RlZHRhYiB7XG4gICAgY29sb3I6ICNhN2Q2ZjA7XG4gIH1cblxuICAjdGFic2NvbnRhaW5lciB7XG4gICAgcG9zaXRpb246IHN0aWNreTtcbiAgICBwYWRkaW5nLXRvcDogMzBweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTBweDtcbiAgICB0b3A6IDIwMHB4O1xuICAgIHotaW5kZXg6IDk5ODtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbiAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBOYXZiYXIgZnJvbSAnLi4vY29tcG9uZW50cy9OYXZiYXIuc3ZlbHRlJ1xuICBpbXBvcnQgVGFiYmFyIGZyb20gJy4uL2NvbXBvbmVudHMvVGFiYmFyLnN2ZWx0ZSdcbiAgaW1wb3J0IFJlY2VudENoYXRzIGZyb20gJy4uL2NvbXBvbmVudHMvUmVjZW50Q2hhdHMuc3ZlbHRlJ1xuICBpbXBvcnQgQ2hhdHMgZnJvbSAnLi4vY29tcG9uZW50cy9DaGF0cy5zdmVsdGUnXG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuICA8dGl0bGU+Q2hhdCA6OiBTdGVhbSBNb2JpbGU8L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPE5hdmJhciB0aXRsZT1cIkNoYXRcIiAvPlxuPGRpdiBpZD1cImNoYXRcIj5cbiAgPCEtLSBOZWVkIHRvIG1ha2UgeC1zY3JvbGxhYmxlIGFuZCBhZGQgbm90aWZpY2F0aW9uIGJ1YmJsZS0tPlxuICA8UmVjZW50Q2hhdHMgdGl0bGU9XCJSZWNlbnQgQ2hhdHNcIiAvPlxuICA8IS0tIE5lZWQgdG8gbWFrZSB4LXNjcm9sbGFibGUgYW5kIGFkZCBub3RpZmljYXRpb24gYnViYmxlLS0+XG4gIDxDaGF0cyAvPlxuPC9kaXY+XG48VGFiYmFyIGxvY2F0aW9uPXs0fSAvPlxuXG48c3R5bGU+XG4gICNjaGF0IHtcbiAgICBwYWRkaW5nOiA0MHB4IDBweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICAgIHBhZGRpbmctYm90dG9tOiA4MHB4O1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFlSyxHQUFJOzs7Ozs7Ozt1Q0FBSixHQUFJOzs7Ozs7O2dFQURHLEdBQU0sUUFBSyxDQUFDLEdBQUcsY0FBYyxHQUFHLEVBQUUsZ0JBQUUsR0FBTSxRQUFLLENBQUMsR0FBRyxjQUFjLEdBQUcsRUFBRSxnQkFBRSxHQUFNLFFBQUssQ0FBQyxHQUFHLGdCQUFnQixHQUFHLEVBQUU7OztnRUFKOUcsR0FBTSxRQUFLLENBQUMsR0FBRyxlQUFlLEdBQUcsRUFBRSxnQkFBRSxHQUFNLFFBQUssQ0FBQyxHQUFHLGVBQWUsR0FBRyxFQUFFLGdCQUFFLEdBQU0sUUFBSyxDQUFDLEdBQUcsZ0JBQWdCLEdBQUcsRUFBRTswREFDeEYsR0FBSzs7Ozs7Ozs7O29EQUloQyxHQUFJOzswRkFERyxHQUFNLFFBQUssQ0FBQyxHQUFHLGNBQWMsR0FBRyxFQUFFLGdCQUFFLEdBQU0sUUFBSyxDQUFDLEdBQUcsY0FBYyxHQUFHLEVBQUUsZ0JBQUUsR0FBTSxRQUFLLENBQUMsR0FBRyxnQkFBZ0IsR0FBRyxFQUFFOzs7OzBGQUo5RyxHQUFNLFFBQUssQ0FBQyxHQUFHLGVB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
