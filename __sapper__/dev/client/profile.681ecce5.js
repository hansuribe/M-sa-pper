import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, a as space, t as text, c as claim_element, b as children, f as detach_dev, g as claim_space, h as claim_text, j as attr_dev, l as add_location, k as set_style, m as insert_dev, n as append_dev, o as set_data_dev, p as noop, K as globals, q as create_component, u as claim_component, w as mount_component, x as transition_in, y as transition_out, z as destroy_component, L as group_outros, M as check_outros, B as create_slot, N as getContext, O as validate_store, P as component_subscribe, J as writable, Q as derived, R as onMount, T as setContext, H as get_slot_context, I as get_slot_changes, U as onDestroy, V as assign, W as exclude_internal_props, X as empty, Y as get_spread_update, Z as get_spread_object, C as createEventDispatcher, _ as set_attributes, F as listen_dev, r as query_selector_all } from './client.17b05aa1.js';
import { N as Navbar, T as Tabbar } from './Tabbar.6a30fc0d.js';
import { u as username } from './stores.9f93f434.js';

/* src/components/ProfileHeader.svelte generated by Svelte v3.22.2 */

const file = "src/components/ProfileHeader.svelte";

function create_fragment(ctx) {
	let main;
	let div8;
	let div0;
	let t0;
	let div5;
	let div4;
	let div1;
	let t1;
	let div2;
	let h3;
	let t2;
	let t3;
	let h5;
	let t4;
	let t5;
	let div3;
	let t6;
	let t7;
	let div6;
	let t8;
	let div7;

	const block = {
		c: function create() {
			main = element("main");
			div8 = element("div");
			div0 = element("div");
			t0 = space();
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			h3 = element("h3");
			t2 = text(/*alias*/ ctx[0]);
			t3 = space();
			h5 = element("h5");
			t4 = text(/*name*/ ctx[1]);
			t5 = space();
			div3 = element("div");
			t6 = text(/*level*/ ctx[3]);
			t7 = space();
			div6 = element("div");
			t8 = space();
			div7 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			div8 = claim_element(main_nodes, "DIV", { id: true, class: true });
			var div8_nodes = children(div8);
			div0 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div8_nodes);
			div5 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			div1 = claim_element(div4_nodes, "DIV", { id: true, style: true, class: true });
			children(div1).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*alias*/ ctx[0]);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			h5 = claim_element(div2_nodes, "H5", { class: true });
			var h5_nodes = children(h5);
			t4 = claim_text(h5_nodes, /*name*/ ctx[1]);
			h5_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t5 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			t6 = claim_text(div3_nodes, /*level*/ ctx[3]);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t7 = claim_space(div8_nodes);
			div6 = claim_element(div8_nodes, "DIV", { id: true, style: true, class: true });
			children(div6).forEach(detach_dev);
			t8 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div7).forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "id", "layer1");
			attr_dev(div0, "class", "svelte-15zeztu");
			add_location(div0, file, 6, 4, 97);
			attr_dev(div1, "id", "profilepicture");
			set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			attr_dev(div1, "class", "svelte-15zeztu");
			add_location(div1, file, 9, 8, 180);
			attr_dev(h3, "class", "svelte-15zeztu");
			add_location(h3, file, 13, 10, 315);
			attr_dev(h5, "class", "svelte-15zeztu");
			add_location(h5, file, 14, 10, 342);
			attr_dev(div2, "id", "userinfo");
			attr_dev(div2, "class", "svelte-15zeztu");
			add_location(div2, file, 12, 8, 285);
			attr_dev(div3, "id", "level");
			attr_dev(div3, "class", "svelte-15zeztu");
			add_location(div3, file, 17, 8, 443);
			attr_dev(div4, "id", "content");
			attr_dev(div4, "class", "svelte-15zeztu");
			add_location(div4, file, 8, 6, 153);
			attr_dev(div5, "id", "contentwrapper");
			attr_dev(div5, "class", "svelte-15zeztu");
			add_location(div5, file, 7, 4, 121);
			attr_dev(div6, "id", "layer2");
			set_style(div6, "background-image", "url(gta.jpg)");
			attr_dev(div6, "class", "svelte-15zeztu");
			add_location(div6, file, 21, 4, 563);
			attr_dev(div7, "id", "layer3");
			attr_dev(div7, "class", "svelte-15zeztu");
			add_location(div7, file, 22, 4, 627);
			attr_dev(div8, "id", "head");
			attr_dev(div8, "class", "svelte-15zeztu");
			add_location(div8, file, 5, 2, 77);
			add_location(main, file, 4, 0, 68);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div8);
			append_dev(div8, div0);
			append_dev(div8, t0);
			append_dev(div8, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div4, t1);
			append_dev(div4, div2);
			append_dev(div2, h3);
			append_dev(h3, t2);
			append_dev(div2, t3);
			append_dev(div2, h5);
			append_dev(h5, t4);
			append_dev(div4, t5);
			append_dev(div4, div3);
			append_dev(div3, t6);
			append_dev(div8, t7);
			append_dev(div8, div6);
			append_dev(div8, t8);
			append_dev(div8, div7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*profilepicture*/ 4) {
				set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			}

			if (dirty & /*alias*/ 1) set_data_dev(t2, /*alias*/ ctx[0]);
			if (dirty & /*name*/ 2) set_data_dev(t4, /*name*/ ctx[1]);
			if (dirty & /*level*/ 8) set_data_dev(t6, /*level*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { alias } = $$props,
		{ name } = $$props,
		{ profilepicture } = $$props,
		{ level } = $$props;

	const writable_props = ["alias", "name", "profilepicture", "level"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProfileHeader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ProfileHeader", $$slots, []);

	$$self.$set = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	$$self.$capture_state = () => ({ alias, name, profilepicture, level });

	$$self.$inject_state = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [alias, name, profilepicture, level];
}

class ProfileHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			alias: 0,
			name: 1,
			profilepicture: 2,
			level: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProfileHeader",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*alias*/ ctx[0] === undefined && !("alias" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'alias'");
		}

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'name'");
		}

		if (/*profilepicture*/ ctx[2] === undefined && !("profilepicture" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'profilepicture'");
		}

		if (/*level*/ ctx[3] === undefined && !("level" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'level'");
		}
	}

	get alias() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alias(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get profilepicture() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set profilepicture(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/AboutMeTile.svelte generated by Svelte v3.22.2 */

const file$1 = "src/components/AboutMeTile.svelte";

function create_fragment$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, "Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", "aboutme");
			attr_dev(div, "class", "svelte-r6lw0a");
			add_location(div, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AboutMeTile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AboutMeTile", $$slots, []);
	return [];
}

class AboutMeTile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AboutMeTile",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/MainBadge.svelte generated by Svelte v3.22.2 */

const file$2 = "src/components/MainBadge.svelte";

function create_fragment$2(ctx) {
	let div1;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let h2;
	let t1;
	let t2;
	let h4;
	let t3;

	const block = {
		c: function create() {
			div1 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			h2 = element("h2");
			t1 = text("Years of Service");
			t2 = space();
			h4 = element("h4");
			t3 = text("250 XP");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			img = claim_element(div1_nodes, "IMG", { src: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Years of Service");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			h4 = claim_element(div0_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t3 = claim_text(h4_nodes, "250 XP");
			h4_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "https://steamcommunity-a.akamaihd.net/public/images/badges/02_years/steamyears5_54.png")) attr_dev(img, "src", img_src_value);
			add_location(img, file$2, 1, 2, 23);
			attr_dev(h2, "class", "svelte-pl8w79");
			add_location(h2, file$2, 4, 4, 159);
			attr_dev(h4, "class", "svelte-pl8w79");
			add_location(h4, file$2, 5, 4, 189);
			attr_dev(div0, "id", "badgemaininfo");
			attr_dev(div0, "class", "svelte-pl8w79");
			add_location(div0, file$2, 3, 2, 130);
			attr_dev(div1, "id", "badgemain");
			attr_dev(div1, "class", "svelte-pl8w79");
			add_location(div1, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h2);
			append_dev(h2, t1);
			append_dev(div0, t2);
			append_dev(div0, h4);
			append_dev(h4, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MainBadge> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MainBadge", $$slots, []);
	return [];
}

class MainBadge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MainBadge",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/components/Showcase.svelte generated by Svelte v3.22.2 */

const { console: console_1 } = globals;
const file$3 = "src/components/Showcase.svelte";

function create_fragment$3(ctx) {
	let div;
	let img0;
	let img0_src_value;
	let t0;
	let img1;
	let img1_src_value;
	let t1;
	let img2;
	let img2_src_value;
	let t2;
	let img3;
	let img3_src_value;
	let t3;
	let img4;
	let img4_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img0 = element("img");
			t0 = space();
			img1 = element("img");
			t1 = space();
			img2 = element("img");
			t2 = space();
			img3 = element("img");
			t3 = space();
			img4 = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			img0 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t0 = claim_space(div_nodes);
			img1 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t1 = claim_space(div_nodes);
			img2 = claim_element(div_nodes, "IMG", { src: true, class: true });
			t2 = claim_space(div_nodes);
			img3 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t3 = claim_space(div_nodes);
			img4 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img0.src !== (img0_src_value = showcase[0].link)) attr_dev(img0, "src", img0_src_value);
			set_style(img0, "height", "32px");
			attr_dev(img0, "class", "svelte-soube2");
			add_location(img0, file$3, 6, 2, 120);
			if (img1.src !== (img1_src_value = showcase[1].link)) attr_dev(img1, "src", img1_src_value);
			set_style(img1, "height", "32px");
			attr_dev(img1, "class", "svelte-soube2");
			add_location(img1, file$3, 7, 2, 177);
			if (img2.src !== (img2_src_value = showcase[2].link)) attr_dev(img2, "src", img2_src_value);
			attr_dev(img2, "class", "svelte-soube2");
			add_location(img2, file$3, 8, 2, 234);
			if (img3.src !== (img3_src_value = showcase[3].link)) attr_dev(img3, "src", img3_src_value);
			set_style(img3, "height", "36px");
			attr_dev(img3, "class", "svelte-soube2");
			add_location(img3, file$3, 9, 2, 269);
			if (img4.src !== (img4_src_value = showcase[4].link)) attr_dev(img4, "src", img4_src_value);
			set_style(img4, "height", "38px");
			attr_dev(img4, "class", "svelte-soube2");
			add_location(img4, file$3, 10, 2, 326);
			attr_dev(div, "id", "badgeshowcase");
			attr_dev(div, "class", "svelte-soube2");
			add_location(div, file$3, 5, 0, 93);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img0);
			append_dev(div, t0);
			append_dev(div, img1);
			append_dev(div, t1);
			append_dev(div, img2);
			append_dev(div, t2);
			append_dev(div, img3);
			append_dev(div, t3);
			append_dev(div, img4);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { images } = $$props;
	let showcaseimages = images;
	console.log(images);
	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Showcase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Showcase", $$slots, []);

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	$$self.$capture_state = () => ({ images, showcaseimages });

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
		if ("showcaseimages" in $$props) showcaseimages = $$props.showcaseimages;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [images];
}

class Showcase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { images: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Showcase",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*images*/ ctx[0] === undefined && !("images" in props)) {
			console_1.warn("<Showcase> was created without expected prop 'images'");
		}
	}

	get images() {
		throw new Error("<Showcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<Showcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/ProfileTile.svelte generated by Svelte v3.22.2 */
const file$4 = "src/components/ProfileTile.svelte";

// (13:2) {#if name === "Badges"}
function create_if_block(ctx) {
	let current;
	const mainbadge = new MainBadge({ $$inline: true });

	const block = {
		c: function create() {
			create_component(mainbadge.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(mainbadge.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(mainbadge, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(mainbadge.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mainbadge.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(mainbadge, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(13:2) {#if name === \\\"Badges\\\"}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;
	let t3;
	let t4;
	let current;
	let if_block = /*name*/ ctx[0] === "Badges" && create_if_block(ctx);

	const showcase = new Showcase({
			props: { images: /*images*/ ctx[3] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text(/*name*/ ctx[0]);
			t1 = space();
			h2 = element("h2");
			t2 = text(/*number*/ ctx[1]);
			t3 = space();
			if (if_block) if_block.c();
			t4 = space();
			create_component(showcase.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, /*name*/ ctx[0]);
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, /*number*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			claim_component(showcase.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$4, 9, 4, 182);
			attr_dev(h2, "class", "svelte-zaz1k8");
			add_location(h2, file$4, 10, 4, 202);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-zaz1k8");
			add_location(div0, file$4, 8, 2, 161);
			attr_dev(div1, "id", /*id*/ ctx[2]);
			attr_dev(div1, "class", "svelte-zaz1k8");
			add_location(div1, file$4, 7, 0, 148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
			append_dev(div1, t3);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t4);
			mount_component(showcase, div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 1) set_data_dev(t0, /*name*/ ctx[0]);
			if (!current || dirty & /*number*/ 2) set_data_dev(t2, /*number*/ ctx[1]);

			if (/*name*/ ctx[0] === "Badges") {
				if (if_block) {
					if (dirty & /*name*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t4);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const showcase_changes = {};
			if (dirty & /*images*/ 8) showcase_changes.images = /*images*/ ctx[3];
			showcase.$set(showcase_changes);

			if (!current || dirty & /*id*/ 4) {
				attr_dev(div1, "id", /*id*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(showcase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(showcase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_component(showcase);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { name } = $$props,
		{ number } = $$props,
		{ id } = $$props,
		{ images } = $$props;

	const writable_props = ["name", "number", "id", "images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProfileTile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ProfileTile", $$slots, []);

	$$self.$set = $$props => {
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("number" in $$props) $$invalidate(1, number = $$props.number);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("images" in $$props) $$invalidate(3, images = $$props.images);
	};

	$$self.$capture_state = () => ({
		MainBadge,
		Showcase,
		name,
		number,
		id,
		images
	});

	$$self.$inject_state = $$props => {
		if ("name" in $$props) $$invalidate(0, name = $$props.name);
		if ("number" in $$props) $$invalidate(1, number = $$props.number);
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("images" in $$props) $$invalidate(3, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [name, number, id, images];
}

class ProfileTile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { name: 0, number: 1, id: 2, images: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProfileTile",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
			console.warn("<ProfileTile> was created without expected prop 'name'");
		}

		if (/*number*/ ctx[1] === undefined && !("number" in props)) {
			console.warn("<ProfileTile> was created without expected prop 'number'");
		}

		if (/*id*/ ctx[2] === undefined && !("id" in props)) {
			console.warn("<ProfileTile> was created without expected prop 'id'");
		}

		if (/*images*/ ctx[3] === undefined && !("images" in props)) {
			console.warn("<ProfileTile> was created without expected prop 'images'");
		}
	}

	get name() {
		throw new Error("<ProfileTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<ProfileTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get number() {
		throw new Error("<ProfileTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set number(value) {
		throw new Error("<ProfileTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<ProfileTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<ProfileTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get images() {
		throw new Error("<ProfileTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<ProfileTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/About.svelte generated by Svelte v3.22.2 */
const file$5 = "src/components/About.svelte";

function create_fragment$5(ctx) {
	let main;
	let t0;
	let t1;
	let t2;
	let current;
	const aboutmetile = new AboutMeTile({ $$inline: true });

	const profiletile0 = new ProfileTile({
			props: {
				id: "badges",
				name: "Badges",
				number: "14"
			},
			$$inline: true
		});

	const profiletile1 = new ProfileTile({
			props: {
				id: "friends",
				name: "Friends",
				number: "28"
			},
			$$inline: true
		});

	const profiletile2 = new ProfileTile({
			props: {
				id: "groups",
				name: "Groups",
				number: "8",
				images: [
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/37_summer2019/level25_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/730/54e40b9e2288fbab8bd4c6537b0325d405c7e1b0.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/28_springcleaning2018/bronze_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/762800/d467ec8eaed4643c47fbed43ed781daef2525963.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/27_steamawardnominations/level04_80.png"
					}
				]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			main = element("main");
			create_component(aboutmetile.$$.fragment);
			t0 = space();
			create_component(profiletile0.$$.fragment);
			t1 = space();
			create_component(profiletile1.$$.fragment);
			t2 = space();
			create_component(profiletile2.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(aboutmetile.$$.fragment, main_nodes);
			t0 = claim_space(main_nodes);
			claim_component(profiletile0.$$.fragment, main_nodes);
			t1 = claim_space(main_nodes);
			claim_component(profiletile1.$$.fragment, main_nodes);
			t2 = claim_space(main_nodes);
			claim_component(profiletile2.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "svelte-p06umt");
			add_location(main, file$5, 7, 0, 205);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(aboutmetile, main, null);
			append_dev(main, t0);
			mount_component(profiletile0, main, null);
			append_dev(main, t1);
			mount_component(profiletile1, main, null);
			append_dev(main, t2);
			mount_component(profiletile2, main, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(aboutmetile.$$.fragment, local);
			transition_in(profiletile0.$$.fragment, local);
			transition_in(profiletile1.$$.fragment, local);
			transition_in(profiletile2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(aboutmetile.$$.fragment, local);
			transition_out(profiletile0.$$.fragment, local);
			transition_out(profiletile1.$$.fragment, local);
			transition_out(profiletile2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(aboutmetile);
			destroy_component(profiletile0);
			destroy_component(profiletile1);
			destroy_component(profiletile2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("About", $$slots, []);
	$$self.$capture_state = () => ({ AboutMeTile, ProfileTile });
	return [];
}

class About extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: create_fragment$5.name
		});
	}
}

const LOCATION = {};
const ROUTER = {};

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

function getLocation(source) {
  return {
    ...source.location,
    state: source.history.state,
    key: (source.history.state && source.history.state.key) || "initial"
  };
}

function createHistory(source, options) {
  const listeners = [];
  let location = getLocation(source);

  return {
    get location() {
      return location;
    },

    listen(listener) {
      listeners.push(listener);

      const popstateListener = () => {
        location = getLocation(source);
        listener({ location, action: "POP" });
      };

      source.addEventListener("popstate", popstateListener);

      return () => {
        source.removeEventListener("popstate", popstateListener);

        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    },

    navigate(to, { state, replace = false } = {}) {
      state = { ...state, key: Date.now() + "" };
      // try...catch iOS Safari limits to 100 pushState calls
      try {
        if (replace) {
          source.history.replaceState(state, null, to);
        } else {
          source.history.pushState(state, null, to);
        }
      } catch (e) {
        source.location[replace ? "replace" : "assign"](to);
      }

      location = getLocation(source);
      listeners.forEach(listener => listener({ location, action: "PUSH" }));
    }
  };
}

// Stores history entries in memory for testing or other platforms like Native
function createMemorySource(initialPathname = "/") {
  let index = 0;
  const stack = [{ pathname: initialPathname, search: "" }];
  const states = [];

  return {
    get location() {
      return stack[index];
    },
    addEventListener(name, fn) {},
    removeEventListener(name, fn) {},
    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        index++;
        stack.push({ pathname, search });
        states.push(state);
      },
      replaceState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        stack[index] = { pathname, search };
        states[index] = state;
      }
    }
  };
}

// Global history uses window.history as the source if available,
// otherwise a memory history
const canUseDOM = Boolean(
  typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
);
const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
const { navigate } = globalHistory;

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

const paramRe = /^:(.+)/;

const SEGMENT_POINTS = 4;
const STATIC_POINTS = 3;
const DYNAMIC_POINTS = 2;
const SPLAT_PENALTY = 1;
const ROOT_POINTS = 1;

/**
 * Check if `string` starts with `search`
 * @param {string} string
 * @param {string} search
 * @return {boolean}
 */
function startsWith(string, search) {
  return string.substr(0, search.length) === search;
}

/**
 * Check if `segment` is a root segment
 * @param {string} segment
 * @return {boolean}
 */
function isRootSegment(segment) {
  return segment === "";
}

/**
 * Check if `segment` is a dynamic segment
 * @param {string} segment
 * @return {boolean}
 */
function isDynamic(segment) {
  return paramRe.test(segment);
}

/**
 * Check if `segment` is a splat
 * @param {string} segment
 * @return {boolean}
 */
function isSplat(segment) {
  return segment[0] === "*";
}

/**
 * Split up the URI into segments delimited by `/`
 * @param {string} uri
 * @return {string[]}
 */
function segmentize(uri) {
  return (
    uri
      // Strip starting/ending `/`
      .replace(/(^\/+|\/+$)/g, "")
      .split("/")
  );
}

/**
 * Strip `str` of potential start and end `/`
 * @param {string} str
 * @return {string}
 */
function stripSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
}

/**
 * Score a route depending on how its individual segments look
 * @param {object} route
 * @param {number} index
 * @return {object}
 */
function rankRoute(route, index) {
  const score = route.default
    ? 0
    : segmentize(route.path).reduce((score, segment) => {
        score += SEGMENT_POINTS;

        if (isRootSegment(segment)) {
          score += ROOT_POINTS;
        } else if (isDynamic(segment)) {
          score += DYNAMIC_POINTS;
        } else if (isSplat(segment)) {
          score -= SEGMENT_POINTS + SPLAT_PENALTY;
        } else {
          score += STATIC_POINTS;
        }

        return score;
      }, 0);

  return { route, score, index };
}

/**
 * Give a score to all routes and sort them on that
 * @param {object[]} routes
 * @return {object[]}
 */
function rankRoutes(routes) {
  return (
    routes
      .map(rankRoute)
      // If two routes have the exact same score, we go by index instead
      .sort((a, b) =>
        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
      )
  );
}

/**
 * Ranks and picks the best route to match. Each segment gets the highest
 * amount of points, then the type of segment gets an additional amount of
 * points where
 *
 *  static > dynamic > splat > root
 *
 * This way we don't have to worry about the order of our routes, let the
 * computers do it.
 *
 * A route looks like this
 *
 *  { path, default, value }
 *
 * And a returned match looks like:
 *
 *  { route, params, uri }
 *
 * @param {object[]} routes
 * @param {string} uri
 * @return {?object}
 */
function pick(routes, uri) {
  let match;
  let default_;

  const [uriPathname] = uri.split("?");
  const uriSegments = segmentize(uriPathname);
  const isRootUri = uriSegments[0] === "";
  const ranked = rankRoutes(routes);

  for (let i = 0, l = ranked.length; i < l; i++) {
    const route = ranked[i].route;
    let missed = false;

    if (route.default) {
      default_ = {
        route,
        params: {},
        uri
      };
      continue;
    }

    const routeSegments = segmentize(route.path);
    const params = {};
    const max = Math.max(uriSegments.length, routeSegments.length);
    let index = 0;

    for (; index < max; index++) {
      const routeSegment = routeSegments[index];
      const uriSegment = uriSegments[index];

      if (routeSegment !== undefined && isSplat(routeSegment)) {
        // Hit a splat, just grab the rest, and return a match
        // uri:   /files/documents/work
        // route: /files/* or /files/*splatname
        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

        params[splatName] = uriSegments
          .slice(index)
          .map(decodeURIComponent)
          .join("/");
        break;
      }

      if (uriSegment === undefined) {
        // URI is shorter than the route, no match
        // uri:   /users
        // route: /users/:userId
        missed = true;
        break;
      }

      let dynamicMatch = paramRe.exec(routeSegment);

      if (dynamicMatch && !isRootUri) {
        const value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        // Current segments don't match, not dynamic, not splat, so no match
        // uri:   /users/123/settings
        // route: /users/:id/profile
        missed = true;
        break;
      }
    }

    if (!missed) {
      match = {
        route,
        params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }

  return match || default_ || null;
}

/**
 * Check if the `path` matches the `uri`.
 * @param {string} path
 * @param {string} uri
 * @return {?object}
 */
function match(route, uri) {
  return pick([route], uri);
}

/**
 * Add the query to the pathname if a query is given
 * @param {string} pathname
 * @param {string} [query]
 * @return {string}
 */
function addQuery(pathname, query) {
  return pathname + (query ? `?${query}` : "");
}

/**
 * Resolve URIs as though every path is a directory, no files. Relative URIs
 * in the browser can feel awkward because not only can you be "in a directory",
 * you can be "at a file", too. For example:
 *
 *  browserSpecResolve('foo', '/bar/') => /bar/foo
 *  browserSpecResolve('foo', '/bar') => /foo
 *
 * But on the command line of a file system, it's not as complicated. You can't
 * `cd` from a file, only directories. This way, links have to know less about
 * their current path. To go deeper you can do this:
 *
 *  <Link to="deeper"/>
 *  // instead of
 *  <Link to=`{${props.uri}/deeper}`/>
 *
 * Just like `cd`, if you want to go deeper from the command line, you do this:
 *
 *  cd deeper
 *  # not
 *  cd $(pwd)/deeper
 *
 * By treating every path as a directory, linking to relative paths should
 * require less contextual information and (fingers crossed) be more intuitive.
 * @param {string} to
 * @param {string} base
 * @return {string}
 */
function resolve(to, base) {
  // /foo/bar, /baz/qux => /foo/bar
  if (startsWith(to, "/")) {
    return to;
  }

  const [toPathname, toQuery] = to.split("?");
  const [basePathname] = base.split("?");
  const toSegments = segmentize(toPathname);
  const baseSegments = segmentize(basePathname);

  // ?a=b, /users?b=c => /users?a=b
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }

  // profile, /users/789 => /users/789/profile
  if (!startsWith(toSegments[0], ".")) {
    const pathname = baseSegments.concat(toSegments).join("/");

    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }

  // ./       , /users/123 => /users/123
  // ../      , /users/123 => /users
  // ../..    , /users/123 => /
  // ../../one, /a/b/c/d   => /a/b/one
  // .././one , /a/b/c/d   => /a/b/c/one
  const allSegments = baseSegments.concat(toSegments);
  const segments = [];

  allSegments.forEach(segment => {
    if (segment === "..") {
      segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });

  return addQuery("/" + segments.join("/"), toQuery);
}

/**
 * Combines the `basepath` and the `path` into one path.
 * @param {string} basepath
 * @param {string} path
 */
function combinePaths(basepath, path) {
  return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
}

/**
 * Decides whether a given `event` should result in a navigation or not.
 * @param {object} event
 */
function shouldNavigate(event) {
  return (
    !event.defaultPrevented &&
    event.button === 0 &&
    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
  );
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.22.2 */

function create_fragment$6(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let $routes;
	let { basepath = "/" } = $$props;
	let { url = null } = $$props;
	const locationContext = getContext(LOCATION);
	const routerContext = getContext(ROUTER);
	const routes = writable([]);
	validate_store(routes, "routes");
	component_subscribe($$self, routes, value => $$invalidate(8, $routes = value));
	const activeRoute = writable(null);
	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

	// If locationContext is not set, this is the topmost Router in the tree.
	// If the `url` prop is given we force the location to it.
	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(7, $location = value));

	// If routerContext is set, the routerBase of the parent Router
	// will be the base for this Router's descendants.
	// If routerContext is not set, the path and resolved uri will both
	// have the value of the basepath prop.
	const base = routerContext
	? routerContext.routerBase
	: writable({ path: basepath, uri: basepath });

	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(6, $base = value));

	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
		// If there is no activeRoute, the routerBase will be identical to the base.
		if (activeRoute === null) {
			return base;
		}

		const { path: basepath } = base;
		const { route, uri } = activeRoute;

		// Remove the potential /* or /*splatname from
		// the end of the child Routes relative paths.
		const path = route.default
		? basepath
		: route.path.replace(/\*.*$/, "");

		return { path, uri };
	});

	function registerRoute(route) {
		const { path: basepath } = $base;
		let { path } = route;

		// We store the original path in the _path property so we can reuse
		// it when the basepath changes. The only thing that matters is that
		// the route reference is intact, so mutation is fine.
		route._path = path;

		route.path = combinePaths(basepath, path);

		if (typeof window === "undefined") {
			// In SSR we should set the activeRoute immediately if it is a match.
			// If there are more Routes being registered after a match is found,
			// we just skip them.
			if (hasActiveRoute) {
				return;
			}

			const matchingRoute = match(route, $location.pathname);

			if (matchingRoute) {
				activeRoute.set(matchingRoute);
				hasActiveRoute = true;
			}
		} else {
			routes.update(rs => {
				rs.push(route);
				return rs;
			});
		}
	}

	function unregisterRoute(route) {
		routes.update(rs => {
			const index = rs.indexOf(route);
			rs.splice(index, 1);
			return rs;
		});
	}

	if (!locationContext) {
		// The topmost Router in the tree is responsible for updating
		// the location store and supplying it through context.
		onMount(() => {
			const unlisten = globalHistory.listen(history => {
				location.set(history.location);
			});

			return unlisten;
		});

		setContext(LOCATION, location);
	}

	setContext(ROUTER, {
		activeRoute,
		base,
		routerBase,
		registerRoute,
		unregisterRoute
	});

	const writable_props = ["basepath", "url"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Router", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		onMount,
		writable,
		derived,
		LOCATION,
		ROUTER,
		globalHistory,
		pick,
		match,
		stripSlashes,
		combinePaths,
		basepath,
		url,
		locationContext,
		routerContext,
		routes,
		activeRoute,
		hasActiveRoute,
		location,
		base,
		routerBase,
		registerRoute,
		unregisterRoute,
		$base,
		$location,
		$routes
	});

	$$self.$inject_state = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$base*/ 64) {
			// This reactive statement will update all the Routes' path when
			// the basepath changes.
			 {
				const { path: basepath } = $base;

				routes.update(rs => {
					rs.forEach(r => r.path = combinePaths(basepath, r._path));
					return rs;
				});
			}
		}

		if ($$self.$$.dirty & /*$routes, $location*/ 384) {
			// This reactive statement will be run when the Router is created
			// when there are no Routes and then again the following tick, so it
			// will not find an active Route in SSR and in the browser it will only
			// pick an active Route after all Routes have been registered.
			 {
				const bestMatch = pick($routes, $location.pathname);
				activeRoute.set(bestMatch);
			}
		}
	};

	return [
		routes,
		location,
		base,
		basepath,
		url,
		hasActiveRoute,
		$base,
		$location,
		$routes,
		locationContext,
		routerContext,
		activeRoute,
		routerBase,
		registerRoute,
		unregisterRoute,
		$$scope,
		$$slots
	];
}

class Router extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { basepath: 3, url: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Router",
			options,
			id: create_fragment$6.name
		});
	}

	get basepath() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set basepath(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.22.2 */

const get_default_slot_changes = dirty => ({
	params: dirty & /*routeParams*/ 2,
	location: dirty & /*$location*/ 16
});

const get_default_slot_context = ctx => ({
	params: /*routeParams*/ ctx[1],
	location: /*$location*/ ctx[4]
});

// (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*component*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
		ctx
	});

	return block;
}

// (43:2) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 4114) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(43:2) {:else}",
		ctx
	});

	return block;
}

// (41:2) {#if component !== null}
function create_if_block_1(ctx) {
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{ location: /*$location*/ ctx[4] },
		/*routeParams*/ ctx[1],
		/*routeProps*/ ctx[2]
	];

	var switch_value = /*component*/ ctx[0];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 22)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
					dirty & /*routeParams*/ 2 && get_spread_object(/*routeParams*/ ctx[1]),
					dirty & /*routeProps*/ 4 && get_spread_object(/*routeProps*/ ctx[2])
				])
			: {};

			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(41:2) {#if component !== null}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$activeRoute*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $activeRoute;
	let $location;
	let { path = "" } = $$props;
	let { component = null } = $$props;
	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
	validate_store(activeRoute, "activeRoute");
	component_subscribe($$self, activeRoute, value => $$invalidate(3, $activeRoute = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

	const route = {
		path,
		// If no path prop is given, this Route will act as the default Route
		// that is rendered if no other Route in the Router is a match.
		default: path === ""
	};

	let routeParams = {};
	let routeProps = {};
	registerRoute(route);

	// There is no need to unregister Routes in SSR since it will all be
	// thrown away anyway.
	if (typeof window !== "undefined") {
		onDestroy(() => {
			unregisterRoute(route);
		});
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Route", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		onDestroy,
		ROUTER,
		LOCATION,
		path,
		component,
		registerRoute,
		unregisterRoute,
		activeRoute,
		location,
		route,
		routeParams,
		routeProps,
		$activeRoute,
		$location
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
		if ("routeParams" in $$props) $$invalidate(1, routeParams = $$new_props.routeParams);
		if ("routeProps" in $$props) $$invalidate(2, routeProps = $$new_props.routeProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$activeRoute*/ 8) {
			 if ($activeRoute && $activeRoute.route === route) {
				$$invalidate(1, routeParams = $activeRoute.params);
			}
		}

		 {
			const { path, component, ...rest } = $$props;
			$$invalidate(2, routeProps = rest);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		component,
		routeParams,
		routeProps,
		$activeRoute,
		$location,
		activeRoute,
		location,
		route,
		path,
		registerRoute,
		unregisterRoute,
		$$props,
		$$scope,
		$$slots
	];
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { path: 8, component: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Route",
			options,
			id: create_fragment$7.name
		});
	}

	get path() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.22.2 */
const file$6 = "Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte";

function create_fragment$8(ctx) {
	let a;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let a_levels = [
		{ href: /*href*/ ctx[0] },
		{ "aria-current": /*ariaCurrent*/ ctx[2] },
		/*props*/ ctx[1]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, "aria-current": true });
			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(a, a_data);
			add_location(a, file$6, 40, 0, 1249);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
			if (remount) dispose();
			dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}

			set_attributes(a, get_spread_update(a_levels, [
				dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
				dirty & /*ariaCurrent*/ 4 && { "aria-current": /*ariaCurrent*/ ctx[2] },
				dirty & /*props*/ 2 && /*props*/ ctx[1]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let { to = "#" } = $$props;
	let { replace = false } = $$props;
	let { state = {} } = $$props;
	let { getProps = () => ({}) } = $$props;
	const { base } = getContext(ROUTER);
	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(12, $base = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(13, $location = value));
	const dispatch = createEventDispatcher();
	let href, isPartiallyCurrent, isCurrent, props;

	function onClick(event) {
		dispatch("click", event);

		if (shouldNavigate(event)) {
			event.preventDefault();

			// Don't push another entry to the history stack when the user
			// clicks on a Link to the page they are currently on.
			const shouldReplace = $location.pathname === href || replace;

			navigate(href, { state, replace: shouldReplace });
		}
	}

	const writable_props = ["to", "replace", "state", "getProps"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Link", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		createEventDispatcher,
		ROUTER,
		LOCATION,
		navigate,
		startsWith,
		resolve,
		shouldNavigate,
		to,
		replace,
		state,
		getProps,
		base,
		location,
		dispatch,
		href,
		isPartiallyCurrent,
		isCurrent,
		props,
		onClick,
		$base,
		$location,
		ariaCurrent
	});

	$$self.$inject_state = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$props.isPartiallyCurrent);
		if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$props.isCurrent);
		if ("props" in $$props) $$invalidate(1, props = $$props.props);
		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$props.ariaCurrent);
	};

	let ariaCurrent;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*to, $base*/ 4160) {
			 $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
		}

		if ($$self.$$.dirty & /*$location, href*/ 8193) {
			 $$invalidate(10, isPartiallyCurrent = startsWith($location.pathname, href));
		}

		if ($$self.$$.dirty & /*href, $location*/ 8193) {
			 $$invalidate(11, isCurrent = href === $location.pathname);
		}

		if ($$self.$$.dirty & /*isCurrent*/ 2048) {
			 $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
		}

		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 11777) {
			 $$invalidate(1, props = getProps({
				location: $location,
				href,
				isPartiallyCurrent,
				isCurrent
			}));
		}
	};

	return [
		href,
		props,
		ariaCurrent,
		base,
		location,
		onClick,
		to,
		replace,
		state,
		getProps,
		isPartiallyCurrent,
		isCurrent,
		$base,
		$location,
		dispatch,
		$$scope,
		$$slots
	];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { to: 6, replace: 7, state: 8, getProps: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$8.name
		});
	}

	get to() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set to(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get replace() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set replace(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getProps() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getProps(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/profile.svelte generated by Svelte v3.22.2 */
const file$7 = "src/routes/profile.svelte";

function create_fragment$9(ctx) {
	let t0;
	let t1;
	let div5;
	let t2;
	let div3;
	let div0;
	let t3;
	let t4;
	let div1;
	let t5;
	let t6;
	let div2;
	let t7;
	let t8;
	let div4;
	let t9;
	let current;

	const navbar = new Navbar({
			props: { title: "Profile" },
			$$inline: true
		});

	const profileheader = new ProfileHeader({
			props: {
				name: /*username_value*/ ctx[0],
				alias: "bingotheslayer",
				profilepicture: "profilepicture.jpg",
				level: "40"
			},
			$$inline: true
		});

	const about = new About({ $$inline: true });
	const tabbar = new Tabbar({ props: { location: 2 }, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			create_component(navbar.$$.fragment);
			t1 = space();
			div5 = element("div");
			create_component(profileheader.$$.fragment);
			t2 = space();
			div3 = element("div");
			div0 = element("div");
			t3 = text("About");
			t4 = space();
			div1 = element("div");
			t5 = text("Activity");
			t6 = space();
			div2 = element("div");
			t7 = text("Inventory");
			t8 = space();
			div4 = element("div");
			create_component(about.$$.fragment);
			t9 = space();
			create_component(tabbar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-fcey8i\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(navbar.$$.fragment, nodes);
			t1 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			claim_component(profileheader.$$.fragment, div5_nodes);
			t2 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t3 = claim_text(div0_nodes, "About");
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t5 = claim_text(div1_nodes, "Activity");
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t7 = claim_text(div2_nodes, "Inventory");
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t8 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			claim_component(about.$$.fragment, div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			claim_component(tabbar.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Profile :: Steam Mobile";
			attr_dev(div0, "class", "selected svelte-1ttnfi1");
			add_location(div0, file$7, 27, 4, 711);
			attr_dev(div1, "class", "svelte-1ttnfi1");
			add_location(div1, file$7, 28, 4, 749);
			attr_dev(div2, "class", "svelte-1ttnfi1");
			add_location(div2, file$7, 29, 4, 773);
			attr_dev(div3, "id", "navtray");
			attr_dev(div3, "class", "svelte-1ttnfi1");
			add_location(div3, file$7, 26, 2, 688);
			attr_dev(div4, "id", "container");
			attr_dev(div4, "class", "svelte-1ttnfi1");
			add_location(div4, file$7, 31, 2, 805);
			attr_dev(div5, "id", "profile");
			attr_dev(div5, "class", "svelte-1ttnfi1");
			add_location(div5, file$7, 20, 0, 539);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(navbar, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div5, anchor);
			mount_component(profileheader, div5, null);
			append_dev(div5, t2);
			append_dev(div5, div3);
			append_dev(div3, div0);
			append_dev(div0, t3);
			append_dev(div3, t4);
			append_dev(div3, div1);
			append_dev(div1, t5);
			append_dev(div3, t6);
			append_dev(div3, div2);
			append_dev(div2, t7);
			append_dev(div5, t8);
			append_dev(div5, div4);
			mount_component(about, div4, null);
			insert_dev(target, t9, anchor);
			mount_component(tabbar, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const profileheader_changes = {};
			if (dirty & /*username_value*/ 1) profileheader_changes.name = /*username_value*/ ctx[0];
			profileheader.$set(profileheader_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(profileheader.$$.fragment, local);
			transition_in(about.$$.fragment, local);
			transition_in(tabbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(profileheader.$$.fragment, local);
			transition_out(about.$$.fragment, local);
			transition_out(tabbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div5);
			destroy_component(profileheader);
			destroy_component(about);
			if (detaching) detach_dev(t9);
			destroy_component(tabbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let username_value;

	const unsubscribe = username.subscribe(value => {
		$$invalidate(0, username_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Profile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Profile", $$slots, []);

	$$self.$capture_state = () => ({
		Navbar,
		Tabbar,
		ProfileHeader,
		About,
		username,
		Router,
		Link,
		Route,
		username_value,
		unsubscribe
	});

	$$self.$inject_state = $$props => {
		if ("username_value" in $$props) $$invalidate(0, username_value = $$props.username_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [username_value];
}

class Profile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Profile",
			options,
			id: create_fragment$9.name
		});
	}
}

export default Profile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS42ODFlY2NlNS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUHJvZmlsZUhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9TaG93Y2FzZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9Qcm9maWxlVGlsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9BYm91dC5zdmVsdGUiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXJvdXRpbmcvc3JjL2NvbnRleHRzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy9oaXN0b3J5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy91dGlscy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvUm91dGVyLnN2ZWx0ZSIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvUm91dGUuc3ZlbHRlIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy9MaW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcHJvZmlsZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBhbGlhcywgbmFtZSwgcHJvZmlsZXBpY3R1cmUsIGxldmVsXG48L3NjcmlwdD5cblxuPG1haW4+XG4gIDxkaXYgaWQ9XCJoZWFkXCI+XG4gICAgPGRpdiBpZD1cImxheWVyMVwiIC8+XG4gICAgPGRpdiBpZD1cImNvbnRlbnR3cmFwcGVyXCI+XG4gICAgICA8ZGl2IGlkPVwiY29udGVudFwiPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgaWQ9XCJwcm9maWxlcGljdHVyZVwiXG4gICAgICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoe3Byb2ZpbGVwaWN0dXJlfSk7XCIgLz5cbiAgICAgICAgPGRpdiBpZD1cInVzZXJpbmZvXCI+XG4gICAgICAgICAgPGgzPnthbGlhc308L2gzPlxuICAgICAgICAgIDxoNT57bmFtZX08L2g1PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCEtLSBuZWVkIHRvIHJpZ2h0IGxvZ2ljIGZvciBoYW5kbGluZyBiYWRnZSBjb2xvciAtLT5cbiAgICAgICAgPGRpdiBpZD1cImxldmVsXCI+e2xldmVsfTwvZGl2PlxuICAgICAgICA8IS0tIG5lZWQgdG8gcmlnaHQgbG9naWMgZm9yIGhhbmRsaW5nIGJhZGdlIGNvbG9yIC0tPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cImxheWVyMlwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKGd0YS5qcGcpO1wiIC8+XG4gICAgPGRpdiBpZD1cImxheWVyM1wiIC8+XG4gIDwvZGl2PlxuPC9tYWluPlxuXG48c3R5bGU+XG4gICNoZWFkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cblxuICAjdXNlcmluZm8ge1xuICAgIG1hcmdpbi1sZWZ0OiAxOHB4O1xuICB9XG5cbiAgI2xldmVsIHtcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjNDY3YTNjO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuICAgIHdpZHRoOiAzNXB4O1xuICAgIGhlaWdodDogMzVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICBoMyB7XG4gICAgZm9udC1zaXplOiAyMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICBoNSB7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgY29sb3I6ICM2OTY5Njk7XG4gIH1cblxuICAjcHJvZmlsZXBpY3R1cmUge1xuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICBoZWlnaHQ6IDc1cHg7XG4gICAgd2lkdGg6IDc1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG5cbiAgI2xheWVyMSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGhlaWdodDogNTBweDtcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCByZ2IoMCwgMCwgMCksIHJnYmEoMCwgMCwgMCwgMCkpO1xuICAgIGJvdHRvbTogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB6LWluZGV4OiA5NzU7XG4gIH1cblxuICAjY29udGVudHdyYXBwZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiA5OTtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gICNjb250ZW50IHtcbiAgICBwYWRkaW5nOiAzMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuXG4gICNsYXllcjIge1xuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxNDBweDtcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICAgIHotaW5kZXg6IDM7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG9wYWNpdHk6IDAuMTtcbiAgfVxuXG4gICNsYXllcjMge1xuICAgIGJhY2tncm91bmQ6ICMwZjBiMjA7XG4gICAgaGVpZ2h0OiAxNDBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIHotaW5kZXg6IDI7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGltYWdlcztcbiAgbGV0IHNob3djYXNlaW1hZ2VzID0gaW1hZ2VzO1xuICBjb25zb2xlLmxvZyhpbWFnZXMpXG48L3NjcmlwdD5cbjxkaXYgaWQ9XCJiYWRnZXNob3djYXNlXCI+XG4gIDxpbWcgc3JjPVwie3Nob3djYXNlWzBdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDMycHg7XCIgLz5cbiAgPGltZyBzcmM9XCJ7c2hvd2Nhc2VbMV0ubGlua31cIiBzdHlsZT1cImhlaWdodDogMzJweDtcIiAvPlxuICA8aW1nIHNyYz1cIntzaG93Y2FzZVsyXS5saW5rfVwiIC8+XG4gIDxpbWcgc3JjPVwie3Nob3djYXNlWzNdLmxpbmt9XCIgc3R5bGU9XCJoZWlnaHQ6IDM2cHg7XCIgLz5cbiAgPGltZyBzcmM9XCJ7c2hvd2Nhc2VbNF0ubGlua31cIiBzdHlsZT1cImhlaWdodDogMzhweDtcIiAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgI2JhZGdlc2hvd2Nhc2UgaW1ne1xuICAgIGhlaWdodDogNDBweDtcbiAgfVxuXG4gICNiYWRnZXNob3djYXNle1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgTWFpbkJhZGdlIGZyb20gJy4vTWFpbkJhZGdlLnN2ZWx0ZSdcbiAgaW1wb3J0IFNob3djYXNlIGZyb20gJy4vU2hvd2Nhc2Uuc3ZlbHRlJ1xuXG4gIGV4cG9ydCBsZXQgbmFtZSwgbnVtYmVyLCBpZCwgaW1hZ2VzO1xuPC9zY3JpcHQ+XG5cbjxkaXYge2lkfT5cbiAgPGRpdiBpZD1cInRpdGxlXCI+XG4gICAgPGgzPntuYW1lfTwvaDM+XG4gICAgPGgyPntudW1iZXJ9PC9oMj5cbiAgPC9kaXY+XG4gIHsjaWYgbmFtZSA9PT0gXCJCYWRnZXNcIn1cbiAgICA8TWFpbkJhZGdlIC8+XG4gIHsvaWZ9XG4gIDxTaG93Y2FzZSB7aW1hZ2VzfSAvPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgI3RpdGxlIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICB9XG5cbiAgaDJ7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgfVxuXG4gICNiYWRnZXMsICNmcmllbmRzLCAjZ3JvdXBzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGYwYjIwO1xuICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgZm9udC1zaXplOiAxMnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgXG4gIH1cblxuICAjYmFkZ2Vze1xuICAgIGdyaWQtY29sdW1uOiAxLzI7XG4gICAgZ3JpZC1yb3c6IDIvNDtcbiAgfVxuXG4gICNmcmllbmRze1xuICAgIGdyaWQtY29sdW1uOiAyL2F1dG87XG4gICAgZ3JpZC1yb3c6IDMvNDtcbiAgfVxuXG4gICAjZ3JvdXBze1xuICAgIGdyaWQtY29sdW1uOiAyL2F1dG87XG4gICAgZ3JpZC1yb3c6IDIvMztcbiAgfVxuXG5cbiAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2MDBweCkge1xuICAjYmFkZ2VzIHtcbiAgICBncmlkLWNvbHVtbjogMS8zO1xuICB9XG59XG5cblxuICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYwMHB4KSB7XG4gICNmcmllbmRzIHtcbiAgICBncmlkLWNvbHVtbjogMS8zO1xuICAgIGdyaWQtcm93OiA0XG4gIH1cbn1cblxuQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2MDBweCkge1xuICAjZ3JvdXBzIHtcbiAgICBncmlkLWNvbHVtbjogMS8zO1xuICAgIGdyaWQtcm93OiA1XG4gIH1cbn1cblxuXG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IEFib3V0TWVUaWxlIGZyb20gJy4vQWJvdXRNZVRpbGUuc3ZlbHRlJ1xuICBpbXBvcnQgUHJvZmlsZVRpbGUgZnJvbSAnLi9Qcm9maWxlVGlsZS5zdmVsdGUnXG4gIC8vIGltcG9ydCBBcnR3b3JrIGZyb20gJy4vQmFkZ2VzLnN2ZWx0ZSdcbiAgLy8gaW1wb3J0IENvbW1lbnRzIGZyb20gJy4vQmFkZ2VzLnN2ZWx0ZSdcbjwvc2NyaXB0PlxuXG48bWFpbj5cbiAgPEFib3V0TWVUaWxlIC8+XG4gIDxQcm9maWxlVGlsZSBpZD1cImJhZGdlc1wiIG5hbWU9XCJCYWRnZXNcIiBudW1iZXI9XCIxNFwiIC8+XG4gIDxQcm9maWxlVGlsZSBpZD1cImZyaWVuZHNcIiBuYW1lPVwiRnJpZW5kc1wiIG51bWJlcj1cIjI4XCIgLz5cbiAgPFByb2ZpbGVUaWxlIGlkPVwiZ3JvdXBzXCIgbmFtZT1cIkdyb3Vwc1wiIG51bWJlcj1cIjhcIiBpbWFnZXM9XCJ7W3tsaW5rOiBcImh0dHBzOi8vc3RlYW1jb21tdW5pdHktYS5ha2FtYWloZC5uZXQvcHVibGljL2ltYWdlcy9iYWRnZXMvMzdfc3VtbWVyMjAxOS9sZXZlbDI1XzgwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNkbi1hLmFrYW1haWhkLm5ldC9zdGVhbWNvbW11bml0eS9wdWJsaWMvaW1hZ2VzL2l0ZW1zLzczMC81NGU0MGI5ZTIyODhmYmFiOGJkNGM2NTM3YjAzMjVkNDA1YzdlMWIwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNvbW11bml0eS1hLmFrYW1haWhkLm5ldC9wdWJsaWMvaW1hZ2VzL2JhZGdlcy8yOF9zcHJpbmdjbGVhbmluZzIwMTgvYnJvbnplXzgwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNkbi1hLmFrYW1haWhkLm5ldC9zdGVhbWNvbW11bml0eS9wdWJsaWMvaW1hZ2VzL2l0ZW1zLzc2MjgwMC9kNDY3ZWM4ZWFlZDQ2NDNjNDdmYmVkNDNlZDc4MWRhZWYyNTI1OTYzLnBuZ1wifSwge2xpbmsgOiBcImh0dHBzOi8vc3RlYW1jb21tdW5pdHktYS5ha2FtYWloZC5uZXQvcHVibGljL2ltYWdlcy9iYWRnZXMvMjdfc3RlYW1hd2FyZG5vbWluYXRpb25zL2xldmVsMDRfODAucG5nXCJ9XX1cIiAvPlxuICA8IS0tIDxBcnR3b3JrIC8+IC0tPlxuICA8IS0tIDxDb21tZW50cyAvPiAtLT5cbjwvbWFpbj5cblxuPHN0eWxlPlxuICBtYWluIHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDMsIGF1dG8pO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMTkycHgsIDUwJSkpO1xuICAgIGdyaWQtZ2FwOiAxNXB4O1xuICB9XG48L3N0eWxlPlxuIiwiZXhwb3J0IGNvbnN0IExPQ0FUSU9OID0ge307XG5leHBvcnQgY29uc3QgUk9VVEVSID0ge307XG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcm91dGVyL2Jsb2IvYjYwZTZkZDc4MWQ1ZDNhNGJkYWFmNGRlNjY1NjQ5YzBmNmE3ZTc4ZC9zcmMvbGliL2hpc3RvcnkuanNcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcm91dGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqICovXG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uKHNvdXJjZSkge1xuICByZXR1cm4ge1xuICAgIC4uLnNvdXJjZS5sb2NhdGlvbixcbiAgICBzdGF0ZTogc291cmNlLmhpc3Rvcnkuc3RhdGUsXG4gICAga2V5OiAoc291cmNlLmhpc3Rvcnkuc3RhdGUgJiYgc291cmNlLmhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImluaXRpYWxcIlxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgbGV0IGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcblxuICByZXR1cm4ge1xuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIGNvbnN0IHBvcHN0YXRlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcbiAgICAgICAgbGlzdGVuZXIoeyBsb2NhdGlvbiwgYWN0aW9uOiBcIlBPUFwiIH0pO1xuICAgICAgfTtcblxuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUxpc3RlbmVyKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBuYXZpZ2F0ZSh0bywgeyBzdGF0ZSwgcmVwbGFjZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgc3RhdGUgPSB7IC4uLnN0YXRlLCBrZXk6IERhdGUubm93KCkgKyBcIlwiIH07XG4gICAgICAvLyB0cnkuLi5jYXRjaCBpT1MgU2FmYXJpIGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgIHNvdXJjZS5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgbnVsbCwgdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZS5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgbnVsbCwgdG8pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNvdXJjZS5sb2NhdGlvbltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcImFzc2lnblwiXSh0byk7XG4gICAgICB9XG5cbiAgICAgIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHsgbG9jYXRpb24sIGFjdGlvbjogXCJQVVNIXCIgfSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gU3RvcmVzIGhpc3RvcnkgZW50cmllcyBpbiBtZW1vcnkgZm9yIHRlc3Rpbmcgb3Igb3RoZXIgcGxhdGZvcm1zIGxpa2UgTmF0aXZlXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlTb3VyY2UoaW5pdGlhbFBhdGhuYW1lID0gXCIvXCIpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3Qgc3RhY2sgPSBbeyBwYXRobmFtZTogaW5pdGlhbFBhdGhuYW1lLCBzZWFyY2g6IFwiXCIgfV07XG4gIGNvbnN0IHN0YXRlcyA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YWNrW2luZGV4XTtcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZm4pIHt9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZm4pIHt9LFxuICAgIGhpc3Rvcnk6IHtcbiAgICAgIGdldCBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9LFxuICAgICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9LFxuICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc3RhdGVzW2luZGV4XTtcbiAgICAgIH0sXG4gICAgICBwdXNoU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICBjb25zdCBbcGF0aG5hbWUsIHNlYXJjaCA9IFwiXCJdID0gdXJpLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgc3RhY2sucHVzaCh7IHBhdGhuYW1lLCBzZWFyY2ggfSk7XG4gICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICBjb25zdCBbcGF0aG5hbWUsIHNlYXJjaCA9IFwiXCJdID0gdXJpLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgc3RhY2tbaW5kZXhdID0geyBwYXRobmFtZSwgc2VhcmNoIH07XG4gICAgICAgIHN0YXRlc1tpbmRleF0gPSBzdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIEdsb2JhbCBoaXN0b3J5IHVzZXMgd2luZG93Lmhpc3RvcnkgYXMgdGhlIHNvdXJjZSBpZiBhdmFpbGFibGUsXG4vLyBvdGhlcndpc2UgYSBtZW1vcnkgaGlzdG9yeVxuY29uc3QgY2FuVXNlRE9NID0gQm9vbGVhbihcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuY29uc3QgZ2xvYmFsSGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoY2FuVXNlRE9NID8gd2luZG93IDogY3JlYXRlTWVtb3J5U291cmNlKCkpO1xuY29uc3QgeyBuYXZpZ2F0ZSB9ID0gZ2xvYmFsSGlzdG9yeTtcblxuZXhwb3J0IHsgZ2xvYmFsSGlzdG9yeSwgbmF2aWdhdGUsIGNyZWF0ZUhpc3RvcnksIGNyZWF0ZU1lbW9yeVNvdXJjZSB9O1xuIiwiLyoqXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JvdXRlci9ibG9iL2I2MGU2ZGQ3ODFkNWQzYTRiZGFhZjRkZTY2NTY0OWMwZjZhN2U3OGQvc3JjL2xpYi91dGlscy5qc1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yb3V0ZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogKi9cblxuY29uc3QgcGFyYW1SZSA9IC9eOiguKykvO1xuXG5jb25zdCBTRUdNRU5UX1BPSU5UUyA9IDQ7XG5jb25zdCBTVEFUSUNfUE9JTlRTID0gMztcbmNvbnN0IERZTkFNSUNfUE9JTlRTID0gMjtcbmNvbnN0IFNQTEFUX1BFTkFMVFkgPSAxO1xuY29uc3QgUk9PVF9QT0lOVFMgPSAxO1xuXG4vKipcbiAqIENoZWNrIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGBzZWFyY2hgXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHNlYXJjaCkge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBzZWdtZW50YCBpcyBhIHJvb3Qgc2VnbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlZ21lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUm9vdFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gXCJcIjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgc2VnbWVudGAgaXMgYSBkeW5hbWljIHNlZ21lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWdtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0R5bmFtaWMoc2VnbWVudCkge1xuICByZXR1cm4gcGFyYW1SZS50ZXN0KHNlZ21lbnQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBzZWdtZW50YCBpcyBhIHNwbGF0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VnbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGxhdChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50WzBdID09PSBcIipcIjtcbn1cblxuLyoqXG4gKiBTcGxpdCB1cCB0aGUgVVJJIGludG8gc2VnbWVudHMgZGVsaW1pdGVkIGJ5IGAvYFxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRpemUodXJpKSB7XG4gIHJldHVybiAoXG4gICAgdXJpXG4gICAgICAvLyBTdHJpcCBzdGFydGluZy9lbmRpbmcgYC9gXG4gICAgICAucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCBcIlwiKVxuICAgICAgLnNwbGl0KFwiL1wiKVxuICApO1xufVxuXG4vKipcbiAqIFN0cmlwIGBzdHJgIG9mIHBvdGVudGlhbCBzdGFydCBhbmQgZW5kIGAvYFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpcFNsYXNoZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCBcIlwiKTtcbn1cblxuLyoqXG4gKiBTY29yZSBhIHJvdXRlIGRlcGVuZGluZyBvbiBob3cgaXRzIGluZGl2aWR1YWwgc2VnbWVudHMgbG9va1xuICogQHBhcmFtIHtvYmplY3R9IHJvdXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmFua1JvdXRlKHJvdXRlLCBpbmRleCkge1xuICBjb25zdCBzY29yZSA9IHJvdXRlLmRlZmF1bHRcbiAgICA/IDBcbiAgICA6IHNlZ21lbnRpemUocm91dGUucGF0aCkucmVkdWNlKChzY29yZSwgc2VnbWVudCkgPT4ge1xuICAgICAgICBzY29yZSArPSBTRUdNRU5UX1BPSU5UUztcblxuICAgICAgICBpZiAoaXNSb290U2VnbWVudChzZWdtZW50KSkge1xuICAgICAgICAgIHNjb3JlICs9IFJPT1RfUE9JTlRTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRHluYW1pYyhzZWdtZW50KSkge1xuICAgICAgICAgIHNjb3JlICs9IERZTkFNSUNfUE9JTlRTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3BsYXQoc2VnbWVudCkpIHtcbiAgICAgICAgICBzY29yZSAtPSBTRUdNRU5UX1BPSU5UUyArIFNQTEFUX1BFTkFMVFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcmUgKz0gU1RBVElDX1BPSU5UUztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICAgIH0sIDApO1xuXG4gIHJldHVybiB7IHJvdXRlLCBzY29yZSwgaW5kZXggfTtcbn1cblxuLyoqXG4gKiBHaXZlIGEgc2NvcmUgdG8gYWxsIHJvdXRlcyBhbmQgc29ydCB0aGVtIG9uIHRoYXRcbiAqIEBwYXJhbSB7b2JqZWN0W119IHJvdXRlc1xuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHJhbmtSb3V0ZXMocm91dGVzKSB7XG4gIHJldHVybiAoXG4gICAgcm91dGVzXG4gICAgICAubWFwKHJhbmtSb3V0ZSlcbiAgICAgIC8vIElmIHR3byByb3V0ZXMgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBzY29yZSwgd2UgZ28gYnkgaW5kZXggaW5zdGVhZFxuICAgICAgLnNvcnQoKGEsIGIpID0+XG4gICAgICAgIGEuc2NvcmUgPCBiLnNjb3JlID8gMSA6IGEuc2NvcmUgPiBiLnNjb3JlID8gLTEgOiBhLmluZGV4IC0gYi5pbmRleFxuICAgICAgKVxuICApO1xufVxuXG4vKipcbiAqIFJhbmtzIGFuZCBwaWNrcyB0aGUgYmVzdCByb3V0ZSB0byBtYXRjaC4gRWFjaCBzZWdtZW50IGdldHMgdGhlIGhpZ2hlc3RcbiAqIGFtb3VudCBvZiBwb2ludHMsIHRoZW4gdGhlIHR5cGUgb2Ygc2VnbWVudCBnZXRzIGFuIGFkZGl0aW9uYWwgYW1vdW50IG9mXG4gKiBwb2ludHMgd2hlcmVcbiAqXG4gKiAgc3RhdGljID4gZHluYW1pYyA+IHNwbGF0ID4gcm9vdFxuICpcbiAqIFRoaXMgd2F5IHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhlIG9yZGVyIG9mIG91ciByb3V0ZXMsIGxldCB0aGVcbiAqIGNvbXB1dGVycyBkbyBpdC5cbiAqXG4gKiBBIHJvdXRlIGxvb2tzIGxpa2UgdGhpc1xuICpcbiAqICB7IHBhdGgsIGRlZmF1bHQsIHZhbHVlIH1cbiAqXG4gKiBBbmQgYSByZXR1cm5lZCBtYXRjaCBsb29rcyBsaWtlOlxuICpcbiAqICB7IHJvdXRlLCBwYXJhbXMsIHVyaSB9XG4gKlxuICogQHBhcmFtIHtvYmplY3RbXX0gcm91dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwaWNrKHJvdXRlcywgdXJpKSB7XG4gIGxldCBtYXRjaDtcbiAgbGV0IGRlZmF1bHRfO1xuXG4gIGNvbnN0IFt1cmlQYXRobmFtZV0gPSB1cmkuc3BsaXQoXCI/XCIpO1xuICBjb25zdCB1cmlTZWdtZW50cyA9IHNlZ21lbnRpemUodXJpUGF0aG5hbWUpO1xuICBjb25zdCBpc1Jvb3RVcmkgPSB1cmlTZWdtZW50c1swXSA9PT0gXCJcIjtcbiAgY29uc3QgcmFua2VkID0gcmFua1JvdXRlcyhyb3V0ZXMpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcmFua2VkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHJvdXRlID0gcmFua2VkW2ldLnJvdXRlO1xuICAgIGxldCBtaXNzZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb3V0ZS5kZWZhdWx0KSB7XG4gICAgICBkZWZhdWx0XyA9IHtcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHVyaVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlU2VnbWVudHMgPSBzZWdtZW50aXplKHJvdXRlLnBhdGgpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHVyaVNlZ21lbnRzLmxlbmd0aCwgcm91dGVTZWdtZW50cy5sZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHJvdXRlU2VnbWVudCA9IHJvdXRlU2VnbWVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgdXJpU2VnbWVudCA9IHVyaVNlZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKHJvdXRlU2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIGlzU3BsYXQocm91dGVTZWdtZW50KSkge1xuICAgICAgICAvLyBIaXQgYSBzcGxhdCwganVzdCBncmFiIHRoZSByZXN0LCBhbmQgcmV0dXJuIGEgbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC9maWxlcy9kb2N1bWVudHMvd29ya1xuICAgICAgICAvLyByb3V0ZTogL2ZpbGVzLyogb3IgL2ZpbGVzLypzcGxhdG5hbWVcbiAgICAgICAgY29uc3Qgc3BsYXROYW1lID0gcm91dGVTZWdtZW50ID09PSBcIipcIiA/IFwiKlwiIDogcm91dGVTZWdtZW50LnNsaWNlKDEpO1xuXG4gICAgICAgIHBhcmFtc1tzcGxhdE5hbWVdID0gdXJpU2VnbWVudHNcbiAgICAgICAgICAuc2xpY2UoaW5kZXgpXG4gICAgICAgICAgLm1hcChkZWNvZGVVUklDb21wb25lbnQpXG4gICAgICAgICAgLmpvaW4oXCIvXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHVyaVNlZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBVUkkgaXMgc2hvcnRlciB0aGFuIHRoZSByb3V0ZSwgbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vyc1xuICAgICAgICAvLyByb3V0ZTogL3VzZXJzLzp1c2VySWRcbiAgICAgICAgbWlzc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBkeW5hbWljTWF0Y2ggPSBwYXJhbVJlLmV4ZWMocm91dGVTZWdtZW50KTtcblxuICAgICAgaWYgKGR5bmFtaWNNYXRjaCAmJiAhaXNSb290VXJpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVNlZ21lbnQpO1xuICAgICAgICBwYXJhbXNbZHluYW1pY01hdGNoWzFdXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChyb3V0ZVNlZ21lbnQgIT09IHVyaVNlZ21lbnQpIHtcbiAgICAgICAgLy8gQ3VycmVudCBzZWdtZW50cyBkb24ndCBtYXRjaCwgbm90IGR5bmFtaWMsIG5vdCBzcGxhdCwgc28gbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vycy8xMjMvc2V0dGluZ3NcbiAgICAgICAgLy8gcm91dGU6IC91c2Vycy86aWQvcHJvZmlsZVxuICAgICAgICBtaXNzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1pc3NlZCkge1xuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHVyaTogXCIvXCIgKyB1cmlTZWdtZW50cy5zbGljZSgwLCBpbmRleCkuam9pbihcIi9cIilcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2ggfHwgZGVmYXVsdF8gfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYHBhdGhgIG1hdGNoZXMgdGhlIGB1cmlgLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHJvdXRlLCB1cmkpIHtcbiAgcmV0dXJuIHBpY2soW3JvdXRlXSwgdXJpKTtcbn1cblxuLyoqXG4gKiBBZGQgdGhlIHF1ZXJ5IHRvIHRoZSBwYXRobmFtZSBpZiBhIHF1ZXJ5IGlzIGdpdmVuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcnldXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFkZFF1ZXJ5KHBhdGhuYW1lLCBxdWVyeSkge1xuICByZXR1cm4gcGF0aG5hbWUgKyAocXVlcnkgPyBgPyR7cXVlcnl9YCA6IFwiXCIpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgVVJJcyBhcyB0aG91Z2ggZXZlcnkgcGF0aCBpcyBhIGRpcmVjdG9yeSwgbm8gZmlsZXMuIFJlbGF0aXZlIFVSSXNcbiAqIGluIHRoZSBicm93c2VyIGNhbiBmZWVsIGF3a3dhcmQgYmVjYXVzZSBub3Qgb25seSBjYW4geW91IGJlIFwiaW4gYSBkaXJlY3RvcnlcIixcbiAqIHlvdSBjYW4gYmUgXCJhdCBhIGZpbGVcIiwgdG9vLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgYnJvd3NlclNwZWNSZXNvbHZlKCdmb28nLCAnL2Jhci8nKSA9PiAvYmFyL2Zvb1xuICogIGJyb3dzZXJTcGVjUmVzb2x2ZSgnZm9vJywgJy9iYXInKSA9PiAvZm9vXG4gKlxuICogQnV0IG9uIHRoZSBjb21tYW5kIGxpbmUgb2YgYSBmaWxlIHN5c3RlbSwgaXQncyBub3QgYXMgY29tcGxpY2F0ZWQuIFlvdSBjYW4ndFxuICogYGNkYCBmcm9tIGEgZmlsZSwgb25seSBkaXJlY3Rvcmllcy4gVGhpcyB3YXksIGxpbmtzIGhhdmUgdG8ga25vdyBsZXNzIGFib3V0XG4gKiB0aGVpciBjdXJyZW50IHBhdGguIFRvIGdvIGRlZXBlciB5b3UgY2FuIGRvIHRoaXM6XG4gKlxuICogIDxMaW5rIHRvPVwiZGVlcGVyXCIvPlxuICogIC8vIGluc3RlYWQgb2ZcbiAqICA8TGluayB0bz1geyR7cHJvcHMudXJpfS9kZWVwZXJ9YC8+XG4gKlxuICogSnVzdCBsaWtlIGBjZGAsIGlmIHlvdSB3YW50IHRvIGdvIGRlZXBlciBmcm9tIHRoZSBjb21tYW5kIGxpbmUsIHlvdSBkbyB0aGlzOlxuICpcbiAqICBjZCBkZWVwZXJcbiAqICAjIG5vdFxuICogIGNkICQocHdkKS9kZWVwZXJcbiAqXG4gKiBCeSB0cmVhdGluZyBldmVyeSBwYXRoIGFzIGEgZGlyZWN0b3J5LCBsaW5raW5nIHRvIHJlbGF0aXZlIHBhdGhzIHNob3VsZFxuICogcmVxdWlyZSBsZXNzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIChmaW5nZXJzIGNyb3NzZWQpIGJlIG1vcmUgaW50dWl0aXZlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHRvLCBiYXNlKSB7XG4gIC8vIC9mb28vYmFyLCAvYmF6L3F1eCA9PiAvZm9vL2JhclxuICBpZiAoc3RhcnRzV2l0aCh0bywgXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgY29uc3QgW3RvUGF0aG5hbWUsIHRvUXVlcnldID0gdG8uc3BsaXQoXCI/XCIpO1xuICBjb25zdCBbYmFzZVBhdGhuYW1lXSA9IGJhc2Uuc3BsaXQoXCI/XCIpO1xuICBjb25zdCB0b1NlZ21lbnRzID0gc2VnbWVudGl6ZSh0b1BhdGhuYW1lKTtcbiAgY29uc3QgYmFzZVNlZ21lbnRzID0gc2VnbWVudGl6ZShiYXNlUGF0aG5hbWUpO1xuXG4gIC8vID9hPWIsIC91c2Vycz9iPWMgPT4gL3VzZXJzP2E9YlxuICBpZiAodG9TZWdtZW50c1swXSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhZGRRdWVyeShiYXNlUGF0aG5hbWUsIHRvUXVlcnkpO1xuICB9XG5cbiAgLy8gcHJvZmlsZSwgL3VzZXJzLzc4OSA9PiAvdXNlcnMvNzg5L3Byb2ZpbGVcbiAgaWYgKCFzdGFydHNXaXRoKHRvU2VnbWVudHNbMF0sIFwiLlwiKSkge1xuICAgIGNvbnN0IHBhdGhuYW1lID0gYmFzZVNlZ21lbnRzLmNvbmNhdCh0b1NlZ21lbnRzKS5qb2luKFwiL1wiKTtcblxuICAgIHJldHVybiBhZGRRdWVyeSgoYmFzZVBhdGhuYW1lID09PSBcIi9cIiA/IFwiXCIgOiBcIi9cIikgKyBwYXRobmFtZSwgdG9RdWVyeSk7XG4gIH1cblxuICAvLyAuLyAgICAgICAsIC91c2Vycy8xMjMgPT4gL3VzZXJzLzEyM1xuICAvLyAuLi8gICAgICAsIC91c2Vycy8xMjMgPT4gL3VzZXJzXG4gIC8vIC4uLy4uICAgICwgL3VzZXJzLzEyMyA9PiAvXG4gIC8vIC4uLy4uL29uZSwgL2EvYi9jL2QgICA9PiAvYS9iL29uZVxuICAvLyAuLi8uL29uZSAsIC9hL2IvYy9kICAgPT4gL2EvYi9jL29uZVxuICBjb25zdCBhbGxTZWdtZW50cyA9IGJhc2VTZWdtZW50cy5jb25jYXQodG9TZWdtZW50cyk7XG4gIGNvbnN0IHNlZ21lbnRzID0gW107XG5cbiAgYWxsU2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGFkZFF1ZXJ5KFwiL1wiICsgc2VnbWVudHMuam9pbihcIi9cIiksIHRvUXVlcnkpO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIHRoZSBgYmFzZXBhdGhgIGFuZCB0aGUgYHBhdGhgIGludG8gb25lIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVQYXRocyhiYXNlcGF0aCwgcGF0aCkge1xuICByZXR1cm4gYCR7c3RyaXBTbGFzaGVzKFxuICAgIHBhdGggPT09IFwiL1wiID8gYmFzZXBhdGggOiBgJHtzdHJpcFNsYXNoZXMoYmFzZXBhdGgpfS8ke3N0cmlwU2xhc2hlcyhwYXRoKX1gXG4gICl9L2A7XG59XG5cbi8qKlxuICogRGVjaWRlcyB3aGV0aGVyIGEgZ2l2ZW4gYGV2ZW50YCBzaG91bGQgcmVzdWx0IGluIGEgbmF2aWdhdGlvbiBvciBub3QuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkTmF2aWdhdGUoZXZlbnQpIHtcbiAgcmV0dXJuIChcbiAgICAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJlxuICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJlxuICAgICEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gaG9zdE1hdGNoZXMoYW5jaG9yKSB7XG4gIGNvbnN0IGhvc3QgPSBsb2NhdGlvbi5ob3N0XG4gIHJldHVybiAoXG4gICAgYW5jaG9yLmhvc3QgPT0gaG9zdCB8fFxuICAgIC8vIHN2ZWx0ZSBzZWVtcyB0byBraWxsIGFuY2hvci5ob3N0IHZhbHVlIGluIGllMTEsIHNvIGZhbGwgYmFjayB0byBjaGVja2luZyBocmVmXG4gICAgYW5jaG9yLmhyZWYuaW5kZXhPZihgaHR0cHM6Ly8ke2hvc3R9YCkgPT09IDAgfHxcbiAgICBhbmNob3IuaHJlZi5pbmRleE9mKGBodHRwOi8vJHtob3N0fWApID09PSAwXG4gIClcbn1cblxuZXhwb3J0IHsgc3RyaXBTbGFzaGVzLCBwaWNrLCBtYXRjaCwgcmVzb2x2ZSwgY29tYmluZVBhdGhzLCBzaG91bGROYXZpZ2F0ZSwgaG9zdE1hdGNoZXMgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIHNldENvbnRleHQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IHdyaXRhYmxlLCBkZXJpdmVkIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuICBpbXBvcnQgeyBMT0NBVElPTiwgUk9VVEVSIH0gZnJvbSBcIi4vY29udGV4dHMuanNcIjtcbiAgaW1wb3J0IHsgZ2xvYmFsSGlzdG9yeSB9IGZyb20gXCIuL2hpc3RvcnkuanNcIjtcbiAgaW1wb3J0IHsgcGljaywgbWF0Y2gsIHN0cmlwU2xhc2hlcywgY29tYmluZVBhdGhzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuICBleHBvcnQgbGV0IGJhc2VwYXRoID0gXCIvXCI7XG4gIGV4cG9ydCBsZXQgdXJsID0gbnVsbDtcblxuICBjb25zdCBsb2NhdGlvbkNvbnRleHQgPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcbiAgY29uc3Qgcm91dGVyQ29udGV4dCA9IGdldENvbnRleHQoUk9VVEVSKTtcblxuICBjb25zdCByb3V0ZXMgPSB3cml0YWJsZShbXSk7XG4gIGNvbnN0IGFjdGl2ZVJvdXRlID0gd3JpdGFibGUobnVsbCk7XG4gIGxldCBoYXNBY3RpdmVSb3V0ZSA9IGZhbHNlOyAvLyBVc2VkIGluIFNTUiB0byBzeW5jaHJvbm91c2x5IHNldCB0aGF0IGEgUm91dGUgaXMgYWN0aXZlLlxuXG4gIC8vIElmIGxvY2F0aW9uQ29udGV4dCBpcyBub3Qgc2V0LCB0aGlzIGlzIHRoZSB0b3Btb3N0IFJvdXRlciBpbiB0aGUgdHJlZS5cbiAgLy8gSWYgdGhlIGB1cmxgIHByb3AgaXMgZ2l2ZW4gd2UgZm9yY2UgdGhlIGxvY2F0aW9uIHRvIGl0LlxuICBjb25zdCBsb2NhdGlvbiA9XG4gICAgbG9jYXRpb25Db250ZXh0IHx8XG4gICAgd3JpdGFibGUodXJsID8geyBwYXRobmFtZTogdXJsIH0gOiBnbG9iYWxIaXN0b3J5LmxvY2F0aW9uKTtcblxuICAvLyBJZiByb3V0ZXJDb250ZXh0IGlzIHNldCwgdGhlIHJvdXRlckJhc2Ugb2YgdGhlIHBhcmVudCBSb3V0ZXJcbiAgLy8gd2lsbCBiZSB0aGUgYmFzZSBmb3IgdGhpcyBSb3V0ZXIncyBkZXNjZW5kYW50cy5cbiAgLy8gSWYgcm91dGVyQ29udGV4dCBpcyBub3Qgc2V0LCB0aGUgcGF0aCBhbmQgcmVzb2x2ZWQgdXJpIHdpbGwgYm90aFxuICAvLyBoYXZlIHRoZSB2YWx1ZSBvZiB0aGUgYmFzZXBhdGggcHJvcC5cbiAgY29uc3QgYmFzZSA9IHJvdXRlckNvbnRleHRcbiAgICA/IHJvdXRlckNvbnRleHQucm91dGVyQmFzZVxuICAgIDogd3JpdGFibGUoe1xuICAgICAgICBwYXRoOiBiYXNlcGF0aCxcbiAgICAgICAgdXJpOiBiYXNlcGF0aFxuICAgICAgfSk7XG5cbiAgY29uc3Qgcm91dGVyQmFzZSA9IGRlcml2ZWQoW2Jhc2UsIGFjdGl2ZVJvdXRlXSwgKFtiYXNlLCBhY3RpdmVSb3V0ZV0pID0+IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhY3RpdmVSb3V0ZSwgdGhlIHJvdXRlckJhc2Ugd2lsbCBiZSBpZGVudGljYWwgdG8gdGhlIGJhc2UuXG4gICAgaWYgKGFjdGl2ZVJvdXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBhdGg6IGJhc2VwYXRoIH0gPSBiYXNlO1xuICAgIGNvbnN0IHsgcm91dGUsIHVyaSB9ID0gYWN0aXZlUm91dGU7XG4gICAgLy8gUmVtb3ZlIHRoZSBwb3RlbnRpYWwgLyogb3IgLypzcGxhdG5hbWUgZnJvbVxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGNoaWxkIFJvdXRlcyByZWxhdGl2ZSBwYXRocy5cbiAgICBjb25zdCBwYXRoID0gcm91dGUuZGVmYXVsdCA/IGJhc2VwYXRoIDogcm91dGUucGF0aC5yZXBsYWNlKC9cXCouKiQvLCBcIlwiKTtcblxuICAgIHJldHVybiB7IHBhdGgsIHVyaSB9O1xuICB9KTtcblxuICBmdW5jdGlvbiByZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgY29uc3QgeyBwYXRoOiBiYXNlcGF0aCB9ID0gJGJhc2U7XG4gICAgbGV0IHsgcGF0aCB9ID0gcm91dGU7XG5cbiAgICAvLyBXZSBzdG9yZSB0aGUgb3JpZ2luYWwgcGF0aCBpbiB0aGUgX3BhdGggcHJvcGVydHkgc28gd2UgY2FuIHJldXNlXG4gICAgLy8gaXQgd2hlbiB0aGUgYmFzZXBhdGggY2hhbmdlcy4gVGhlIG9ubHkgdGhpbmcgdGhhdCBtYXR0ZXJzIGlzIHRoYXRcbiAgICAvLyB0aGUgcm91dGUgcmVmZXJlbmNlIGlzIGludGFjdCwgc28gbXV0YXRpb24gaXMgZmluZS5cbiAgICByb3V0ZS5fcGF0aCA9IHBhdGg7XG4gICAgcm91dGUucGF0aCA9IGNvbWJpbmVQYXRocyhiYXNlcGF0aCwgcGF0aCk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gSW4gU1NSIHdlIHNob3VsZCBzZXQgdGhlIGFjdGl2ZVJvdXRlIGltbWVkaWF0ZWx5IGlmIGl0IGlzIGEgbWF0Y2guXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBSb3V0ZXMgYmVpbmcgcmVnaXN0ZXJlZCBhZnRlciBhIG1hdGNoIGlzIGZvdW5kLFxuICAgICAgLy8gd2UganVzdCBza2lwIHRoZW0uXG4gICAgICBpZiAoaGFzQWN0aXZlUm91dGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaGluZ1JvdXRlID0gbWF0Y2gocm91dGUsICRsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hpbmdSb3V0ZSkge1xuICAgICAgICBhY3RpdmVSb3V0ZS5zZXQobWF0Y2hpbmdSb3V0ZSk7XG4gICAgICAgIGhhc0FjdGl2ZVJvdXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVzLnVwZGF0ZShycyA9PiB7XG4gICAgICAgIHJzLnB1c2gocm91dGUpO1xuICAgICAgICByZXR1cm4gcnM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICByb3V0ZXMudXBkYXRlKHJzID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcnMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICBycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHJzO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVGhpcyByZWFjdGl2ZSBzdGF0ZW1lbnQgd2lsbCB1cGRhdGUgYWxsIHRoZSBSb3V0ZXMnIHBhdGggd2hlblxuICAvLyB0aGUgYmFzZXBhdGggY2hhbmdlcy5cbiAgJDoge1xuICAgIGNvbnN0IHsgcGF0aDogYmFzZXBhdGggfSA9ICRiYXNlO1xuICAgIHJvdXRlcy51cGRhdGUocnMgPT4ge1xuICAgICAgcnMuZm9yRWFjaChyID0+IChyLnBhdGggPSBjb21iaW5lUGF0aHMoYmFzZXBhdGgsIHIuX3BhdGgpKSk7XG4gICAgICByZXR1cm4gcnM7XG4gICAgfSk7XG4gIH1cbiAgLy8gVGhpcyByZWFjdGl2ZSBzdGF0ZW1lbnQgd2lsbCBiZSBydW4gd2hlbiB0aGUgUm91dGVyIGlzIGNyZWF0ZWRcbiAgLy8gd2hlbiB0aGVyZSBhcmUgbm8gUm91dGVzIGFuZCB0aGVuIGFnYWluIHRoZSBmb2xsb3dpbmcgdGljaywgc28gaXRcbiAgLy8gd2lsbCBub3QgZmluZCBhbiBhY3RpdmUgUm91dGUgaW4gU1NSIGFuZCBpbiB0aGUgYnJvd3NlciBpdCB3aWxsIG9ubHlcbiAgLy8gcGljayBhbiBhY3RpdmUgUm91dGUgYWZ0ZXIgYWxsIFJvdXRlcyBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cbiAgJDoge1xuICAgIGNvbnN0IGJlc3RNYXRjaCA9IHBpY2soJHJvdXRlcywgJGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICBhY3RpdmVSb3V0ZS5zZXQoYmVzdE1hdGNoKTtcbiAgfVxuXG4gIGlmICghbG9jYXRpb25Db250ZXh0KSB7XG4gICAgLy8gVGhlIHRvcG1vc3QgUm91dGVyIGluIHRoZSB0cmVlIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZ1xuICAgIC8vIHRoZSBsb2NhdGlvbiBzdG9yZSBhbmQgc3VwcGx5aW5nIGl0IHRocm91Z2ggY29udGV4dC5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgIGNvbnN0IHVubGlzdGVuID0gZ2xvYmFsSGlzdG9yeS5saXN0ZW4oaGlzdG9yeSA9PiB7XG4gICAgICAgIGxvY2F0aW9uLnNldChoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdW5saXN0ZW47XG4gICAgfSk7XG5cbiAgICBzZXRDb250ZXh0KExPQ0FUSU9OLCBsb2NhdGlvbik7XG4gIH1cblxuICBzZXRDb250ZXh0KFJPVVRFUiwge1xuICAgIGFjdGl2ZVJvdXRlLFxuICAgIGJhc2UsXG4gICAgcm91dGVyQmFzZSxcbiAgICByZWdpc3RlclJvdXRlLFxuICAgIHVucmVnaXN0ZXJSb3V0ZVxuICB9KTtcbjwvc2NyaXB0PlxuXG48c2xvdD48L3Nsb3Q+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0LCBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IFJPVVRFUiwgTE9DQVRJT04gfSBmcm9tIFwiLi9jb250ZXh0cy5qc1wiO1xuXG4gIGV4cG9ydCBsZXQgcGF0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgY29tcG9uZW50ID0gbnVsbDtcblxuICBjb25zdCB7IHJlZ2lzdGVyUm91dGUsIHVucmVnaXN0ZXJSb3V0ZSwgYWN0aXZlUm91dGUgfSA9IGdldENvbnRleHQoUk9VVEVSKTtcbiAgY29uc3QgbG9jYXRpb24gPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcblxuICBjb25zdCByb3V0ZSA9IHtcbiAgICBwYXRoLFxuICAgIC8vIElmIG5vIHBhdGggcHJvcCBpcyBnaXZlbiwgdGhpcyBSb3V0ZSB3aWxsIGFjdCBhcyB0aGUgZGVmYXVsdCBSb3V0ZVxuICAgIC8vIHRoYXQgaXMgcmVuZGVyZWQgaWYgbm8gb3RoZXIgUm91dGUgaW4gdGhlIFJvdXRlciBpcyBhIG1hdGNoLlxuICAgIGRlZmF1bHQ6IHBhdGggPT09IFwiXCJcbiAgfTtcbiAgbGV0IHJvdXRlUGFyYW1zID0ge307XG4gIGxldCByb3V0ZVByb3BzID0ge307XG5cbiAgJDogaWYgKCRhY3RpdmVSb3V0ZSAmJiAkYWN0aXZlUm91dGUucm91dGUgPT09IHJvdXRlKSB7XG4gICAgcm91dGVQYXJhbXMgPSAkYWN0aXZlUm91dGUucGFyYW1zO1xuICB9XG5cbiAgJDoge1xuICAgIGNvbnN0IHsgcGF0aCwgY29tcG9uZW50LCAuLi5yZXN0IH0gPSAkJHByb3BzO1xuICAgIHJvdXRlUHJvcHMgPSByZXN0O1xuICB9XG5cbiAgcmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG5cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1bnJlZ2lzdGVyIFJvdXRlcyBpbiBTU1Igc2luY2UgaXQgd2lsbCBhbGwgYmVcbiAgLy8gdGhyb3duIGF3YXkgYW55d2F5LlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9XG48L3NjcmlwdD5cblxueyNpZiAkYWN0aXZlUm91dGUgIT09IG51bGwgJiYgJGFjdGl2ZVJvdXRlLnJvdXRlID09PSByb3V0ZX1cbiAgeyNpZiBjb21wb25lbnQgIT09IG51bGx9XG4gICAgPHN2ZWx0ZTpjb21wb25lbnQgdGhpcz1cIntjb21wb25lbnR9XCIgbG9jYXRpb249eyRsb2NhdGlvbn0gey4uLnJvdXRlUGFyYW1zfSB7Li4ucm91dGVQcm9wc30gIC8+XG4gIHs6ZWxzZX1cbiAgICA8c2xvdCBwYXJhbXM9XCJ7cm91dGVQYXJhbXN9XCIgbG9jYXRpb249eyRsb2NhdGlvbn0+PC9zbG90PlxuICB7L2lmfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgUk9VVEVSLCBMT0NBVElPTiB9IGZyb20gXCIuL2NvbnRleHRzLmpzXCI7XG4gIGltcG9ydCB7IG5hdmlnYXRlIH0gZnJvbSBcIi4vaGlzdG9yeS5qc1wiO1xuICBpbXBvcnQgeyBzdGFydHNXaXRoLCByZXNvbHZlLCBzaG91bGROYXZpZ2F0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbiAgZXhwb3J0IGxldCB0byA9IFwiI1wiO1xuICBleHBvcnQgbGV0IHJlcGxhY2UgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBzdGF0ZSA9IHt9O1xuICBleHBvcnQgbGV0IGdldFByb3BzID0gKCkgPT4gKHt9KTtcblxuICBjb25zdCB7IGJhc2UgfSA9IGdldENvbnRleHQoUk9VVEVSKTtcbiAgY29uc3QgbG9jYXRpb24gPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBsZXQgaHJlZiwgaXNQYXJ0aWFsbHlDdXJyZW50LCBpc0N1cnJlbnQsIHByb3BzO1xuICAkOiBocmVmID0gdG8gPT09IFwiL1wiID8gJGJhc2UudXJpIDogcmVzb2x2ZSh0bywgJGJhc2UudXJpKTtcbiAgJDogaXNQYXJ0aWFsbHlDdXJyZW50ID0gc3RhcnRzV2l0aCgkbG9jYXRpb24ucGF0aG5hbWUsIGhyZWYpO1xuICAkOiBpc0N1cnJlbnQgPSBocmVmID09PSAkbG9jYXRpb24ucGF0aG5hbWU7XG4gICQ6IGFyaWFDdXJyZW50ID0gaXNDdXJyZW50ID8gXCJwYWdlXCIgOiB1bmRlZmluZWQ7XG4gICQ6IHByb3BzID0gZ2V0UHJvcHMoe1xuICAgIGxvY2F0aW9uOiAkbG9jYXRpb24sXG4gICAgaHJlZixcbiAgICBpc1BhcnRpYWxseUN1cnJlbnQsXG4gICAgaXNDdXJyZW50XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBkaXNwYXRjaChcImNsaWNrXCIsIGV2ZW50KTtcblxuICAgIGlmIChzaG91bGROYXZpZ2F0ZShldmVudCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBEb24ndCBwdXNoIGFub3RoZXIgZW50cnkgdG8gdGhlIGhpc3Rvcnkgc3RhY2sgd2hlbiB0aGUgdXNlclxuICAgICAgLy8gY2xpY2tzIG9uIGEgTGluayB0byB0aGUgcGFnZSB0aGV5IGFyZSBjdXJyZW50bHkgb24uXG4gICAgICBjb25zdCBzaG91bGRSZXBsYWNlID0gJGxvY2F0aW9uLnBhdGhuYW1lID09PSBocmVmIHx8IHJlcGxhY2U7XG4gICAgICBuYXZpZ2F0ZShocmVmLCB7IHN0YXRlLCByZXBsYWNlOiBzaG91bGRSZXBsYWNlIH0pO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxhIGhyZWY9XCJ7aHJlZn1cIiBhcmlhLWN1cnJlbnQ9XCJ7YXJpYUN1cnJlbnR9XCIgb246Y2xpY2s9XCJ7b25DbGlja31cIiB7Li4ucHJvcHN9PlxuICA8c2xvdD48L3Nsb3Q+XG48L2E+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgTmF2YmFyIGZyb20gJy4uL2NvbXBvbmVudHMvTmF2YmFyLnN2ZWx0ZSdcbiAgaW1wb3J0IFRhYmJhciBmcm9tICcuLi9jb21wb25lbnRzL1RhYmJhci5zdmVsdGUnXG4gIGltcG9ydCBQcm9maWxlSGVhZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvUHJvZmlsZUhlYWRlci5zdmVsdGUnXG4gIGltcG9ydCBBYm91dCBmcm9tICcuLi9jb21wb25lbnRzL0Fib3V0LnN2ZWx0ZSdcbiAgaW1wb3J0IHsgdXNlcm5hbWUgfSBmcm9tICcuL3N0b3Jlcy5qcydcbiAgaW1wb3J0IHsgUm91dGVyLCBMaW5rLCBSb3V0ZSB9IGZyb20gJ3N2ZWx0ZS1yb3V0aW5nJ1xuXG4gIGxldCB1c2VybmFtZV92YWx1ZVxuXG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gdXNlcm5hbWUuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgIHVzZXJuYW1lX3ZhbHVlID0gdmFsdWVcbiAgfSlcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT5Qcm9maWxlIDo6IFN0ZWFtIE1vYmlsZTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48TmF2YmFyIHRpdGxlPVwiUHJvZmlsZVwiIC8+XG48ZGl2IGlkPVwicHJvZmlsZVwiPlxuICA8UHJvZmlsZUhlYWRlclxuICAgIG5hbWU9e3VzZXJuYW1lX3ZhbHVlfVxuICAgIGFsaWFzPVwiYmluZ290aGVzbGF5ZXJcIlxuICAgIHByb2ZpbGVwaWN0dXJlPVwicHJvZmlsZXBpY3R1cmUuanBnXCJcbiAgICBsZXZlbD1cIjQwXCIgLz5cbiAgPGRpdiBpZD1cIm5hdnRyYXlcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VsZWN0ZWRcIj5BYm91dDwvZGl2PlxuICAgIDxkaXY+QWN0aXZpdHk8L2Rpdj5cbiAgICA8ZGl2PkludmVudG9yeTwvZGl2PlxuICA8L2Rpdj5cbiAgPGRpdiBpZD1cImNvbnRhaW5lclwiPlxuICAgIDxBYm91dCAvPlxuICA8L2Rpdj5cbjwvZGl2PlxuPFRhYmJhciBsb2NhdGlvbj17Mn0gLz5cblxuPHN0eWxlPlxuICAjY29udGFpbmVyIHtcbiAgICBwYWRkaW5nOiAyMHB4IDMwcHg7XG4gIH1cblxuICAjcHJvZmlsZSB7XG4gICAgcGFkZGluZzogNjBweCAwcHg7XG4gIH1cblxuICAjbmF2dHJheSB7XG4gICAgcGFkZGluZzogMHB4IDMwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgfVxuXG4gICNuYXZ0cmF5IGRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzBmMGIyMDtcbiAgICB3aWR0aDogMjIlO1xuICAgIGhlaWdodDogMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG5cbiAgLnNlbGVjdGVkIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjMDI3YWZmO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
