import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, a as space, t as text, c as claim_element, b as children, f as detach_dev, g as claim_space, h as claim_text, j as attr_dev, l as add_location, k as set_style, m as insert_dev, n as append_dev, o as set_data_dev, p as noop, q as create_component, u as claim_component, w as mount_component, x as transition_in, y as transition_out, z as destroy_component, B as create_slot, K as getContext, L as validate_store, M as component_subscribe, J as writable, N as derived, O as onMount, P as setContext, H as get_slot_context, I as get_slot_changes, Q as onDestroy, R as assign, T as exclude_internal_props, U as empty, V as group_outros, W as check_outros, X as get_spread_update, Y as get_spread_object, C as createEventDispatcher, Z as set_attributes, F as listen_dev, r as query_selector_all } from './client.491f0882.js';
import { N as Navbar, T as Tabbar } from './Tabbar.1852381b.js';
import { u as username } from './stores.ff8ea292.js';

/* src/components/ProfileHeader.svelte generated by Svelte v3.22.2 */

const file = "src/components/ProfileHeader.svelte";

function create_fragment(ctx) {
	let main;
	let div8;
	let div0;
	let t0;
	let div5;
	let div4;
	let div1;
	let t1;
	let div2;
	let h3;
	let t2;
	let t3;
	let h5;
	let t4;
	let t5;
	let div3;
	let t6;
	let t7;
	let div6;
	let t8;
	let div7;

	const block = {
		c: function create() {
			main = element("main");
			div8 = element("div");
			div0 = element("div");
			t0 = space();
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			h3 = element("h3");
			t2 = text(/*alias*/ ctx[0]);
			t3 = space();
			h5 = element("h5");
			t4 = text(/*name*/ ctx[1]);
			t5 = space();
			div3 = element("div");
			t6 = text(/*level*/ ctx[3]);
			t7 = space();
			div6 = element("div");
			t8 = space();
			div7 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", {});
			var main_nodes = children(main);
			div8 = claim_element(main_nodes, "DIV", { id: true, class: true });
			var div8_nodes = children(div8);
			div0 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(div8_nodes);
			div5 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			div1 = claim_element(div4_nodes, "DIV", { id: true, style: true, class: true });
			children(div1).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*alias*/ ctx[0]);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			h5 = claim_element(div2_nodes, "H5", { class: true });
			var h5_nodes = children(h5);
			t4 = claim_text(h5_nodes, /*name*/ ctx[1]);
			h5_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t5 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			t6 = claim_text(div3_nodes, /*level*/ ctx[3]);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t7 = claim_space(div8_nodes);
			div6 = claim_element(div8_nodes, "DIV", { id: true, style: true, class: true });
			children(div6).forEach(detach_dev);
			t8 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", { id: true, class: true });
			children(div7).forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "id", "layer1");
			attr_dev(div0, "class", "svelte-15zeztu");
			add_location(div0, file, 6, 4, 97);
			attr_dev(div1, "id", "profilepicture");
			set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			attr_dev(div1, "class", "svelte-15zeztu");
			add_location(div1, file, 9, 8, 180);
			attr_dev(h3, "class", "svelte-15zeztu");
			add_location(h3, file, 13, 10, 315);
			attr_dev(h5, "class", "svelte-15zeztu");
			add_location(h5, file, 14, 10, 342);
			attr_dev(div2, "id", "userinfo");
			attr_dev(div2, "class", "svelte-15zeztu");
			add_location(div2, file, 12, 8, 285);
			attr_dev(div3, "id", "level");
			attr_dev(div3, "class", "svelte-15zeztu");
			add_location(div3, file, 17, 8, 443);
			attr_dev(div4, "id", "content");
			attr_dev(div4, "class", "svelte-15zeztu");
			add_location(div4, file, 8, 6, 153);
			attr_dev(div5, "id", "contentwrapper");
			attr_dev(div5, "class", "svelte-15zeztu");
			add_location(div5, file, 7, 4, 121);
			attr_dev(div6, "id", "layer2");
			set_style(div6, "background-image", "url(gta.jpg)");
			attr_dev(div6, "class", "svelte-15zeztu");
			add_location(div6, file, 21, 4, 563);
			attr_dev(div7, "id", "layer3");
			attr_dev(div7, "class", "svelte-15zeztu");
			add_location(div7, file, 22, 4, 627);
			attr_dev(div8, "id", "head");
			attr_dev(div8, "class", "svelte-15zeztu");
			add_location(div8, file, 5, 2, 77);
			add_location(main, file, 4, 0, 68);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			append_dev(main, div8);
			append_dev(div8, div0);
			append_dev(div8, t0);
			append_dev(div8, div5);
			append_dev(div5, div4);
			append_dev(div4, div1);
			append_dev(div4, t1);
			append_dev(div4, div2);
			append_dev(div2, h3);
			append_dev(h3, t2);
			append_dev(div2, t3);
			append_dev(div2, h5);
			append_dev(h5, t4);
			append_dev(div4, t5);
			append_dev(div4, div3);
			append_dev(div3, t6);
			append_dev(div8, t7);
			append_dev(div8, div6);
			append_dev(div8, t8);
			append_dev(div8, div7);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*profilepicture*/ 4) {
				set_style(div1, "background-image", "url(" + /*profilepicture*/ ctx[2] + ")");
			}

			if (dirty & /*alias*/ 1) set_data_dev(t2, /*alias*/ ctx[0]);
			if (dirty & /*name*/ 2) set_data_dev(t4, /*name*/ ctx[1]);
			if (dirty & /*level*/ 8) set_data_dev(t6, /*level*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { alias } = $$props,
		{ name } = $$props,
		{ profilepicture } = $$props,
		{ level } = $$props;

	const writable_props = ["alias", "name", "profilepicture", "level"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProfileHeader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ProfileHeader", $$slots, []);

	$$self.$set = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	$$self.$capture_state = () => ({ alias, name, profilepicture, level });

	$$self.$inject_state = $$props => {
		if ("alias" in $$props) $$invalidate(0, alias = $$props.alias);
		if ("name" in $$props) $$invalidate(1, name = $$props.name);
		if ("profilepicture" in $$props) $$invalidate(2, profilepicture = $$props.profilepicture);
		if ("level" in $$props) $$invalidate(3, level = $$props.level);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [alias, name, profilepicture, level];
}

class ProfileHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			alias: 0,
			name: 1,
			profilepicture: 2,
			level: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProfileHeader",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*alias*/ ctx[0] === undefined && !("alias" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'alias'");
		}

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'name'");
		}

		if (/*profilepicture*/ ctx[2] === undefined && !("profilepicture" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'profilepicture'");
		}

		if (/*level*/ ctx[3] === undefined && !("level" in props)) {
			console.warn("<ProfileHeader> was created without expected prop 'level'");
		}
	}

	get alias() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alias(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get profilepicture() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set profilepicture(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level() {
		throw new Error("<ProfileHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level(value) {
		throw new Error("<ProfileHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/AboutMeTile.svelte generated by Svelte v3.22.2 */

const file$1 = "src/components/AboutMeTile.svelte";

function create_fragment$1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, "Hidetaka Miyazaki is god. Change my mind. Dank Souls has the best lore in any\n  videogame. Waiting for Elden Ring.");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", "aboutme");
			attr_dev(div, "class", "svelte-3tnd7d");
			add_location(div, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AboutMeTile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AboutMeTile", $$slots, []);
	return [];
}

class AboutMeTile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AboutMeTile",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/MainBadge.svelte generated by Svelte v3.22.2 */

const file$2 = "src/components/MainBadge.svelte";

function create_fragment$2(ctx) {
	let div1;
	let img;
	let img_src_value;
	let t0;
	let div0;
	let h2;
	let t1;
	let t2;
	let h4;
	let t3;

	const block = {
		c: function create() {
			div1 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			h2 = element("h2");
			t1 = text("Years of Service");
			t2 = space();
			h4 = element("h4");
			t3 = text("250 XP");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			img = claim_element(div1_nodes, "IMG", { src: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Years of Service");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			h4 = claim_element(div0_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t3 = claim_text(h4_nodes, "250 XP");
			h4_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "https://steamcommunity-a.akamaihd.net/public/images/badges/02_years/steamyears5_54.png")) attr_dev(img, "src", img_src_value);
			add_location(img, file$2, 1, 2, 23);
			attr_dev(h2, "class", "svelte-vmk8bb");
			add_location(h2, file$2, 4, 4, 159);
			attr_dev(h4, "class", "svelte-vmk8bb");
			add_location(h4, file$2, 5, 4, 189);
			attr_dev(div0, "id", "badgemaininfo");
			attr_dev(div0, "class", "svelte-vmk8bb");
			add_location(div0, file$2, 3, 2, 130);
			attr_dev(div1, "id", "badgemain");
			attr_dev(div1, "class", "svelte-vmk8bb");
			add_location(div1, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h2);
			append_dev(h2, t1);
			append_dev(div0, t2);
			append_dev(div0, h4);
			append_dev(h4, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MainBadge> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MainBadge", $$slots, []);
	return [];
}

class MainBadge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MainBadge",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/components/Showcase.svelte generated by Svelte v3.22.2 */

const file$3 = "src/components/Showcase.svelte";

function create_fragment$3(ctx) {
	let div;
	let img0;
	let img0_src_value;
	let t0;
	let img1;
	let img1_src_value;
	let t1;
	let img2;
	let img2_src_value;
	let t2;
	let img3;
	let img3_src_value;
	let t3;
	let img4;
	let img4_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img0 = element("img");
			t0 = space();
			img1 = element("img");
			t1 = space();
			img2 = element("img");
			t2 = space();
			img3 = element("img");
			t3 = space();
			img4 = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			img0 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t0 = claim_space(div_nodes);
			img1 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t1 = claim_space(div_nodes);
			img2 = claim_element(div_nodes, "IMG", { src: true, class: true });
			t2 = claim_space(div_nodes);
			img3 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			t3 = claim_space(div_nodes);
			img4 = claim_element(div_nodes, "IMG", { src: true, style: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img0.src !== (img0_src_value = /*images*/ ctx[0][0].link)) attr_dev(img0, "src", img0_src_value);
			set_style(img0, "height", "32px");
			attr_dev(img0, "class", "svelte-soube2");
			add_location(img0, file$3, 4, 2, 67);
			if (img1.src !== (img1_src_value = /*images*/ ctx[0][1].link)) attr_dev(img1, "src", img1_src_value);
			set_style(img1, "height", "32px");
			attr_dev(img1, "class", "svelte-soube2");
			add_location(img1, file$3, 5, 2, 122);
			if (img2.src !== (img2_src_value = /*images*/ ctx[0][2].link)) attr_dev(img2, "src", img2_src_value);
			attr_dev(img2, "class", "svelte-soube2");
			add_location(img2, file$3, 6, 2, 177);
			if (img3.src !== (img3_src_value = /*images*/ ctx[0][3].link)) attr_dev(img3, "src", img3_src_value);
			set_style(img3, "height", "36px");
			attr_dev(img3, "class", "svelte-soube2");
			add_location(img3, file$3, 7, 2, 210);
			if (img4.src !== (img4_src_value = /*images*/ ctx[0][4].link)) attr_dev(img4, "src", img4_src_value);
			set_style(img4, "height", "38px");
			attr_dev(img4, "class", "svelte-soube2");
			add_location(img4, file$3, 8, 2, 265);
			attr_dev(div, "id", "badgeshowcase");
			attr_dev(div, "class", "svelte-soube2");
			add_location(div, file$3, 3, 0, 40);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img0);
			append_dev(div, t0);
			append_dev(div, img1);
			append_dev(div, t1);
			append_dev(div, img2);
			append_dev(div, t2);
			append_dev(div, img3);
			append_dev(div, t3);
			append_dev(div, img4);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*images*/ 1 && img0.src !== (img0_src_value = /*images*/ ctx[0][0].link)) {
				attr_dev(img0, "src", img0_src_value);
			}

			if (dirty & /*images*/ 1 && img1.src !== (img1_src_value = /*images*/ ctx[0][1].link)) {
				attr_dev(img1, "src", img1_src_value);
			}

			if (dirty & /*images*/ 1 && img2.src !== (img2_src_value = /*images*/ ctx[0][2].link)) {
				attr_dev(img2, "src", img2_src_value);
			}

			if (dirty & /*images*/ 1 && img3.src !== (img3_src_value = /*images*/ ctx[0][3].link)) {
				attr_dev(img3, "src", img3_src_value);
			}

			if (dirty & /*images*/ 1 && img4.src !== (img4_src_value = /*images*/ ctx[0][4].link)) {
				attr_dev(img4, "src", img4_src_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { images } = $$props;
	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Showcase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Showcase", $$slots, []);

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	$$self.$capture_state = () => ({ images });

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(0, images = $$props.images);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [images];
}

class Showcase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { images: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Showcase",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*images*/ ctx[0] === undefined && !("images" in props)) {
			console.warn("<Showcase> was created without expected prop 'images'");
		}
	}

	get images() {
		throw new Error("<Showcase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<Showcase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Badges.svelte generated by Svelte v3.22.2 */
const file$4 = "src/components/Badges.svelte";

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;
	let t3;
	let t4;
	let current;
	const mainbadge = new MainBadge({ $$inline: true });

	const showcase = new Showcase({
			props: {
				images: [
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/37_summer2019/level25_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/730/54e40b9e2288fbab8bd4c6537b0325d405c7e1b0.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/28_springcleaning2018/bronze_80.png"
					},
					{
						link: "https://steamcdn-a.akamaihd.net/steamcommunity/public/images/items/762800/d467ec8eaed4643c47fbed43ed781daef2525963.png"
					},
					{
						link: "https://steamcommunity-a.akamaihd.net/public/images/badges/27_steamawardnominations/level04_80.png"
					}
				]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text("Badges");
			t1 = space();
			h2 = element("h2");
			t2 = text("8");
			t3 = space();
			create_component(mainbadge.$$.fragment);
			t4 = space();
			create_component(showcase.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Badges");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "8");
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			claim_component(mainbadge.$$.fragment, div1_nodes);
			t4 = claim_space(div1_nodes);
			claim_component(showcase.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$4, 7, 4, 149);
			add_location(h2, file$4, 8, 4, 169);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-1ye7e9i");
			add_location(div0, file$4, 6, 2, 128);
			attr_dev(div1, "id", "badges");
			attr_dev(div1, "class", "svelte-1ye7e9i");
			add_location(div1, file$4, 5, 0, 108);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
			append_dev(div1, t3);
			mount_component(mainbadge, div1, null);
			append_dev(div1, t4);
			mount_component(showcase, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(mainbadge.$$.fragment, local);
			transition_in(showcase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mainbadge.$$.fragment, local);
			transition_out(showcase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(mainbadge);
			destroy_component(showcase);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Badges> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Badges", $$slots, []);
	$$self.$capture_state = () => ({ MainBadge, Showcase });
	return [];
}

class Badges extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badges",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/components/Friends.svelte generated by Svelte v3.22.2 */

const file$5 = "src/components/Friends.svelte";

function create_fragment$5(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text("Friends");
			t1 = space();
			h2 = element("h2");
			t2 = text("72");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Friends");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "72");
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$5, 6, 4, 65);
			add_location(h2, file$5, 7, 4, 86);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-un30hq");
			add_location(div0, file$5, 5, 2, 44);
			attr_dev(div1, "id", "friends");
			attr_dev(div1, "class", "svelte-un30hq");
			add_location(div1, file$5, 4, 0, 23);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Friends> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Friends", $$slots, []);
	return [];
}

class Friends extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Friends",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/components/Groups.svelte generated by Svelte v3.22.2 */

const file$6 = "src/components/Groups.svelte";

function create_fragment$6(ctx) {
	let div1;
	let div0;
	let h3;
	let t0;
	let t1;
	let h2;
	let t2;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			h3 = element("h3");
			t0 = text("Group");
			t1 = space();
			h2 = element("h2");
			t2 = text("3");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
			var div0_nodes = children(div0);
			h3 = claim_element(div0_nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Group");
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			h2 = claim_element(div0_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "3");
			h2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$6, 2, 4, 42);
			add_location(h2, file$6, 3, 4, 61);
			attr_dev(div0, "id", "title");
			attr_dev(div0, "class", "svelte-b52dg2");
			add_location(div0, file$6, 1, 2, 21);
			attr_dev(div1, "id", "friends");
			attr_dev(div1, "class", "svelte-b52dg2");
			add_location(div1, file$6, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);
			append_dev(div0, h2);
			append_dev(h2, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Groups> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Groups", $$slots, []);
	return [];
}

class Groups extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Groups",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/components/About.svelte generated by Svelte v3.22.2 */
const file$7 = "src/components/About.svelte";

function create_fragment$7(ctx) {
	let main;
	let t0;
	let t1;
	let t2;
	let current;
	const aboutmetile = new AboutMeTile({ $$inline: true });
	const badges = new Badges({ $$inline: true });
	const friends = new Friends({ $$inline: true });
	const groups = new Groups({ $$inline: true });

	const block = {
		c: function create() {
			main = element("main");
			create_component(aboutmetile.$$.fragment);
			t0 = space();
			create_component(badges.$$.fragment);
			t1 = space();
			create_component(friends.$$.fragment);
			t2 = space();
			create_component(groups.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(aboutmetile.$$.fragment, main_nodes);
			t0 = claim_space(main_nodes);
			claim_component(badges.$$.fragment, main_nodes);
			t1 = claim_space(main_nodes);
			claim_component(friends.$$.fragment, main_nodes);
			t2 = claim_space(main_nodes);
			claim_component(groups.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "svelte-171qr0s");
			add_location(main, file$7, 9, 0, 275);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(aboutmetile, main, null);
			append_dev(main, t0);
			mount_component(badges, main, null);
			append_dev(main, t1);
			mount_component(friends, main, null);
			append_dev(main, t2);
			mount_component(groups, main, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(aboutmetile.$$.fragment, local);
			transition_in(badges.$$.fragment, local);
			transition_in(friends.$$.fragment, local);
			transition_in(groups.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(aboutmetile.$$.fragment, local);
			transition_out(badges.$$.fragment, local);
			transition_out(friends.$$.fragment, local);
			transition_out(groups.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(aboutmetile);
			destroy_component(badges);
			destroy_component(friends);
			destroy_component(groups);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("About", $$slots, []);
	$$self.$capture_state = () => ({ AboutMeTile, Badges, Friends, Groups });
	return [];
}

class About extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: create_fragment$7.name
		});
	}
}

const LOCATION = {};
const ROUTER = {};

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

function getLocation(source) {
  return {
    ...source.location,
    state: source.history.state,
    key: (source.history.state && source.history.state.key) || "initial"
  };
}

function createHistory(source, options) {
  const listeners = [];
  let location = getLocation(source);

  return {
    get location() {
      return location;
    },

    listen(listener) {
      listeners.push(listener);

      const popstateListener = () => {
        location = getLocation(source);
        listener({ location, action: "POP" });
      };

      source.addEventListener("popstate", popstateListener);

      return () => {
        source.removeEventListener("popstate", popstateListener);

        const index = listeners.indexOf(listener);
        listeners.splice(index, 1);
      };
    },

    navigate(to, { state, replace = false } = {}) {
      state = { ...state, key: Date.now() + "" };
      // try...catch iOS Safari limits to 100 pushState calls
      try {
        if (replace) {
          source.history.replaceState(state, null, to);
        } else {
          source.history.pushState(state, null, to);
        }
      } catch (e) {
        source.location[replace ? "replace" : "assign"](to);
      }

      location = getLocation(source);
      listeners.forEach(listener => listener({ location, action: "PUSH" }));
    }
  };
}

// Stores history entries in memory for testing or other platforms like Native
function createMemorySource(initialPathname = "/") {
  let index = 0;
  const stack = [{ pathname: initialPathname, search: "" }];
  const states = [];

  return {
    get location() {
      return stack[index];
    },
    addEventListener(name, fn) {},
    removeEventListener(name, fn) {},
    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        index++;
        stack.push({ pathname, search });
        states.push(state);
      },
      replaceState(state, _, uri) {
        const [pathname, search = ""] = uri.split("?");
        stack[index] = { pathname, search };
        states[index] = state;
      }
    }
  };
}

// Global history uses window.history as the source if available,
// otherwise a memory history
const canUseDOM = Boolean(
  typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
);
const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
const { navigate } = globalHistory;

/**
 * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
 *
 * https://github.com/reach/router/blob/master/LICENSE
 * */

const paramRe = /^:(.+)/;

const SEGMENT_POINTS = 4;
const STATIC_POINTS = 3;
const DYNAMIC_POINTS = 2;
const SPLAT_PENALTY = 1;
const ROOT_POINTS = 1;

/**
 * Check if `string` starts with `search`
 * @param {string} string
 * @param {string} search
 * @return {boolean}
 */
function startsWith(string, search) {
  return string.substr(0, search.length) === search;
}

/**
 * Check if `segment` is a root segment
 * @param {string} segment
 * @return {boolean}
 */
function isRootSegment(segment) {
  return segment === "";
}

/**
 * Check if `segment` is a dynamic segment
 * @param {string} segment
 * @return {boolean}
 */
function isDynamic(segment) {
  return paramRe.test(segment);
}

/**
 * Check if `segment` is a splat
 * @param {string} segment
 * @return {boolean}
 */
function isSplat(segment) {
  return segment[0] === "*";
}

/**
 * Split up the URI into segments delimited by `/`
 * @param {string} uri
 * @return {string[]}
 */
function segmentize(uri) {
  return (
    uri
      // Strip starting/ending `/`
      .replace(/(^\/+|\/+$)/g, "")
      .split("/")
  );
}

/**
 * Strip `str` of potential start and end `/`
 * @param {string} str
 * @return {string}
 */
function stripSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
}

/**
 * Score a route depending on how its individual segments look
 * @param {object} route
 * @param {number} index
 * @return {object}
 */
function rankRoute(route, index) {
  const score = route.default
    ? 0
    : segmentize(route.path).reduce((score, segment) => {
        score += SEGMENT_POINTS;

        if (isRootSegment(segment)) {
          score += ROOT_POINTS;
        } else if (isDynamic(segment)) {
          score += DYNAMIC_POINTS;
        } else if (isSplat(segment)) {
          score -= SEGMENT_POINTS + SPLAT_PENALTY;
        } else {
          score += STATIC_POINTS;
        }

        return score;
      }, 0);

  return { route, score, index };
}

/**
 * Give a score to all routes and sort them on that
 * @param {object[]} routes
 * @return {object[]}
 */
function rankRoutes(routes) {
  return (
    routes
      .map(rankRoute)
      // If two routes have the exact same score, we go by index instead
      .sort((a, b) =>
        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
      )
  );
}

/**
 * Ranks and picks the best route to match. Each segment gets the highest
 * amount of points, then the type of segment gets an additional amount of
 * points where
 *
 *  static > dynamic > splat > root
 *
 * This way we don't have to worry about the order of our routes, let the
 * computers do it.
 *
 * A route looks like this
 *
 *  { path, default, value }
 *
 * And a returned match looks like:
 *
 *  { route, params, uri }
 *
 * @param {object[]} routes
 * @param {string} uri
 * @return {?object}
 */
function pick(routes, uri) {
  let match;
  let default_;

  const [uriPathname] = uri.split("?");
  const uriSegments = segmentize(uriPathname);
  const isRootUri = uriSegments[0] === "";
  const ranked = rankRoutes(routes);

  for (let i = 0, l = ranked.length; i < l; i++) {
    const route = ranked[i].route;
    let missed = false;

    if (route.default) {
      default_ = {
        route,
        params: {},
        uri
      };
      continue;
    }

    const routeSegments = segmentize(route.path);
    const params = {};
    const max = Math.max(uriSegments.length, routeSegments.length);
    let index = 0;

    for (; index < max; index++) {
      const routeSegment = routeSegments[index];
      const uriSegment = uriSegments[index];

      if (routeSegment !== undefined && isSplat(routeSegment)) {
        // Hit a splat, just grab the rest, and return a match
        // uri:   /files/documents/work
        // route: /files/* or /files/*splatname
        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

        params[splatName] = uriSegments
          .slice(index)
          .map(decodeURIComponent)
          .join("/");
        break;
      }

      if (uriSegment === undefined) {
        // URI is shorter than the route, no match
        // uri:   /users
        // route: /users/:userId
        missed = true;
        break;
      }

      let dynamicMatch = paramRe.exec(routeSegment);

      if (dynamicMatch && !isRootUri) {
        const value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        // Current segments don't match, not dynamic, not splat, so no match
        // uri:   /users/123/settings
        // route: /users/:id/profile
        missed = true;
        break;
      }
    }

    if (!missed) {
      match = {
        route,
        params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }

  return match || default_ || null;
}

/**
 * Check if the `path` matches the `uri`.
 * @param {string} path
 * @param {string} uri
 * @return {?object}
 */
function match(route, uri) {
  return pick([route], uri);
}

/**
 * Add the query to the pathname if a query is given
 * @param {string} pathname
 * @param {string} [query]
 * @return {string}
 */
function addQuery(pathname, query) {
  return pathname + (query ? `?${query}` : "");
}

/**
 * Resolve URIs as though every path is a directory, no files. Relative URIs
 * in the browser can feel awkward because not only can you be "in a directory",
 * you can be "at a file", too. For example:
 *
 *  browserSpecResolve('foo', '/bar/') => /bar/foo
 *  browserSpecResolve('foo', '/bar') => /foo
 *
 * But on the command line of a file system, it's not as complicated. You can't
 * `cd` from a file, only directories. This way, links have to know less about
 * their current path. To go deeper you can do this:
 *
 *  <Link to="deeper"/>
 *  // instead of
 *  <Link to=`{${props.uri}/deeper}`/>
 *
 * Just like `cd`, if you want to go deeper from the command line, you do this:
 *
 *  cd deeper
 *  # not
 *  cd $(pwd)/deeper
 *
 * By treating every path as a directory, linking to relative paths should
 * require less contextual information and (fingers crossed) be more intuitive.
 * @param {string} to
 * @param {string} base
 * @return {string}
 */
function resolve(to, base) {
  // /foo/bar, /baz/qux => /foo/bar
  if (startsWith(to, "/")) {
    return to;
  }

  const [toPathname, toQuery] = to.split("?");
  const [basePathname] = base.split("?");
  const toSegments = segmentize(toPathname);
  const baseSegments = segmentize(basePathname);

  // ?a=b, /users?b=c => /users?a=b
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }

  // profile, /users/789 => /users/789/profile
  if (!startsWith(toSegments[0], ".")) {
    const pathname = baseSegments.concat(toSegments).join("/");

    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }

  // ./       , /users/123 => /users/123
  // ../      , /users/123 => /users
  // ../..    , /users/123 => /
  // ../../one, /a/b/c/d   => /a/b/one
  // .././one , /a/b/c/d   => /a/b/c/one
  const allSegments = baseSegments.concat(toSegments);
  const segments = [];

  allSegments.forEach(segment => {
    if (segment === "..") {
      segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });

  return addQuery("/" + segments.join("/"), toQuery);
}

/**
 * Combines the `basepath` and the `path` into one path.
 * @param {string} basepath
 * @param {string} path
 */
function combinePaths(basepath, path) {
  return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
}

/**
 * Decides whether a given `event` should result in a navigation or not.
 * @param {object} event
 */
function shouldNavigate(event) {
  return (
    !event.defaultPrevented &&
    event.button === 0 &&
    !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
  );
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.22.2 */

function create_fragment$8(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let $routes;
	let { basepath = "/" } = $$props;
	let { url = null } = $$props;
	const locationContext = getContext(LOCATION);
	const routerContext = getContext(ROUTER);
	const routes = writable([]);
	validate_store(routes, "routes");
	component_subscribe($$self, routes, value => $$invalidate(8, $routes = value));
	const activeRoute = writable(null);
	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

	// If locationContext is not set, this is the topmost Router in the tree.
	// If the `url` prop is given we force the location to it.
	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(7, $location = value));

	// If routerContext is set, the routerBase of the parent Router
	// will be the base for this Router's descendants.
	// If routerContext is not set, the path and resolved uri will both
	// have the value of the basepath prop.
	const base = routerContext
	? routerContext.routerBase
	: writable({ path: basepath, uri: basepath });

	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(6, $base = value));

	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
		// If there is no activeRoute, the routerBase will be identical to the base.
		if (activeRoute === null) {
			return base;
		}

		const { path: basepath } = base;
		const { route, uri } = activeRoute;

		// Remove the potential /* or /*splatname from
		// the end of the child Routes relative paths.
		const path = route.default
		? basepath
		: route.path.replace(/\*.*$/, "");

		return { path, uri };
	});

	function registerRoute(route) {
		const { path: basepath } = $base;
		let { path } = route;

		// We store the original path in the _path property so we can reuse
		// it when the basepath changes. The only thing that matters is that
		// the route reference is intact, so mutation is fine.
		route._path = path;

		route.path = combinePaths(basepath, path);

		if (typeof window === "undefined") {
			// In SSR we should set the activeRoute immediately if it is a match.
			// If there are more Routes being registered after a match is found,
			// we just skip them.
			if (hasActiveRoute) {
				return;
			}

			const matchingRoute = match(route, $location.pathname);

			if (matchingRoute) {
				activeRoute.set(matchingRoute);
				hasActiveRoute = true;
			}
		} else {
			routes.update(rs => {
				rs.push(route);
				return rs;
			});
		}
	}

	function unregisterRoute(route) {
		routes.update(rs => {
			const index = rs.indexOf(route);
			rs.splice(index, 1);
			return rs;
		});
	}

	if (!locationContext) {
		// The topmost Router in the tree is responsible for updating
		// the location store and supplying it through context.
		onMount(() => {
			const unlisten = globalHistory.listen(history => {
				location.set(history.location);
			});

			return unlisten;
		});

		setContext(LOCATION, location);
	}

	setContext(ROUTER, {
		activeRoute,
		base,
		routerBase,
		registerRoute,
		unregisterRoute
	});

	const writable_props = ["basepath", "url"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Router", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		setContext,
		onMount,
		writable,
		derived,
		LOCATION,
		ROUTER,
		globalHistory,
		pick,
		match,
		stripSlashes,
		combinePaths,
		basepath,
		url,
		locationContext,
		routerContext,
		routes,
		activeRoute,
		hasActiveRoute,
		location,
		base,
		routerBase,
		registerRoute,
		unregisterRoute,
		$base,
		$location,
		$routes
	});

	$$self.$inject_state = $$props => {
		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
		if ("url" in $$props) $$invalidate(4, url = $$props.url);
		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$base*/ 64) {
			// This reactive statement will update all the Routes' path when
			// the basepath changes.
			 {
				const { path: basepath } = $base;

				routes.update(rs => {
					rs.forEach(r => r.path = combinePaths(basepath, r._path));
					return rs;
				});
			}
		}

		if ($$self.$$.dirty & /*$routes, $location*/ 384) {
			// This reactive statement will be run when the Router is created
			// when there are no Routes and then again the following tick, so it
			// will not find an active Route in SSR and in the browser it will only
			// pick an active Route after all Routes have been registered.
			 {
				const bestMatch = pick($routes, $location.pathname);
				activeRoute.set(bestMatch);
			}
		}
	};

	return [
		routes,
		location,
		base,
		basepath,
		url,
		hasActiveRoute,
		$base,
		$location,
		$routes,
		locationContext,
		routerContext,
		activeRoute,
		routerBase,
		registerRoute,
		unregisterRoute,
		$$scope,
		$$slots
	];
}

class Router extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { basepath: 3, url: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Router",
			options,
			id: create_fragment$8.name
		});
	}

	get basepath() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set basepath(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.22.2 */

const get_default_slot_changes = dirty => ({
	params: dirty & /*routeParams*/ 2,
	location: dirty & /*$location*/ 16
});

const get_default_slot_context = ctx => ({
	params: /*routeParams*/ ctx[1],
	location: /*$location*/ ctx[4]
});

// (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
function create_if_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*component*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
		ctx
	});

	return block;
}

// (43:2) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 4114) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes));
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(43:2) {:else}",
		ctx
	});

	return block;
}

// (41:2) {#if component !== null}
function create_if_block_1(ctx) {
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{ location: /*$location*/ ctx[4] },
		/*routeParams*/ ctx[1],
		/*routeProps*/ ctx[2]
	];

	var switch_value = /*component*/ ctx[0];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 22)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
					dirty & /*routeParams*/ 2 && get_spread_object(/*routeParams*/ ctx[1]),
					dirty & /*routeProps*/ 4 && get_spread_object(/*routeProps*/ ctx[2])
				])
			: {};

			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(41:2) {#if component !== null}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$activeRoute*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $activeRoute;
	let $location;
	let { path = "" } = $$props;
	let { component = null } = $$props;
	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
	validate_store(activeRoute, "activeRoute");
	component_subscribe($$self, activeRoute, value => $$invalidate(3, $activeRoute = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

	const route = {
		path,
		// If no path prop is given, this Route will act as the default Route
		// that is rendered if no other Route in the Router is a match.
		default: path === ""
	};

	let routeParams = {};
	let routeProps = {};
	registerRoute(route);

	// There is no need to unregister Routes in SSR since it will all be
	// thrown away anyway.
	if (typeof window !== "undefined") {
		onDestroy(() => {
			unregisterRoute(route);
		});
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Route", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		onDestroy,
		ROUTER,
		LOCATION,
		path,
		component,
		registerRoute,
		unregisterRoute,
		activeRoute,
		location,
		route,
		routeParams,
		routeProps,
		$activeRoute,
		$location
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
		if ("routeParams" in $$props) $$invalidate(1, routeParams = $$new_props.routeParams);
		if ("routeProps" in $$props) $$invalidate(2, routeProps = $$new_props.routeProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$activeRoute*/ 8) {
			 if ($activeRoute && $activeRoute.route === route) {
				$$invalidate(1, routeParams = $activeRoute.params);
			}
		}

		 {
			const { path, component, ...rest } = $$props;
			$$invalidate(2, routeProps = rest);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		component,
		routeParams,
		routeProps,
		$activeRoute,
		$location,
		activeRoute,
		location,
		route,
		path,
		registerRoute,
		unregisterRoute,
		$$props,
		$$scope,
		$$slots
	];
}

class Route extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { path: 8, component: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Route",
			options,
			id: create_fragment$9.name
		});
	}

	get path() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.22.2 */
const file$8 = "Users/rohanharikumar/node_modules/svelte-routing/src/Link.svelte";

function create_fragment$a(ctx) {
	let a;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	let a_levels = [
		{ href: /*href*/ ctx[0] },
		{ "aria-current": /*ariaCurrent*/ ctx[2] },
		/*props*/ ctx[1]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, "aria-current": true });
			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(a, a_data);
			add_location(a, file$8, 40, 0, 1249);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
			if (remount) dispose();
			dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
				}
			}

			set_attributes(a, get_spread_update(a_levels, [
				dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
				dirty & /*ariaCurrent*/ 4 && { "aria-current": /*ariaCurrent*/ ctx[2] },
				dirty & /*props*/ 2 && /*props*/ ctx[1]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let $base;
	let $location;
	let { to = "#" } = $$props;
	let { replace = false } = $$props;
	let { state = {} } = $$props;
	let { getProps = () => ({}) } = $$props;
	const { base } = getContext(ROUTER);
	validate_store(base, "base");
	component_subscribe($$self, base, value => $$invalidate(12, $base = value));
	const location = getContext(LOCATION);
	validate_store(location, "location");
	component_subscribe($$self, location, value => $$invalidate(13, $location = value));
	const dispatch = createEventDispatcher();
	let href, isPartiallyCurrent, isCurrent, props;

	function onClick(event) {
		dispatch("click", event);

		if (shouldNavigate(event)) {
			event.preventDefault();

			// Don't push another entry to the history stack when the user
			// clicks on a Link to the page they are currently on.
			const shouldReplace = $location.pathname === href || replace;

			navigate(href, { state, replace: shouldReplace });
		}
	}

	const writable_props = ["to", "replace", "state", "getProps"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Link", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		createEventDispatcher,
		ROUTER,
		LOCATION,
		navigate,
		startsWith,
		resolve,
		shouldNavigate,
		to,
		replace,
		state,
		getProps,
		base,
		location,
		dispatch,
		href,
		isPartiallyCurrent,
		isCurrent,
		props,
		onClick,
		$base,
		$location,
		ariaCurrent
	});

	$$self.$inject_state = $$props => {
		if ("to" in $$props) $$invalidate(6, to = $$props.to);
		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
		if ("state" in $$props) $$invalidate(8, state = $$props.state);
		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
		if ("href" in $$props) $$invalidate(0, href = $$props.href);
		if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$props.isPartiallyCurrent);
		if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$props.isCurrent);
		if ("props" in $$props) $$invalidate(1, props = $$props.props);
		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$props.ariaCurrent);
	};

	let ariaCurrent;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*to, $base*/ 4160) {
			 $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
		}

		if ($$self.$$.dirty & /*$location, href*/ 8193) {
			 $$invalidate(10, isPartiallyCurrent = startsWith($location.pathname, href));
		}

		if ($$self.$$.dirty & /*href, $location*/ 8193) {
			 $$invalidate(11, isCurrent = href === $location.pathname);
		}

		if ($$self.$$.dirty & /*isCurrent*/ 2048) {
			 $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
		}

		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 11777) {
			 $$invalidate(1, props = getProps({
				location: $location,
				href,
				isPartiallyCurrent,
				isCurrent
			}));
		}
	};

	return [
		href,
		props,
		ariaCurrent,
		base,
		location,
		onClick,
		to,
		replace,
		state,
		getProps,
		isPartiallyCurrent,
		isCurrent,
		$base,
		$location,
		dispatch,
		$$scope,
		$$slots
	];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { to: 6, replace: 7, state: 8, getProps: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$a.name
		});
	}

	get to() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set to(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get replace() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set replace(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getProps() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getProps(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/profile.svelte generated by Svelte v3.22.2 */
const file$9 = "src/routes/profile.svelte";

function create_fragment$b(ctx) {
	let t0;
	let t1;
	let div5;
	let t2;
	let div3;
	let div0;
	let t3;
	let t4;
	let div1;
	let t5;
	let t6;
	let div2;
	let t7;
	let t8;
	let div4;
	let t9;
	let current;

	const navbar = new Navbar({
			props: { title: "Profile" },
			$$inline: true
		});

	const profileheader = new ProfileHeader({
			props: {
				name: /*username_value*/ ctx[0],
				alias: "bingotheslayer",
				profilepicture: "profilepicture.jpg",
				level: "40"
			},
			$$inline: true
		});

	const about = new About({ $$inline: true });
	const tabbar = new Tabbar({ props: { location: 2 }, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			create_component(navbar.$$.fragment);
			t1 = space();
			div5 = element("div");
			create_component(profileheader.$$.fragment);
			t2 = space();
			div3 = element("div");
			div0 = element("div");
			t3 = text("About");
			t4 = space();
			div1 = element("div");
			t5 = text("Activity");
			t6 = space();
			div2 = element("div");
			t7 = text("Inventory");
			t8 = space();
			div4 = element("div");
			create_component(about.$$.fragment);
			t9 = space();
			create_component(tabbar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-fcey8i\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(navbar.$$.fragment, nodes);
			t1 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", { id: true, class: true });
			var div5_nodes = children(div5);
			claim_component(profileheader.$$.fragment, div5_nodes);
			t2 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t3 = claim_text(div0_nodes, "About");
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t5 = claim_text(div1_nodes, "Activity");
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t7 = claim_text(div2_nodes, "Inventory");
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t8 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { id: true, class: true });
			var div4_nodes = children(div4);
			claim_component(about.$$.fragment, div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			claim_component(tabbar.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Profile :: Steam Mobile";
			attr_dev(div0, "class", "selected svelte-1ttnfi1");
			add_location(div0, file$9, 27, 4, 711);
			attr_dev(div1, "class", "svelte-1ttnfi1");
			add_location(div1, file$9, 28, 4, 749);
			attr_dev(div2, "class", "svelte-1ttnfi1");
			add_location(div2, file$9, 29, 4, 773);
			attr_dev(div3, "id", "navtray");
			attr_dev(div3, "class", "svelte-1ttnfi1");
			add_location(div3, file$9, 26, 2, 688);
			attr_dev(div4, "id", "container");
			attr_dev(div4, "class", "svelte-1ttnfi1");
			add_location(div4, file$9, 31, 2, 805);
			attr_dev(div5, "id", "profile");
			attr_dev(div5, "class", "svelte-1ttnfi1");
			add_location(div5, file$9, 20, 0, 539);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(navbar, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div5, anchor);
			mount_component(profileheader, div5, null);
			append_dev(div5, t2);
			append_dev(div5, div3);
			append_dev(div3, div0);
			append_dev(div0, t3);
			append_dev(div3, t4);
			append_dev(div3, div1);
			append_dev(div1, t5);
			append_dev(div3, t6);
			append_dev(div3, div2);
			append_dev(div2, t7);
			append_dev(div5, t8);
			append_dev(div5, div4);
			mount_component(about, div4, null);
			insert_dev(target, t9, anchor);
			mount_component(tabbar, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const profileheader_changes = {};
			if (dirty & /*username_value*/ 1) profileheader_changes.name = /*username_value*/ ctx[0];
			profileheader.$set(profileheader_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navbar.$$.fragment, local);
			transition_in(profileheader.$$.fragment, local);
			transition_in(about.$$.fragment, local);
			transition_in(tabbar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navbar.$$.fragment, local);
			transition_out(profileheader.$$.fragment, local);
			transition_out(about.$$.fragment, local);
			transition_out(tabbar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(navbar, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div5);
			destroy_component(profileheader);
			destroy_component(about);
			if (detaching) detach_dev(t9);
			destroy_component(tabbar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let username_value;

	const unsubscribe = username.subscribe(value => {
		$$invalidate(0, username_value = value);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Profile> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Profile", $$slots, []);

	$$self.$capture_state = () => ({
		Navbar,
		Tabbar,
		ProfileHeader,
		About,
		username,
		Router,
		Link,
		Route,
		username_value,
		unsubscribe
	});

	$$self.$inject_state = $$props => {
		if ("username_value" in $$props) $$invalidate(0, username_value = $$props.username_value);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [username_value];
}

class Profile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Profile",
			options,
			id: create_fragment$b.name
		});
	}
}

export default Profile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZmlsZS5mZDlmMzE1OS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUHJvZmlsZUhlYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9TaG93Y2FzZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9CYWRnZXMuc3ZlbHRlIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1yb3V0aW5nL3NyYy9jb250ZXh0cy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvaGlzdG9yeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvdXRpbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXJvdXRpbmcvc3JjL1JvdXRlci5zdmVsdGUiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXJvdXRpbmcvc3JjL1JvdXRlLnN2ZWx0ZSIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcm91dGluZy9zcmMvTGluay5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL3Byb2ZpbGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgYWxpYXMsIG5hbWUsIHByb2ZpbGVwaWN0dXJlLCBsZXZlbFxuPC9zY3JpcHQ+XG5cbjxtYWluPlxuICA8ZGl2IGlkPVwiaGVhZFwiPlxuICAgIDxkaXYgaWQ9XCJsYXllcjFcIiAvPlxuICAgIDxkaXYgaWQ9XCJjb250ZW50d3JhcHBlclwiPlxuICAgICAgPGRpdiBpZD1cImNvbnRlbnRcIj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGlkPVwicHJvZmlsZXBpY3R1cmVcIlxuICAgICAgICAgIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKHtwcm9maWxlcGljdHVyZX0pO1wiIC8+XG4gICAgICAgIDxkaXYgaWQ9XCJ1c2VyaW5mb1wiPlxuICAgICAgICAgIDxoMz57YWxpYXN9PC9oMz5cbiAgICAgICAgICA8aDU+e25hbWV9PC9oNT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDwhLS0gbmVlZCB0byByaWdodCBsb2dpYyBmb3IgaGFuZGxpbmcgYmFkZ2UgY29sb3IgLS0+XG4gICAgICAgIDxkaXYgaWQ9XCJsZXZlbFwiPntsZXZlbH08L2Rpdj5cbiAgICAgICAgPCEtLSBuZWVkIHRvIHJpZ2h0IGxvZ2ljIGZvciBoYW5kbGluZyBiYWRnZSBjb2xvciAtLT5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJsYXllcjJcIiBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybChndGEuanBnKTtcIiAvPlxuICAgIDxkaXYgaWQ9XCJsYXllcjNcIiAvPlxuICA8L2Rpdj5cbjwvbWFpbj5cblxuPHN0eWxlPlxuICAjaGVhZCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG5cbiAgI3VzZXJpbmZvIHtcbiAgICBtYXJnaW4tbGVmdDogMThweDtcbiAgfVxuXG4gICNsZXZlbCB7XG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgYm9yZGVyOiAycHggc29saWQgIzQ2N2EzYztcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbiAgICB3aWR0aDogMzVweDtcbiAgICBoZWlnaHQ6IDM1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgaDMge1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG5cbiAgaDUge1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBmb250LXdlaWdodDogMzAwO1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIGNvbG9yOiAjNjk2OTY5O1xuICB9XG5cbiAgI3Byb2ZpbGVwaWN0dXJlIHtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gICAgaGVpZ2h0OiA3NXB4O1xuICAgIHdpZHRoOiA3NXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgfVxuXG4gICNsYXllcjEge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHRvcCwgcmdiKDAsIDAsIDApLCByZ2JhKDAsIDAsIDAsIDApKTtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgei1pbmRleDogOTc1O1xuICB9XG5cbiAgI2NvbnRlbnR3cmFwcGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogOTk7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAjY29udGVudCB7XG4gICAgcGFkZGluZzogMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAjbGF5ZXIyIHtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTQwcHg7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgICB6LWluZGV4OiAzO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBvcGFjaXR5OiAwLjE7XG4gIH1cblxuICAjbGF5ZXIzIHtcbiAgICBiYWNrZ3JvdW5kOiAjMGYwYjIwO1xuICAgIGhlaWdodDogMTQwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICB6LWluZGV4OiAyO1xuICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBpbWFnZXM7XG48L3NjcmlwdD5cbjxkaXYgaWQ9XCJiYWRnZXNob3djYXNlXCI+XG4gIDxpbWcgc3JjPVwie2ltYWdlc1swXS5saW5rfVwiIHN0eWxlPVwiaGVpZ2h0OiAzMnB4O1wiIC8+XG4gIDxpbWcgc3JjPVwie2ltYWdlc1sxXS5saW5rfVwiIHN0eWxlPVwiaGVpZ2h0OiAzMnB4O1wiIC8+XG4gIDxpbWcgc3JjPVwie2ltYWdlc1syXS5saW5rfVwiIC8+XG4gIDxpbWcgc3JjPVwie2ltYWdlc1szXS5saW5rfVwiIHN0eWxlPVwiaGVpZ2h0OiAzNnB4O1wiIC8+XG4gIDxpbWcgc3JjPVwie2ltYWdlc1s0XS5saW5rfVwiIHN0eWxlPVwiaGVpZ2h0OiAzOHB4O1wiIC8+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAjYmFkZ2VzaG93Y2FzZSBpbWd7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICB9XG5cbiAgI2JhZGdlc2hvd2Nhc2V7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuPC9zdHlsZT5cblxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IE1haW5CYWRnZSBmcm9tICcuL01haW5CYWRnZS5zdmVsdGUnXG4gIGltcG9ydCBTaG93Y2FzZSBmcm9tICcuL1Nob3djYXNlLnN2ZWx0ZSdcbjwvc2NyaXB0PlxuXG48ZGl2IGlkPVwiYmFkZ2VzXCI+XG4gIDxkaXYgaWQ9XCJ0aXRsZVwiPlxuICAgIDxoMz5CYWRnZXM8L2gzPlxuICAgIDxoMj44PC9oMj5cbiAgPC9kaXY+XG4gIDxNYWluQmFkZ2UgLz5cbiAgPFNob3djYXNlIGltYWdlcz17W3tsaW5rOiBcImh0dHBzOi8vc3RlYW1jb21tdW5pdHktYS5ha2FtYWloZC5uZXQvcHVibGljL2ltYWdlcy9iYWRnZXMvMzdfc3VtbWVyMjAxOS9sZXZlbDI1XzgwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNkbi1hLmFrYW1haWhkLm5ldC9zdGVhbWNvbW11bml0eS9wdWJsaWMvaW1hZ2VzL2l0ZW1zLzczMC81NGU0MGI5ZTIyODhmYmFiOGJkNGM2NTM3YjAzMjVkNDA1YzdlMWIwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNvbW11bml0eS1hLmFrYW1haWhkLm5ldC9wdWJsaWMvaW1hZ2VzL2JhZGdlcy8yOF9zcHJpbmdjbGVhbmluZzIwMTgvYnJvbnplXzgwLnBuZ1wifSwge2xpbms6IFwiaHR0cHM6Ly9zdGVhbWNkbi1hLmFrYW1haWhkLm5ldC9zdGVhbWNvbW11bml0eS9wdWJsaWMvaW1hZ2VzL2l0ZW1zLzc2MjgwMC9kNDY3ZWM4ZWFlZDQ2NDNjNDdmYmVkNDNlZDc4MWRhZWYyNTI1OTYzLnBuZ1wifSwge2xpbmsgOiBcImh0dHBzOi8vc3RlYW1jb21tdW5pdHktYS5ha2FtYWloZC5uZXQvcHVibGljL2ltYWdlcy9iYWRnZXMvMjdfc3RlYW1hd2FyZG5vbWluYXRpb25zL2xldmVsMDRfODAucG5nXCJ9XX0gLz5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICNiYWRnZXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMwZjBiMjA7XG4gICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICBncmlkLWNvbHVtbjogMS8yO1xuICAgIGdyaWQtcm93OiAyLzQ7XG4gIH1cblxuICAjdGl0bGUge1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG48L3N0eWxlPlxuIiwiZXhwb3J0IGNvbnN0IExPQ0FUSU9OID0ge307XG5leHBvcnQgY29uc3QgUk9VVEVSID0ge307XG4iLCIvKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcm91dGVyL2Jsb2IvYjYwZTZkZDc4MWQ1ZDNhNGJkYWFmNGRlNjY1NjQ5YzBmNmE3ZTc4ZC9zcmMvbGliL2hpc3RvcnkuanNcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY2gvcm91dGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqICovXG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uKHNvdXJjZSkge1xuICByZXR1cm4ge1xuICAgIC4uLnNvdXJjZS5sb2NhdGlvbixcbiAgICBzdGF0ZTogc291cmNlLmhpc3Rvcnkuc3RhdGUsXG4gICAga2V5OiAoc291cmNlLmhpc3Rvcnkuc3RhdGUgJiYgc291cmNlLmhpc3Rvcnkuc3RhdGUua2V5KSB8fCBcImluaXRpYWxcIlxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIaXN0b3J5KHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgbGV0IGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcblxuICByZXR1cm4ge1xuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIGNvbnN0IHBvcHN0YXRlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcbiAgICAgICAgbGlzdGVuZXIoeyBsb2NhdGlvbiwgYWN0aW9uOiBcIlBPUFwiIH0pO1xuICAgICAgfTtcblxuICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUxpc3RlbmVyKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BzdGF0ZUxpc3RlbmVyKTtcblxuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBuYXZpZ2F0ZSh0bywgeyBzdGF0ZSwgcmVwbGFjZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgc3RhdGUgPSB7IC4uLnN0YXRlLCBrZXk6IERhdGUubm93KCkgKyBcIlwiIH07XG4gICAgICAvLyB0cnkuLi5jYXRjaCBpT1MgU2FmYXJpIGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gICAgICB0cnkge1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgIHNvdXJjZS5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgbnVsbCwgdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZS5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgbnVsbCwgdG8pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNvdXJjZS5sb2NhdGlvbltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcImFzc2lnblwiXSh0byk7XG4gICAgICB9XG5cbiAgICAgIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKHsgbG9jYXRpb24sIGFjdGlvbjogXCJQVVNIXCIgfSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gU3RvcmVzIGhpc3RvcnkgZW50cmllcyBpbiBtZW1vcnkgZm9yIHRlc3Rpbmcgb3Igb3RoZXIgcGxhdGZvcm1zIGxpa2UgTmF0aXZlXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlTb3VyY2UoaW5pdGlhbFBhdGhuYW1lID0gXCIvXCIpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3Qgc3RhY2sgPSBbeyBwYXRobmFtZTogaW5pdGlhbFBhdGhuYW1lLCBzZWFyY2g6IFwiXCIgfV07XG4gIGNvbnN0IHN0YXRlcyA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YWNrW2luZGV4XTtcbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZm4pIHt9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZm4pIHt9LFxuICAgIGhpc3Rvcnk6IHtcbiAgICAgIGdldCBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICB9LFxuICAgICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9LFxuICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc3RhdGVzW2luZGV4XTtcbiAgICAgIH0sXG4gICAgICBwdXNoU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICBjb25zdCBbcGF0aG5hbWUsIHNlYXJjaCA9IFwiXCJdID0gdXJpLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgc3RhY2sucHVzaCh7IHBhdGhuYW1lLCBzZWFyY2ggfSk7XG4gICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICByZXBsYWNlU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICBjb25zdCBbcGF0aG5hbWUsIHNlYXJjaCA9IFwiXCJdID0gdXJpLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgc3RhY2tbaW5kZXhdID0geyBwYXRobmFtZSwgc2VhcmNoIH07XG4gICAgICAgIHN0YXRlc1tpbmRleF0gPSBzdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIEdsb2JhbCBoaXN0b3J5IHVzZXMgd2luZG93Lmhpc3RvcnkgYXMgdGhlIHNvdXJjZSBpZiBhdmFpbGFibGUsXG4vLyBvdGhlcndpc2UgYSBtZW1vcnkgaGlzdG9yeVxuY29uc3QgY2FuVXNlRE9NID0gQm9vbGVhbihcbiAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuY29uc3QgZ2xvYmFsSGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoY2FuVXNlRE9NID8gd2luZG93IDogY3JlYXRlTWVtb3J5U291cmNlKCkpO1xuY29uc3QgeyBuYXZpZ2F0ZSB9ID0gZ2xvYmFsSGlzdG9yeTtcblxuZXhwb3J0IHsgZ2xvYmFsSGlzdG9yeSwgbmF2aWdhdGUsIGNyZWF0ZUhpc3RvcnksIGNyZWF0ZU1lbW9yeVNvdXJjZSB9O1xuIiwiLyoqXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3JlYWNoL3JvdXRlci9ibG9iL2I2MGU2ZGQ3ODFkNWQzYTRiZGFhZjRkZTY2NTY0OWMwZjZhN2U3OGQvc3JjL2xpYi91dGlscy5qc1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjaC9yb3V0ZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogKi9cblxuY29uc3QgcGFyYW1SZSA9IC9eOiguKykvO1xuXG5jb25zdCBTRUdNRU5UX1BPSU5UUyA9IDQ7XG5jb25zdCBTVEFUSUNfUE9JTlRTID0gMztcbmNvbnN0IERZTkFNSUNfUE9JTlRTID0gMjtcbmNvbnN0IFNQTEFUX1BFTkFMVFkgPSAxO1xuY29uc3QgUk9PVF9QT0lOVFMgPSAxO1xuXG4vKipcbiAqIENoZWNrIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGBzZWFyY2hgXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHNlYXJjaCkge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBzZWdtZW50YCBpcyBhIHJvb3Qgc2VnbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlZ21lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUm9vdFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gXCJcIjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgc2VnbWVudGAgaXMgYSBkeW5hbWljIHNlZ21lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWdtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0R5bmFtaWMoc2VnbWVudCkge1xuICByZXR1cm4gcGFyYW1SZS50ZXN0KHNlZ21lbnQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBzZWdtZW50YCBpcyBhIHNwbGF0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VnbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGxhdChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50WzBdID09PSBcIipcIjtcbn1cblxuLyoqXG4gKiBTcGxpdCB1cCB0aGUgVVJJIGludG8gc2VnbWVudHMgZGVsaW1pdGVkIGJ5IGAvYFxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRpemUodXJpKSB7XG4gIHJldHVybiAoXG4gICAgdXJpXG4gICAgICAvLyBTdHJpcCBzdGFydGluZy9lbmRpbmcgYC9gXG4gICAgICAucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCBcIlwiKVxuICAgICAgLnNwbGl0KFwiL1wiKVxuICApO1xufVxuXG4vKipcbiAqIFN0cmlwIGBzdHJgIG9mIHBvdGVudGlhbCBzdGFydCBhbmQgZW5kIGAvYFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpcFNsYXNoZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLCBcIlwiKTtcbn1cblxuLyoqXG4gKiBTY29yZSBhIHJvdXRlIGRlcGVuZGluZyBvbiBob3cgaXRzIGluZGl2aWR1YWwgc2VnbWVudHMgbG9va1xuICogQHBhcmFtIHtvYmplY3R9IHJvdXRlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmFua1JvdXRlKHJvdXRlLCBpbmRleCkge1xuICBjb25zdCBzY29yZSA9IHJvdXRlLmRlZmF1bHRcbiAgICA/IDBcbiAgICA6IHNlZ21lbnRpemUocm91dGUucGF0aCkucmVkdWNlKChzY29yZSwgc2VnbWVudCkgPT4ge1xuICAgICAgICBzY29yZSArPSBTRUdNRU5UX1BPSU5UUztcblxuICAgICAgICBpZiAoaXNSb290U2VnbWVudChzZWdtZW50KSkge1xuICAgICAgICAgIHNjb3JlICs9IFJPT1RfUE9JTlRTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRHluYW1pYyhzZWdtZW50KSkge1xuICAgICAgICAgIHNjb3JlICs9IERZTkFNSUNfUE9JTlRTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3BsYXQoc2VnbWVudCkpIHtcbiAgICAgICAgICBzY29yZSAtPSBTRUdNRU5UX1BPSU5UUyArIFNQTEFUX1BFTkFMVFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcmUgKz0gU1RBVElDX1BPSU5UUztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICAgIH0sIDApO1xuXG4gIHJldHVybiB7IHJvdXRlLCBzY29yZSwgaW5kZXggfTtcbn1cblxuLyoqXG4gKiBHaXZlIGEgc2NvcmUgdG8gYWxsIHJvdXRlcyBhbmQgc29ydCB0aGVtIG9uIHRoYXRcbiAqIEBwYXJhbSB7b2JqZWN0W119IHJvdXRlc1xuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHJhbmtSb3V0ZXMocm91dGVzKSB7XG4gIHJldHVybiAoXG4gICAgcm91dGVzXG4gICAgICAubWFwKHJhbmtSb3V0ZSlcbiAgICAgIC8vIElmIHR3byByb3V0ZXMgaGF2ZSB0aGUgZXhhY3Qgc2FtZSBzY29yZSwgd2UgZ28gYnkgaW5kZXggaW5zdGVhZFxuICAgICAgLnNvcnQoKGEsIGIpID0+XG4gICAgICAgIGEuc2NvcmUgPCBiLnNjb3JlID8gMSA6IGEuc2NvcmUgPiBiLnNjb3JlID8gLTEgOiBhLmluZGV4IC0gYi5pbmRleFxuICAgICAgKVxuICApO1xufVxuXG4vKipcbiAqIFJhbmtzIGFuZCBwaWNrcyB0aGUgYmVzdCByb3V0ZSB0byBtYXRjaC4gRWFjaCBzZWdtZW50IGdldHMgdGhlIGhpZ2hlc3RcbiAqIGFtb3VudCBvZiBwb2ludHMsIHRoZW4gdGhlIHR5cGUgb2Ygc2VnbWVudCBnZXRzIGFuIGFkZGl0aW9uYWwgYW1vdW50IG9mXG4gKiBwb2ludHMgd2hlcmVcbiAqXG4gKiAgc3RhdGljID4gZHluYW1pYyA+IHNwbGF0ID4gcm9vdFxuICpcbiAqIFRoaXMgd2F5IHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhlIG9yZGVyIG9mIG91ciByb3V0ZXMsIGxldCB0aGVcbiAqIGNvbXB1dGVycyBkbyBpdC5cbiAqXG4gKiBBIHJvdXRlIGxvb2tzIGxpa2UgdGhpc1xuICpcbiAqICB7IHBhdGgsIGRlZmF1bHQsIHZhbHVlIH1cbiAqXG4gKiBBbmQgYSByZXR1cm5lZCBtYXRjaCBsb29rcyBsaWtlOlxuICpcbiAqICB7IHJvdXRlLCBwYXJhbXMsIHVyaSB9XG4gKlxuICogQHBhcmFtIHtvYmplY3RbXX0gcm91dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwaWNrKHJvdXRlcywgdXJpKSB7XG4gIGxldCBtYXRjaDtcbiAgbGV0IGRlZmF1bHRfO1xuXG4gIGNvbnN0IFt1cmlQYXRobmFtZV0gPSB1cmkuc3BsaXQoXCI/XCIpO1xuICBjb25zdCB1cmlTZWdtZW50cyA9IHNlZ21lbnRpemUodXJpUGF0aG5hbWUpO1xuICBjb25zdCBpc1Jvb3RVcmkgPSB1cmlTZWdtZW50c1swXSA9PT0gXCJcIjtcbiAgY29uc3QgcmFua2VkID0gcmFua1JvdXRlcyhyb3V0ZXMpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcmFua2VkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHJvdXRlID0gcmFua2VkW2ldLnJvdXRlO1xuICAgIGxldCBtaXNzZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb3V0ZS5kZWZhdWx0KSB7XG4gICAgICBkZWZhdWx0XyA9IHtcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIHVyaVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlU2VnbWVudHMgPSBzZWdtZW50aXplKHJvdXRlLnBhdGgpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHVyaVNlZ21lbnRzLmxlbmd0aCwgcm91dGVTZWdtZW50cy5sZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHJvdXRlU2VnbWVudCA9IHJvdXRlU2VnbWVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgdXJpU2VnbWVudCA9IHVyaVNlZ21lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKHJvdXRlU2VnbWVudCAhPT0gdW5kZWZpbmVkICYmIGlzU3BsYXQocm91dGVTZWdtZW50KSkge1xuICAgICAgICAvLyBIaXQgYSBzcGxhdCwganVzdCBncmFiIHRoZSByZXN0LCBhbmQgcmV0dXJuIGEgbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC9maWxlcy9kb2N1bWVudHMvd29ya1xuICAgICAgICAvLyByb3V0ZTogL2ZpbGVzLyogb3IgL2ZpbGVzLypzcGxhdG5hbWVcbiAgICAgICAgY29uc3Qgc3BsYXROYW1lID0gcm91dGVTZWdtZW50ID09PSBcIipcIiA/IFwiKlwiIDogcm91dGVTZWdtZW50LnNsaWNlKDEpO1xuXG4gICAgICAgIHBhcmFtc1tzcGxhdE5hbWVdID0gdXJpU2VnbWVudHNcbiAgICAgICAgICAuc2xpY2UoaW5kZXgpXG4gICAgICAgICAgLm1hcChkZWNvZGVVUklDb21wb25lbnQpXG4gICAgICAgICAgLmpvaW4oXCIvXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHVyaVNlZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBVUkkgaXMgc2hvcnRlciB0aGFuIHRoZSByb3V0ZSwgbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vyc1xuICAgICAgICAvLyByb3V0ZTogL3VzZXJzLzp1c2VySWRcbiAgICAgICAgbWlzc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBkeW5hbWljTWF0Y2ggPSBwYXJhbVJlLmV4ZWMocm91dGVTZWdtZW50KTtcblxuICAgICAgaWYgKGR5bmFtaWNNYXRjaCAmJiAhaXNSb290VXJpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVNlZ21lbnQpO1xuICAgICAgICBwYXJhbXNbZHluYW1pY01hdGNoWzFdXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChyb3V0ZVNlZ21lbnQgIT09IHVyaVNlZ21lbnQpIHtcbiAgICAgICAgLy8gQ3VycmVudCBzZWdtZW50cyBkb24ndCBtYXRjaCwgbm90IGR5bmFtaWMsIG5vdCBzcGxhdCwgc28gbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vycy8xMjMvc2V0dGluZ3NcbiAgICAgICAgLy8gcm91dGU6IC91c2Vycy86aWQvcHJvZmlsZVxuICAgICAgICBtaXNzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1pc3NlZCkge1xuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHVyaTogXCIvXCIgKyB1cmlTZWdtZW50cy5zbGljZSgwLCBpbmRleCkuam9pbihcIi9cIilcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2ggfHwgZGVmYXVsdF8gfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYHBhdGhgIG1hdGNoZXMgdGhlIGB1cmlgLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hdGNoKHJvdXRlLCB1cmkpIHtcbiAgcmV0dXJuIHBpY2soW3JvdXRlXSwgdXJpKTtcbn1cblxuLyoqXG4gKiBBZGQgdGhlIHF1ZXJ5IHRvIHRoZSBwYXRobmFtZSBpZiBhIHF1ZXJ5IGlzIGdpdmVuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcnldXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGFkZFF1ZXJ5KHBhdGhuYW1lLCBxdWVyeSkge1xuICByZXR1cm4gcGF0aG5hbWUgKyAocXVlcnkgPyBgPyR7cXVlcnl9YCA6IFwiXCIpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgVVJJcyBhcyB0aG91Z2ggZXZlcnkgcGF0aCBpcyBhIGRpcmVjdG9yeSwgbm8gZmlsZXMuIFJlbGF0aXZlIFVSSXNcbiAqIGluIHRoZSBicm93c2VyIGNhbiBmZWVsIGF3a3dhcmQgYmVjYXVzZSBub3Qgb25seSBjYW4geW91IGJlIFwiaW4gYSBkaXJlY3RvcnlcIixcbiAqIHlvdSBjYW4gYmUgXCJhdCBhIGZpbGVcIiwgdG9vLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgYnJvd3NlclNwZWNSZXNvbHZlKCdmb28nLCAnL2Jhci8nKSA9PiAvYmFyL2Zvb1xuICogIGJyb3dzZXJTcGVjUmVzb2x2ZSgnZm9vJywgJy9iYXInKSA9PiAvZm9vXG4gKlxuICogQnV0IG9uIHRoZSBjb21tYW5kIGxpbmUgb2YgYSBmaWxlIHN5c3RlbSwgaXQncyBub3QgYXMgY29tcGxpY2F0ZWQuIFlvdSBjYW4ndFxuICogYGNkYCBmcm9tIGEgZmlsZSwgb25seSBkaXJlY3Rvcmllcy4gVGhpcyB3YXksIGxpbmtzIGhhdmUgdG8ga25vdyBsZXNzIGFib3V0XG4gKiB0aGVpciBjdXJyZW50IHBhdGguIFRvIGdvIGRlZXBlciB5b3UgY2FuIGRvIHRoaXM6XG4gKlxuICogIDxMaW5rIHRvPVwiZGVlcGVyXCIvPlxuICogIC8vIGluc3RlYWQgb2ZcbiAqICA8TGluayB0bz1geyR7cHJvcHMudXJpfS9kZWVwZXJ9YC8+XG4gKlxuICogSnVzdCBsaWtlIGBjZGAsIGlmIHlvdSB3YW50IHRvIGdvIGRlZXBlciBmcm9tIHRoZSBjb21tYW5kIGxpbmUsIHlvdSBkbyB0aGlzOlxuICpcbiAqICBjZCBkZWVwZXJcbiAqICAjIG5vdFxuICogIGNkICQocHdkKS9kZWVwZXJcbiAqXG4gKiBCeSB0cmVhdGluZyBldmVyeSBwYXRoIGFzIGEgZGlyZWN0b3J5LCBsaW5raW5nIHRvIHJlbGF0aXZlIHBhdGhzIHNob3VsZFxuICogcmVxdWlyZSBsZXNzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIChmaW5nZXJzIGNyb3NzZWQpIGJlIG1vcmUgaW50dWl0aXZlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHRvLCBiYXNlKSB7XG4gIC8vIC9mb28vYmFyLCAvYmF6L3F1eCA9PiAvZm9vL2JhclxuICBpZiAoc3RhcnRzV2l0aCh0bywgXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgY29uc3QgW3RvUGF0aG5hbWUsIHRvUXVlcnldID0gdG8uc3BsaXQoXCI/XCIpO1xuICBjb25zdCBbYmFzZVBhdGhuYW1lXSA9IGJhc2Uuc3BsaXQoXCI/XCIpO1xuICBjb25zdCB0b1NlZ21lbnRzID0gc2VnbWVudGl6ZSh0b1BhdGhuYW1lKTtcbiAgY29uc3QgYmFzZVNlZ21lbnRzID0gc2VnbWVudGl6ZShiYXNlUGF0aG5hbWUpO1xuXG4gIC8vID9hPWIsIC91c2Vycz9iPWMgPT4gL3VzZXJzP2E9YlxuICBpZiAodG9TZWdtZW50c1swXSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhZGRRdWVyeShiYXNlUGF0aG5hbWUsIHRvUXVlcnkpO1xuICB9XG5cbiAgLy8gcHJvZmlsZSwgL3VzZXJzLzc4OSA9PiAvdXNlcnMvNzg5L3Byb2ZpbGVcbiAgaWYgKCFzdGFydHNXaXRoKHRvU2VnbWVudHNbMF0sIFwiLlwiKSkge1xuICAgIGNvbnN0IHBhdGhuYW1lID0gYmFzZVNlZ21lbnRzLmNvbmNhdCh0b1NlZ21lbnRzKS5qb2luKFwiL1wiKTtcblxuICAgIHJldHVybiBhZGRRdWVyeSgoYmFzZVBhdGhuYW1lID09PSBcIi9cIiA/IFwiXCIgOiBcIi9cIikgKyBwYXRobmFtZSwgdG9RdWVyeSk7XG4gIH1cblxuICAvLyAuLyAgICAgICAsIC91c2Vycy8xMjMgPT4gL3VzZXJzLzEyM1xuICAvLyAuLi8gICAgICAsIC91c2Vycy8xMjMgPT4gL3VzZXJzXG4gIC8vIC4uLy4uICAgICwgL3VzZXJzLzEyMyA9PiAvXG4gIC8vIC4uLy4uL29uZSwgL2EvYi9jL2QgICA9PiAvYS9iL29uZVxuICAvLyAuLi8uL29uZSAsIC9hL2IvYy9kICAgPT4gL2EvYi9jL29uZVxuICBjb25zdCBhbGxTZWdtZW50cyA9IGJhc2VTZWdtZW50cy5jb25jYXQodG9TZWdtZW50cyk7XG4gIGNvbnN0IHNlZ21lbnRzID0gW107XG5cbiAgYWxsU2VnbWVudHMuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICBpZiAoc2VnbWVudCA9PT0gXCIuLlwiKSB7XG4gICAgICBzZWdtZW50cy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGFkZFF1ZXJ5KFwiL1wiICsgc2VnbWVudHMuam9pbihcIi9cIiksIHRvUXVlcnkpO1xufVxuXG4vKipcbiAqIENvbWJpbmVzIHRoZSBgYmFzZXBhdGhgIGFuZCB0aGUgYHBhdGhgIGludG8gb25lIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVQYXRocyhiYXNlcGF0aCwgcGF0aCkge1xuICByZXR1cm4gYCR7c3RyaXBTbGFzaGVzKFxuICAgIHBhdGggPT09IFwiL1wiID8gYmFzZXBhdGggOiBgJHtzdHJpcFNsYXNoZXMoYmFzZXBhdGgpfS8ke3N0cmlwU2xhc2hlcyhwYXRoKX1gXG4gICl9L2A7XG59XG5cbi8qKlxuICogRGVjaWRlcyB3aGV0aGVyIGEgZ2l2ZW4gYGV2ZW50YCBzaG91bGQgcmVzdWx0IGluIGEgbmF2aWdhdGlvbiBvciBub3QuXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkTmF2aWdhdGUoZXZlbnQpIHtcbiAgcmV0dXJuIChcbiAgICAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJlxuICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJlxuICAgICEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gaG9zdE1hdGNoZXMoYW5jaG9yKSB7XG4gIGNvbnN0IGhvc3QgPSBsb2NhdGlvbi5ob3N0XG4gIHJldHVybiAoXG4gICAgYW5jaG9yLmhvc3QgPT0gaG9zdCB8fFxuICAgIC8vIHN2ZWx0ZSBzZWVtcyB0byBraWxsIGFuY2hvci5ob3N0IHZhbHVlIGluIGllMTEsIHNvIGZhbGwgYmFjayB0byBjaGVja2luZyBocmVmXG4gICAgYW5jaG9yLmhyZWYuaW5kZXhPZihgaHR0cHM6Ly8ke2hvc3R9YCkgPT09IDAgfHxcbiAgICBhbmNob3IuaHJlZi5pbmRleE9mKGBodHRwOi8vJHtob3N0fWApID09PSAwXG4gIClcbn1cblxuZXhwb3J0IHsgc3RyaXBTbGFzaGVzLCBwaWNrLCBtYXRjaCwgcmVzb2x2ZSwgY29tYmluZVBhdGhzLCBzaG91bGROYXZpZ2F0ZSwgaG9zdE1hdGNoZXMgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIHNldENvbnRleHQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IHdyaXRhYmxlLCBkZXJpdmVkIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuICBpbXBvcnQgeyBMT0NBVElPTiwgUk9VVEVSIH0gZnJvbSBcIi4vY29udGV4dHMuanNcIjtcbiAgaW1wb3J0IHsgZ2xvYmFsSGlzdG9yeSB9IGZyb20gXCIuL2hpc3RvcnkuanNcIjtcbiAgaW1wb3J0IHsgcGljaywgbWF0Y2gsIHN0cmlwU2xhc2hlcywgY29tYmluZVBhdGhzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuICBleHBvcnQgbGV0IGJhc2VwYXRoID0gXCIvXCI7XG4gIGV4cG9ydCBsZXQgdXJsID0gbnVsbDtcblxuICBjb25zdCBsb2NhdGlvbkNvbnRleHQgPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcbiAgY29uc3Qgcm91dGVyQ29udGV4dCA9IGdldENvbnRleHQoUk9VVEVSKTtcblxuICBjb25zdCByb3V0ZXMgPSB3cml0YWJsZShbXSk7XG4gIGNvbnN0IGFjdGl2ZVJvdXRlID0gd3JpdGFibGUobnVsbCk7XG4gIGxldCBoYXNBY3RpdmVSb3V0ZSA9IGZhbHNlOyAvLyBVc2VkIGluIFNTUiB0byBzeW5jaHJvbm91c2x5IHNldCB0aGF0IGEgUm91dGUgaXMgYWN0aXZlLlxuXG4gIC8vIElmIGxvY2F0aW9uQ29udGV4dCBpcyBub3Qgc2V0LCB0aGlzIGlzIHRoZSB0b3Btb3N0IFJvdXRlciBpbiB0aGUgdHJlZS5cbiAgLy8gSWYgdGhlIGB1cmxgIHByb3AgaXMgZ2l2ZW4gd2UgZm9yY2UgdGhlIGxvY2F0aW9uIHRvIGl0LlxuICBjb25zdCBsb2NhdGlvbiA9XG4gICAgbG9jYXRpb25Db250ZXh0IHx8XG4gICAgd3JpdGFibGUodXJsID8geyBwYXRobmFtZTogdXJsIH0gOiBnbG9iYWxIaXN0b3J5LmxvY2F0aW9uKTtcblxuICAvLyBJZiByb3V0ZXJDb250ZXh0IGlzIHNldCwgdGhlIHJvdXRlckJhc2Ugb2YgdGhlIHBhcmVudCBSb3V0ZXJcbiAgLy8gd2lsbCBiZSB0aGUgYmFzZSBmb3IgdGhpcyBSb3V0ZXIncyBkZXNjZW5kYW50cy5cbiAgLy8gSWYgcm91dGVyQ29udGV4dCBpcyBub3Qgc2V0LCB0aGUgcGF0aCBhbmQgcmVzb2x2ZWQgdXJpIHdpbGwgYm90aFxuICAvLyBoYXZlIHRoZSB2YWx1ZSBvZiB0aGUgYmFzZXBhdGggcHJvcC5cbiAgY29uc3QgYmFzZSA9IHJvdXRlckNvbnRleHRcbiAgICA/IHJvdXRlckNvbnRleHQucm91dGVyQmFzZVxuICAgIDogd3JpdGFibGUoe1xuICAgICAgICBwYXRoOiBiYXNlcGF0aCxcbiAgICAgICAgdXJpOiBiYXNlcGF0aFxuICAgICAgfSk7XG5cbiAgY29uc3Qgcm91dGVyQmFzZSA9IGRlcml2ZWQoW2Jhc2UsIGFjdGl2ZVJvdXRlXSwgKFtiYXNlLCBhY3RpdmVSb3V0ZV0pID0+IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhY3RpdmVSb3V0ZSwgdGhlIHJvdXRlckJhc2Ugd2lsbCBiZSBpZGVudGljYWwgdG8gdGhlIGJhc2UuXG4gICAgaWYgKGFjdGl2ZVJvdXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHBhdGg6IGJhc2VwYXRoIH0gPSBiYXNlO1xuICAgIGNvbnN0IHsgcm91dGUsIHVyaSB9ID0gYWN0aXZlUm91dGU7XG4gICAgLy8gUmVtb3ZlIHRoZSBwb3RlbnRpYWwgLyogb3IgLypzcGxhdG5hbWUgZnJvbVxuICAgIC8vIHRoZSBlbmQgb2YgdGhlIGNoaWxkIFJvdXRlcyByZWxhdGl2ZSBwYXRocy5cbiAgICBjb25zdCBwYXRoID0gcm91dGUuZGVmYXVsdCA/IGJhc2VwYXRoIDogcm91dGUucGF0aC5yZXBsYWNlKC9cXCouKiQvLCBcIlwiKTtcblxuICAgIHJldHVybiB7IHBhdGgsIHVyaSB9O1xuICB9KTtcblxuICBmdW5jdGlvbiByZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgY29uc3QgeyBwYXRoOiBiYXNlcGF0aCB9ID0gJGJhc2U7XG4gICAgbGV0IHsgcGF0aCB9ID0gcm91dGU7XG5cbiAgICAvLyBXZSBzdG9yZSB0aGUgb3JpZ2luYWwgcGF0aCBpbiB0aGUgX3BhdGggcHJvcGVydHkgc28gd2UgY2FuIHJldXNlXG4gICAgLy8gaXQgd2hlbiB0aGUgYmFzZXBhdGggY2hhbmdlcy4gVGhlIG9ubHkgdGhpbmcgdGhhdCBtYXR0ZXJzIGlzIHRoYXRcbiAgICAvLyB0aGUgcm91dGUgcmVmZXJlbmNlIGlzIGludGFjdCwgc28gbXV0YXRpb24gaXMgZmluZS5cbiAgICByb3V0ZS5fcGF0aCA9IHBhdGg7XG4gICAgcm91dGUucGF0aCA9IGNvbWJpbmVQYXRocyhiYXNlcGF0aCwgcGF0aCk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gSW4gU1NSIHdlIHNob3VsZCBzZXQgdGhlIGFjdGl2ZVJvdXRlIGltbWVkaWF0ZWx5IGlmIGl0IGlzIGEgbWF0Y2guXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBSb3V0ZXMgYmVpbmcgcmVnaXN0ZXJlZCBhZnRlciBhIG1hdGNoIGlzIGZvdW5kLFxuICAgICAgLy8gd2UganVzdCBza2lwIHRoZW0uXG4gICAgICBpZiAoaGFzQWN0aXZlUm91dGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaGluZ1JvdXRlID0gbWF0Y2gocm91dGUsICRsb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hpbmdSb3V0ZSkge1xuICAgICAgICBhY3RpdmVSb3V0ZS5zZXQobWF0Y2hpbmdSb3V0ZSk7XG4gICAgICAgIGhhc0FjdGl2ZVJvdXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVzLnVwZGF0ZShycyA9PiB7XG4gICAgICAgIHJzLnB1c2gocm91dGUpO1xuICAgICAgICByZXR1cm4gcnM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICByb3V0ZXMudXBkYXRlKHJzID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcnMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICBycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHJzO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVGhpcyByZWFjdGl2ZSBzdGF0ZW1lbnQgd2lsbCB1cGRhdGUgYWxsIHRoZSBSb3V0ZXMnIHBhdGggd2hlblxuICAvLyB0aGUgYmFzZXBhdGggY2hhbmdlcy5cbiAgJDoge1xuICAgIGNvbnN0IHsgcGF0aDogYmFzZXBhdGggfSA9ICRiYXNlO1xuICAgIHJvdXRlcy51cGRhdGUocnMgPT4ge1xuICAgICAgcnMuZm9yRWFjaChyID0+IChyLnBhdGggPSBjb21iaW5lUGF0aHMoYmFzZXBhdGgsIHIuX3BhdGgpKSk7XG4gICAgICByZXR1cm4gcnM7XG4gICAgfSk7XG4gIH1cbiAgLy8gVGhpcyByZWFjdGl2ZSBzdGF0ZW1lbnQgd2lsbCBiZSBydW4gd2hlbiB0aGUgUm91dGVyIGlzIGNyZWF0ZWRcbiAgLy8gd2hlbiB0aGVyZSBhcmUgbm8gUm91dGVzIGFuZCB0aGVuIGFnYWluIHRoZSBmb2xsb3dpbmcgdGljaywgc28gaXRcbiAgLy8gd2lsbCBub3QgZmluZCBhbiBhY3RpdmUgUm91dGUgaW4gU1NSIGFuZCBpbiB0aGUgYnJvd3NlciBpdCB3aWxsIG9ubHlcbiAgLy8gcGljayBhbiBhY3RpdmUgUm91dGUgYWZ0ZXIgYWxsIFJvdXRlcyBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cbiAgJDoge1xuICAgIGNvbnN0IGJlc3RNYXRjaCA9IHBpY2soJHJvdXRlcywgJGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICBhY3RpdmVSb3V0ZS5zZXQoYmVzdE1hdGNoKTtcbiAgfVxuXG4gIGlmICghbG9jYXRpb25Db250ZXh0KSB7XG4gICAgLy8gVGhlIHRvcG1vc3QgUm91dGVyIGluIHRoZSB0cmVlIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZ1xuICAgIC8vIHRoZSBsb2NhdGlvbiBzdG9yZSBhbmQgc3VwcGx5aW5nIGl0IHRocm91Z2ggY29udGV4dC5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgIGNvbnN0IHVubGlzdGVuID0gZ2xvYmFsSGlzdG9yeS5saXN0ZW4oaGlzdG9yeSA9PiB7XG4gICAgICAgIGxvY2F0aW9uLnNldChoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdW5saXN0ZW47XG4gICAgfSk7XG5cbiAgICBzZXRDb250ZXh0KExPQ0FUSU9OLCBsb2NhdGlvbik7XG4gIH1cblxuICBzZXRDb250ZXh0KFJPVVRFUiwge1xuICAgIGFjdGl2ZVJvdXRlLFxuICAgIGJhc2UsXG4gICAgcm91dGVyQmFzZSxcbiAgICByZWdpc3RlclJvdXRlLFxuICAgIHVucmVnaXN0ZXJSb3V0ZVxuICB9KTtcbjwvc2NyaXB0PlxuXG48c2xvdD48L3Nsb3Q+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0LCBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IFJPVVRFUiwgTE9DQVRJT04gfSBmcm9tIFwiLi9jb250ZXh0cy5qc1wiO1xuXG4gIGV4cG9ydCBsZXQgcGF0aCA9IFwiXCI7XG4gIGV4cG9ydCBsZXQgY29tcG9uZW50ID0gbnVsbDtcblxuICBjb25zdCB7IHJlZ2lzdGVyUm91dGUsIHVucmVnaXN0ZXJSb3V0ZSwgYWN0aXZlUm91dGUgfSA9IGdldENvbnRleHQoUk9VVEVSKTtcbiAgY29uc3QgbG9jYXRpb24gPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcblxuICBjb25zdCByb3V0ZSA9IHtcbiAgICBwYXRoLFxuICAgIC8vIElmIG5vIHBhdGggcHJvcCBpcyBnaXZlbiwgdGhpcyBSb3V0ZSB3aWxsIGFjdCBhcyB0aGUgZGVmYXVsdCBSb3V0ZVxuICAgIC8vIHRoYXQgaXMgcmVuZGVyZWQgaWYgbm8gb3RoZXIgUm91dGUgaW4gdGhlIFJvdXRlciBpcyBhIG1hdGNoLlxuICAgIGRlZmF1bHQ6IHBhdGggPT09IFwiXCJcbiAgfTtcbiAgbGV0IHJvdXRlUGFyYW1zID0ge307XG4gIGxldCByb3V0ZVByb3BzID0ge307XG5cbiAgJDogaWYgKCRhY3RpdmVSb3V0ZSAmJiAkYWN0aXZlUm91dGUucm91dGUgPT09IHJvdXRlKSB7XG4gICAgcm91dGVQYXJhbXMgPSAkYWN0aXZlUm91dGUucGFyYW1zO1xuICB9XG5cbiAgJDoge1xuICAgIGNvbnN0IHsgcGF0aCwgY29tcG9uZW50LCAuLi5yZXN0IH0gPSAkJHByb3BzO1xuICAgIHJvdXRlUHJvcHMgPSByZXN0O1xuICB9XG5cbiAgcmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG5cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1bnJlZ2lzdGVyIFJvdXRlcyBpbiBTU1Igc2luY2UgaXQgd2lsbCBhbGwgYmVcbiAgLy8gdGhyb3duIGF3YXkgYW55d2F5LlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyUm91dGUocm91dGUpO1xuICAgIH0pO1xuICB9XG48L3NjcmlwdD5cblxueyNpZiAkYWN0aXZlUm91dGUgIT09IG51bGwgJiYgJGFjdGl2ZVJvdXRlLnJvdXRlID09PSByb3V0ZX1cbiAgeyNpZiBjb21wb25lbnQgIT09IG51bGx9XG4gICAgPHN2ZWx0ZTpjb21wb25lbnQgdGhpcz1cIntjb21wb25lbnR9XCIgbG9jYXRpb249eyRsb2NhdGlvbn0gey4uLnJvdXRlUGFyYW1zfSB7Li4ucm91dGVQcm9wc30gIC8+XG4gIHs6ZWxzZX1cbiAgICA8c2xvdCBwYXJhbXM9XCJ7cm91dGVQYXJhbXN9XCIgbG9jYXRpb249eyRsb2NhdGlvbn0+PC9zbG90PlxuICB7L2lmfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgUk9VVEVSLCBMT0NBVElPTiB9IGZyb20gXCIuL2NvbnRleHRzLmpzXCI7XG4gIGltcG9ydCB7IG5hdmlnYXRlIH0gZnJvbSBcIi4vaGlzdG9yeS5qc1wiO1xuICBpbXBvcnQgeyBzdGFydHNXaXRoLCByZXNvbHZlLCBzaG91bGROYXZpZ2F0ZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cbiAgZXhwb3J0IGxldCB0byA9IFwiI1wiO1xuICBleHBvcnQgbGV0IHJlcGxhY2UgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBzdGF0ZSA9IHt9O1xuICBleHBvcnQgbGV0IGdldFByb3BzID0gKCkgPT4gKHt9KTtcblxuICBjb25zdCB7IGJhc2UgfSA9IGdldENvbnRleHQoUk9VVEVSKTtcbiAgY29uc3QgbG9jYXRpb24gPSBnZXRDb250ZXh0KExPQ0FUSU9OKTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBsZXQgaHJlZiwgaXNQYXJ0aWFsbHlDdXJyZW50LCBpc0N1cnJlbnQsIHByb3BzO1xuICAkOiBocmVmID0gdG8gPT09IFwiL1wiID8gJGJhc2UudXJpIDogcmVzb2x2ZSh0bywgJGJhc2UudXJpKTtcbiAgJDogaXNQYXJ0aWFsbHlDdXJyZW50ID0gc3RhcnRzV2l0aCgkbG9jYXRpb24ucGF0aG5hbWUsIGhyZWYpO1xuICAkOiBpc0N1cnJlbnQgPSBocmVmID09PSAkbG9jYXRpb24ucGF0aG5hbWU7XG4gICQ6IGFyaWFDdXJyZW50ID0gaXNDdXJyZW50ID8gXCJwYWdlXCIgOiB1bmRlZmluZWQ7XG4gICQ6IHByb3BzID0gZ2V0UHJvcHMoe1xuICAgIGxvY2F0aW9uOiAkbG9jYXRpb24sXG4gICAgaHJlZixcbiAgICBpc1BhcnRpYWxseUN1cnJlbnQsXG4gICAgaXNDdXJyZW50XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBkaXNwYXRjaChcImNsaWNrXCIsIGV2ZW50KTtcblxuICAgIGlmIChzaG91bGROYXZpZ2F0ZShldmVudCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBEb24ndCBwdXNoIGFub3RoZXIgZW50cnkgdG8gdGhlIGhpc3Rvcnkgc3RhY2sgd2hlbiB0aGUgdXNlclxuICAgICAgLy8gY2xpY2tzIG9uIGEgTGluayB0byB0aGUgcGFnZSB0aGV5IGFyZSBjdXJyZW50bHkgb24uXG4gICAgICBjb25zdCBzaG91bGRSZXBsYWNlID0gJGxvY2F0aW9uLnBhdGhuYW1lID09PSBocmVmIHx8IHJlcGxhY2U7XG4gICAgICBuYXZpZ2F0ZShocmVmLCB7IHN0YXRlLCByZXBsYWNlOiBzaG91bGRSZXBsYWNlIH0pO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxhIGhyZWY9XCJ7aHJlZn1cIiBhcmlhLWN1cnJlbnQ9XCJ7YXJpYUN1cnJlbnR9XCIgb246Y2xpY2s9XCJ7b25DbGlja31cIiB7Li4ucHJvcHN9PlxuICA8c2xvdD48L3Nsb3Q+XG48L2E+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgTmF2YmFyIGZyb20gJy4uL2NvbXBvbmVudHMvTmF2YmFyLnN2ZWx0ZSdcbiAgaW1wb3J0IFRhYmJhciBmcm9tICcuLi9jb21wb25lbnRzL1RhYmJhci5zdmVsdGUnXG4gIGltcG9ydCBQcm9maWxlSGVhZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvUHJvZmlsZUhlYWRlci5zdmVsdGUnXG4gIGltcG9ydCBBYm91dCBmcm9tICcuLi9jb21wb25lbnRzL0Fib3V0LnN2ZWx0ZSdcbiAgaW1wb3J0IHsgdXNlcm5hbWUgfSBmcm9tICcuL3N0b3Jlcy5qcydcbiAgaW1wb3J0IHsgUm91dGVyLCBMaW5rLCBSb3V0ZSB9IGZyb20gJ3N2ZWx0ZS1yb3V0aW5nJ1xuXG4gIGxldCB1c2VybmFtZV92YWx1ZVxuXG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gdXNlcm5hbWUuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgIHVzZXJuYW1lX3ZhbHVlID0gdmFsdWVcbiAgfSlcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT5Qcm9maWxlIDo6IFN0ZWFtIE1vYmlsZTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48TmF2YmFyIHRpdGxlPVwiUHJvZmlsZVwiIC8+XG48ZGl2IGlkPVwicHJvZmlsZVwiPlxuICA8UHJvZmlsZUhlYWRlclxuICAgIG5hbWU9e3VzZXJuYW1lX3ZhbHVlfVxuICAgIGFsaWFzPVwiYmluZ290aGVzbGF5ZXJcIlxuICAgIHByb2ZpbGVwaWN0dXJlPVwicHJvZmlsZXBpY3R1cmUuanBnXCJcbiAgICBsZXZlbD1cIjQwXCIgLz5cbiAgPGRpdiBpZD1cIm5hdnRyYXlcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VsZWN0ZWRcIj5BYm91dDwvZGl2PlxuICAgIDxkaXY+QWN0aXZpdHk8L2Rpdj5cbiAgICA8ZGl2PkludmVudG9yeTwvZGl2PlxuICA8L2Rpdj5cbiAgPGRpdiBpZD1cImNvbnRhaW5lclwiPlxuICAgIDxBYm91dCAvPlxuICA8L2Rpdj5cbjwvZGl2PlxuPFRhYmJhciBsb2NhdGlvbj17Mn0gLz5cblxuPHN0eWxlPlxuICAjY29udGFpbmVyIHtcbiAgICBwYWRkaW5nOiAyMHB4IDMwcHg7XG4gIH1cblxuICAjcHJvZmlsZSB7XG4gICAgcGFkZGluZzogNjBweCAwcHg7XG4gIH1cblxuICAjbmF2dHJheSB7XG4gICAgcGFkZGluZzogMHB4IDMwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgfVxuXG4gICNuYXZ0cmF5IGRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzBmMGIyMDtcbiAgICB3aWR0aDogMjIlO1xuICAgIGhlaWdodDogMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICB9XG5cbiAgLnNlbGVjdGVkIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjMDI3YWZmO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBYWUsR0FBSzs7O3NCQUNMLEdBQUk7Ozt1QkFHTSxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FKZixHQUFLOzs7OztzQ0FDTCxHQUFJOzs7Ozs7eUNBR00sR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttRUFOVSxHQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvRUFBZCxHQUFjOzs7dURBRXZDLEdBQUs7cURBQ0wsR0FBSTt1REFHTSxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FoQmpCLEtBQUs7SUFBRSxJQUFJO0lBQUUsY0FBYztJQUFFLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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LFFBQVEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFO0FBQ25DLEVBQUUsT0FBTyxRQUFRLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQzNCO0FBQ0EsRUFBRSxJQUFJLFVBQVUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDM0IsSUFBSSxPQUFPLEVBQUUsQ0FBQztBQUNkLEdBQUc7QUFDSDtBQUNBLEVBQUUsTUFBTSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDekMsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDNUMsRUFBRSxNQUFNLFlBQVksR0FBRyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDaEQ7QUFDQTtBQUNBLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO0FBQzVCLElBQUksT0FBTyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtBQUN2QyxJQUFJLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FB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
